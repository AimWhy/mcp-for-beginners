<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T19:37:36+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "my"
}
-->
# HTTPS Streaming နှင့် Model Context Protocol (MCP)

ဤအခန်းတွင် HTTPS ကို အသုံးပြု၍ Model Context Protocol (MCP) ဖြင့် လုံခြုံပြီး၊ တိုးချဲ့နိုင်ပြီး၊ အချိန်နှင့်တပြေးညီ စတရီမင်းလုပ်ဆောင်နိုင်မှုကို အပြည့်အစုံ လမ်းညွှန်ပေးထားသည်။ စတရီမင်းလုပ်ဆောင်ရန် အကြောင်းရင်း၊ ရရှိနိုင်သော သယ်ယူပို့ဆောင်မှုနည်းလမ်းများ၊ MCP တွင် streamable HTTP ကို မည်သို့ အကောင်အထည်ဖော်မည်၊ လုံခြုံရေးအကောင်းဆုံး လေ့လာမှုများ၊ SSE မှ ပြောင်းရွှေ့ခြင်းနှင့် သင့်ကိုယ်ပိုင် streaming MCP အက်ပလီကေးရှင်းများ တည်ဆောက်ရန် လက်တွေ့ လမ်းညွှန်ချက်များ ပါဝင်သည်။

## MCP တွင် သယ်ယူပို့ဆောင်မှုနည်းလမ်းများနှင့် စတရီမင်းလုပ်ဆောင်ခြင်း

ဤအပိုင်းတွင် MCP တွင် ရရှိနိုင်သည့် သယ်ယူပို့ဆောင်မှုနည်းလမ်းများနှင့် ၎င်းတို့၏ အခန်းကဏ္ဍကို စတရီမင်းလုပ်ဆောင်ခြင်းအတွက် ရှင်းလင်းပြသထားသည်။ ၎င်းသည် client နှင့် server များအကြား အချိန်နှင့်တပြေးညီ ဆက်သွယ်မှုအတွက် အရေးကြီးသည်။

### သယ်ယူပို့ဆောင်မှုနည်းလမ်းဆိုသည်မှာ?

သယ်ယူပို့ဆောင်မှုနည်းလမ်းသည် client နှင့် server အကြား ဒေတာကို မည်သို့ လဲလှယ်ပေးမည်ကို သတ်မှတ်သည်။ MCP သည် ပတ်ဝန်းကျင်နှင့် လိုအပ်ချက်အမျိုးမျိုးကို ဖြည့်ဆည်းနိုင်ရန် သယ်ယူပို့ဆောင်မှုအမျိုးအစားများစွာကို ထောက်ခံပေးသည်-

- **stdio**: စံသတ်မှတ် input/output ဖြစ်ပြီး ဒေသတွင်းနှင့် CLI အခြေပြု ကိရိယာများအတွက် သင့်တော်သည်။ ရိုးရှင်းသော်လည်း web သို့မဟုတ် cloud အတွက် မသင့်တော်ပါ။
- **SSE (Server-Sent Events)**: server များမှ client များသို့ HTTP ဖြင့် အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များကို ပို့ပေးနိုင်သည်။ web UI များအတွက် ကောင်းမွန်သော်လည်း တိုးချဲ့နိုင်မှုနှင့် လွတ်လပ်မှုမှာ ကန့်သတ်ချက်ရှိသည်။
- **Streamable HTTP**: ခေတ်မီ HTTP အခြေပြု စတရီမင်းသယ်ယူပို့ဆောင်မှုဖြစ်ပြီး အသိပေးချက်များနှင့် တိုးချဲ့နိုင်မှုကောင်းမွန်မှုကို ထောက်ပံ့သည်။ ထုတ်လုပ်မှုနှင့် cloud ပတ်ဝန်းကျင်များအတွက် အကြံပြုသည်။

### နှိုင်းယှဉ်ဇယား

အောက်ပါ နှိုင်းယှဉ်ဇယားကို ကြည့်၍ သယ်ယူပို့ဆောင်မှုနည်းလမ်းများ၏ ကွာခြားချက်များကို နားလည်ပါ-

| သယ်ယူပို့ဆောင်မှု | အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ | စတရီမင်းလုပ်ဆောင်မှု | တိုးချဲ့နိုင်မှု | အသုံးပြုမှုအခြေအနေ          |
|-------------------|------------------------------|-----------------|-------------|-----------------------------|
| stdio             | မဟုတ်ပါ                     | မဟုတ်ပါ        | နည်းပါးသည်  | ဒေသတွင်း CLI ကိရိယာများ     |
| SSE               | ဟုတ်သည်                     | ဟုတ်သည်        | အလယ်အလတ်    | web, အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ |
| Streamable HTTP   | ဟုတ်သည်                     | ဟုတ်သည်        | မြင့်မားသည်  | cloud, မျိုးစုံ client များ  |

> **Tip:** သင့်တော်သော သယ်ယူပို့ဆောင်မှုကို ရွေးချယ်ခြင်းသည် စွမ်းဆောင်ရည်၊ တိုးချဲ့နိုင်မှုနှင့် အသုံးပြုသူအတွေ့အကြုံကို ထိခိုက်စေသည်။ **Streamable HTTP** ကို ခေတ်မီ၊ တိုးချဲ့နိုင်ပြီး cloud အတွက် အကြံပြုသည်။

ယခင်အခန်းများတွင် ပြသခဲ့သည့် stdio နှင့် SSE သယ်ယူပို့ဆောင်မှုများနှင့် ယခုအခန်းတွင် ဖော်ပြထားသည့် streamable HTTP သယ်ယူပို့ဆောင်မှုကို သတိပြုပါ။

## စတရီမင်းလုပ်ဆောင်ခြင်း- အယူအဆနှင့် အကြောင်းရင်း

စတရီမင်းလုပ်ဆောင်ခြင်း၏ အခြေခံအယူအဆများနှင့် အကြောင်းရင်းများကို နားလည်ခြင်းသည် အကျိုးရှိသော အချိန်နှင့်တပြေးညီ ဆက်သွယ်မှုစနစ်များ တည်ဆောက်ရာတွင် အရေးကြီးသည်။

**စတရီမင်း** ဆိုသည်မှာ ကွန်ယက်ပရိုဂရမ်မင်းတွင် ဒေတာကို တစ်ပြိုင်နက်လုံး ပြီးစီးရန် မစောင့်ဘဲ၊ အနည်းငယ်ခွဲခြားထားသော အပိုင်းများ သို့မဟုတ် ဖြစ်ရပ်စဉ်များအဖြစ် ပို့ဆောင်ခြင်းနှင့် လက်ခံခြင်းနည်းလမ်းဖြစ်သည်။ ၎င်းသည် အထူးသဖြင့်-

- ဖိုင်ကြီးများ သို့မဟုတ် ဒေတာစုစည်းမှုများအတွက်
- အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ (ဥပမာ- စကားပြောခြင်း၊ တိုးတက်မှုဘားများ)
- ရေရှည်တွက်ချက်မှုများတွင် အသုံးပြုသူကို သတင်းပေးရန်

အထက်ပါအချက်များအရ စတရီမင်းလုပ်ဆောင်ခြင်းအကြောင်း အကျဉ်းချုပ်မှာ-

- ဒေတာကို တဖြည်းဖြည်း ပို့ဆောင်သည်၊ တပြိုင်နက်လုံး မဟုတ်ပါ။
- client သည် ဒေတာရောက်ရှိသည့်အခါ ချက်ချင်း လုပ်ဆောင်နိုင်သည်။
- ခံစားရသော နောက်ကျမှုကို လျော့နည်းစေပြီး အသုံးပြုသူအတွေ့အကြုံကို တိုးတက်စေသည်။

### စတရီမင်းကို မည်သို့ အသုံးပြုသနည်း?

စတရီမင်းကို အသုံးပြုရခြင်း၏ အကြောင်းရင်းများမှာ-

- အသုံးပြုသူများသည် အဆုံးမရောက်မီ တုံ့ပြန်ချက်ကို ချက်ချင်း ရရှိသည်။
- အချိန်နှင့်တပြေးညီ အက်ပလီကေးရှင်းများနှင့် တုံ့ပြန်မှုရှိသော UI များ ဖန်တီးနိုင်သည်။
- ကွန်ယက်နှင့် ကွန်ပျူတာ အရင်းအမြစ်များကို ထိရောက်စွာ အသုံးပြုနိုင်သည်။

### ရိုးရှင်းသော ဥပမာ- HTTP Streaming Server နှင့် Client

စတရီမင်းကို မည်သို့ အကောင်အထည်ဖော်နိုင်သည်ကို ရိုးရှင်းသော ဥပမာဖြင့် ဖော်ပြထားသည်-

## Python

**Server (Python, FastAPI နှင့် StreamingResponse အသုံးပြု၍):**

### Python

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```


**Client (Python, requests အသုံးပြု၍):**

### Python

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```


ဤဥပမာတွင် server သည် မက်ဆေ့ခ်ျများအားလုံး ပြီးစီးရန် မစောင့်ဘဲ မက်ဆေ့ခ်ျတစ်ခုချင်းစီ ရရှိသည့်အခါ client သို့ ပို့ပေးသည်။

**လုပ်ဆောင်ပုံ:**
- server သည် မက်ဆေ့ခ်ျတစ်ခုချင်းစီ ပြင်ဆင်ပြီးချိန်တွင် ပေးပို့သည်။
- client သည် ရောက်ရှိသည့် အပိုင်းတိုင်းကို လက်ခံပြီး ပုံနှိပ်ပြသည်။

**လိုအပ်ချက်များ:**
- server သည် streaming response (ဥပမာ- FastAPI တွင် `StreamingResponse`) ကို အသုံးပြုရမည်။
- client သည် response ကို stream အဖြစ် လက်ခံရမည် (`stream=True` in requests)။
- Content-Type သည် ပုံမှန်အားဖြင့် `text/event-stream` သို့မဟုတ် `application/octet-stream` ဖြစ်သည်။

## Java

**Server (Java, Spring Boot နှင့် Server-Sent Events အသုံးပြု၍):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Client (Java, Spring WebFlux WebClient အသုံးပြု၍):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java အကောင်အထည်ဖော်မှု မှတ်ချက်များ:**
- Spring Boot ၏ reactive stack ကို `Flux` ဖြင့် စတရီမင်းလုပ်ဆောင်သည်။
- `ServerSentEvent` သည် event အမျိုးအစားများပါဝင်သည့် ဖွဲ့စည်းထားသော event စတရီမင်းကို ပံ့ပိုးသည်။
- `WebClient` ၏ `bodyToFlux()` သည် reactive streaming ကို လက်ခံနိုင်စေသည်။
- `delayElements()` သည် event များအကြား လုပ်ဆောင်ချိန်ကို အတုယူသည်။
- event များတွင် client အတွက် ပိုမိုကောင်းမွန်စေရန် အမျိုးအစားများ (`info`, `result`) ပါရှိနိုင်သည်။

### နှိုင်းယှဉ်ခြင်း- Classic Streaming နှင့် MCP Streaming

Classic HTTP streaming နှင့် MCP streaming ၏ ကွာခြားချက်များကို အောက်ပါအတိုင်း ဖော်ပြနိုင်သည်-

| လက္ခဏာ                | Classic HTTP Streaming         | MCP Streaming (Notifications)      |
|------------------------|-------------------------------|-------------------------------------|
| အဓိက တုံ့ပြန်ချက်      | Chunked                       | တစ်ခုတည်း၊ အဆုံးတွင်ပေးသည်          |
| တိုးတက်မှု အပ်ဒိတ်များ   | ဒေတာ အပိုင်းများအဖြစ် ပေးပို့သည် | အသိပေးချက်များအဖြစ် ပေးပို့သည်         |
| client လိုအပ်ချက်များ   | stream ကို လုပ်ဆောင်ရမည်       | message handler တည်ဆောက်ရမည်          |
| အသုံးပြုမှုအခြေအနေ    | ဖိုင်ကြီးများ၊ AI token စတရီမင်း | တိုးတက်မှု၊ မှတ်တမ်းများ၊ အချိန်နှင့်တပြေးညီ တုံ့ပြန်ချက် |

### အဓိက ကွာခြားချက်များ

ထို့အပြင် အဓိက ကွာခြားချက်များမှာ-

- **ဆက်သွယ်မှု ပုံစံ:**
   - Classic HTTP streaming: ဒေတာကို chunked transfer encoding ဖြင့် ပို့သည်။
   - MCP streaming: JSON-RPC protocol ဖြင့် ဖွဲ့စည်းထားသော အသိပေးချက်စနစ်ကို အသုံးပြုသည်။

- **မက်ဆေ့ခ်ျ ပုံစံ:**
   - Classic HTTP: စာသားရိုးရှင်းသော chunk များနှင့် newlines ပါရှိသည်။
   - MCP: metadata ပါဝင်သည့် LoggingMessageNotification အရာဝတ္ထုများဖြစ်သည်။

- **client အကောင်အထည်ဖော်မှု:**
   - Classic HTTP: streaming response များကို လုပ်ဆောင်နိုင်သည့် ရိုးရှင်းသော client ဖြစ်သည်။
   - MCP: မက်ဆေ့ခ်ျအမျိုးအစားများကို ခွဲခြားစီမံနိုင်သည့် message handler ပါရှိသော client ဖြစ်သည်။

- **တိုးတက်မှု အပ်ဒိတ်များ:**
   - Classic HTTP: တိုးတက်မှုသည် အဓိက response stream ၏ အစိတ်အပိုင်းဖြစ်သည်။
   - MCP: တိုးတက်မှုကို အသိပေးချက် မက်ဆေ့ခ်ျများဖြင့် ပေးပို့ပြီး အဓိက response ကို အဆုံးတွင် ပေးသည်။

### အကြံပြုချက်များ

Classic streaming (ဥပမာ `/stream` endpoint ဖြင့် ပြသထားသည့်) နှင့် MCP streaming တို့အကြား ရွေးချယ်ရာတွင် အောက်ပါအချက်များကို အကြံပြုပါသည်-

- **ရိုးရှင်းသော စတရီမင်းလိုအပ်ချက်များအတွက်:** Classic HTTP streaming သည် ရိုးရှင်းပြီး အခြေခံ စတရီမင်းလိုအပ်ချက်များအတွက် လုံလောက်သည်။
- **ရှုပ်ထွေးပြီး အပြန်အလှန် ဆက်သွယ်မှုရှိသော အက်ပလီကေးရှင်းများအတွက်:** MCP streaming သည် ပိုမိုဖွဲ့စည်းထားသော နည်းလမ်းဖြင့် metadata ပိုမိုကြွယ်ဝပြီး အသိပေးချက်များနှင့် နောက်ဆုံးရလဒ်ကို ခွဲခြားထားသည်။
- **AI အက်ပလီကေးရှင်းများအတွက်:** MCP ၏ အသိပေးချက်စနစ်သည် ရေရှည် AI လုပ်ငန်းများတွင် အသုံးပြုသူများအား တိုးတက်မှုအခြေအနေများကို သတင်းပေးရန် အထူးအသုံးဝင်သည်။

## MCP တွင် စတရီမင်းလုပ်ဆောင်ခြင်း

ယခုအထိ classic streaming နှင့် MCP streaming ၏ ကွာခြားချက်များနှင့် အကြံပြုချက်များကို ကြည့်ရှုခဲ့ပါပြီ။ ယခု MCP တွင် စတရီမင်းကို မည်သို့ အသုံးချနိုင်သည်ကို အသေးစိတ် ရှင်းပြပါမည်။

MCP ဖရိမ်ဝတ်အတွင်း စတရီမင်းလုပ်ဆောင်ပုံကို နားလည်ခြင်းသည် ရေရှည်လုပ်ငန်းများအတွင်း အသုံးပြုသူများအား အချိန်နှင့်တပြေးညီ တုံ့ပြန်ချက်ပေးနိုင်သော အက်ပလီကေးရှင်းများ ဖန်တီးရာတွင် အရေးကြီးသည်။

MCP တွင် စတရီမင်းဆိုသည်မှာ အဓိက တုံ့ပြန်ချက်ကို chunk များအဖြစ် မပို့ပဲ၊ ကိရိယာတစ်ခုသည် တောင်းဆိုမှုကို လုပ်ဆောင်နေစဉ် client သို့ **အသိပေးချက်များ** ပို့ပေးခြင်းဖြစ်သည်။ ၎င်းအသိပေးချက်များတွင် တိုးတက်မှု အပ်ဒိတ်များ၊ မှတ်တမ်းများ သို့မဟုတ် အခြားဖြစ်ရပ်များ ပါဝင်နိုင်သည်။

### လုပ်ဆောင်ပုံ

အဓိက ရလဒ်ကို တစ်ခုတည်းသော တုံ့ပြန်ချက်အဖြစ် ပေးပို့သည်။ သို့သော် လုပ်ဆောင်နေစဉ်တွင် အသိပေးချက်များကို သီးခြား မက်ဆေ့ခ်ျများအဖြစ် ပို့ပေးနိုင်ပြီး client ကို အချိန်နှင့်တပြေးညီ အပ်ဒိတ်ပေးနိုင်သည်။ client သည် ၎င်းအသိပေးချက်များကို လက်ခံ၍ ပြသနိုင်ရမည်။

## အသိပေးချက် (Notification) ဆိုသည်မှာ?

"အသိပေးချက်" ဟု ဆိုသည်မှာ MCP အတွင်း ဘာကို ဆိုလိုသနည်း?

အသိပေးချက်သည် ရေရှည်လုပ်ငန်းတစ်ခုအတွင်း တိုးတက်မှု၊ အခြေအနေ သို့မဟုတ် အခြားဖြစ်ရပ်များအကြောင်း server မှ client သို့ ပို့သော မက်ဆေ့ခ်ျဖြစ်သည်။ အသိပေးချက်များသည် ထင်ရှားမှုနှင့် အသုံးပြုသူအတွေ့အကြုံကို တိုးတက်စေသည်။

ဥပမာအားဖြင့် client သည် server နှင့် ပထမဆုံး handshake ပြီးဆုံးသည့်အခါ အသိပေးချက်တစ်ခု ပို့ရမည်ဖြစ်သည်။

အသိပေးချက်သည် JSON မက်ဆေ့ခ်ျအဖြစ် အောက်ပါအတိုင်း ဖြစ်သည်-

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

အသိပေးချက်များသည် MCP တွင် ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) ဟု ခေါ်သော topic တစ်ခုတွင် ပါဝင်သည်။

logging ကို အလုပ်လုပ်စေရန် server သည် အောက်ပါအတိုင်း feature/capability အဖြစ် ဖွင့်ထားရမည်-

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> အသုံးပြုသော SDK အပေါ်မူတည်၍ logging ကို ပုံမှန်အားဖြင့် ဖွင့်ထားနိုင်သော်လည်း၊ server configuration တွင် ထိရောက်စွာ ဖွင့်ရနိုင်ပါသည်။

အသိပေးချက်အမျိုးအစားများမှာ-

| အဆင့်     | ဖော်ပြချက်                      | ဥပမာ အသုံးပြုမှု               |
|-----------|-------------------------------|---------------------------------|
| debug     | အသေးစိတ် debugging အချက်အလက်များ | function ဝင်/ထွက်နေရာများ       |
| info      | အထွေထွေ သတင်းအချက်အလက်များ   | လုပ်ငန်းတိုးတက်မှု အပ်ဒိတ်များ    |
| notice    | ပုံမှန် သို့သော် အရေးကြီးဖြစ်ရပ်များ | ဖွဲ့စည်းမှု ပြောင်းလဲမှုများ      |
| warning   | သတိပေးချက် အခြေအနေများ         | အသုံးမပြုသင့်သော function များ  |
| error     | အမှားအခြေအနေများ               | လုပ်ငန်း မအောင်မြင်မှုများ        |
| critical  | အရေးပေါ် အခြေအနေများ           | စနစ်အစိတ်အပိုင်း မအောင်မြင်မှု
### ဘာကြောင့် အဆင့်မြှင့်ရမလဲ?

SSE မှ Streamable HTTP သို့ အဆင့်မြှင့်ရန် အကြောင်းရင်း အဓိက နှစ်ချက်ရှိပါတယ်-

- Streamable HTTP သည် SSE ထက် ပိုမိုတိုးချဲ့နိုင်မှု၊ ကိုက်ညီမှုနှင့် အသိပေးချက်များ ပိုမိုကြွယ်ဝစွာ ထောက်ပံ့ပေးနိုင်သည်။
- MCP အသစ်များအတွက် အကြံပြုထားသော သယ်ယူပို့ဆောင်မှု ဖြစ်သည်။

### ပြောင်းရွှေ့ခြင်း အဆင့်များ

MCP အက်ပလီကေးရှင်းများတွင် SSE မှ Streamable HTTP သို့ ပြောင်းရွှေ့ရန် နည်းလမ်းများမှာ-

- `mcp.run()` တွင် `transport="streamable-http"` ကို အသုံးပြုရန် ဆာဗာကုဒ်ကို အပ်ဒိတ်လုပ်ပါ။
- SSE client အစား `streamablehttp_client` ကို အသုံးပြုရန် client ကုဒ်ကို အပ်ဒိတ်လုပ်ပါ။
- အသိပေးချက်များကို ကိုင်တွယ်ရန် client တွင် message handler တစ်ခု ထည့်သွင်းပါ။
- ရှိပြီးသား ကိရိယာများနှင့် workflow များနှင့် ကိုက်ညီမှု စစ်ဆေးပါ။

### ကိုက်ညီမှု ထိန်းသိမ်းခြင်း

ပြောင်းရွှေ့စဉ်ကာလတွင် ရှိပြီးသား SSE client များနှင့် ကိုက်ညီမှု ထိန်းသိမ်းရန် အကြံပြုသည်။ နည်းလမ်းအချို့မှာ-

- SSE နှင့် Streamable HTTP နှစ်ခုလုံးကို endpoint မတူကွဲပြားစွာ တပြိုင်နက်တွင် ထောက်ပံ့နိုင်သည်။
- client များကို တဖြည်းဖြည်း အသစ်သော သယ်ယူပို့ဆောင်မှုသို့ ပြောင်းရွှေ့ပါ။

### စိန်ခေါ်မှုများ

ပြောင်းရွှေ့စဉ်တွင် အောက်ပါ စိန်ခေါ်မှုများကို ဖြေရှင်းရန် သေချာပါစေ-

- client များအားလုံးကို အပ်ဒိတ်လုပ်ထားခြင်း
- အသိပေးချက် ပို့ဆောင်မှု ကွာခြားချက်များကို ကိုင်တွယ်ခြင်း

## လုံခြုံရေး စဉ်းစားချက်များ

မည်သည့် ဆာဗာကိုမဆို အထူးသဖြင့် MCP တွင် Streamable HTTP ကဲ့သို့ HTTP အခြေပြု သယ်ယူပို့ဆောင်မှုများ အသုံးပြုသောအခါ လုံခြုံရေးကို အလွန်အရေးကြီးစွာ ထိန်းသိမ်းရမည်ဖြစ်သည်။

MCP ဆာဗာများကို HTTP အခြေပြု သယ်ယူပို့ဆောင်မှုများဖြင့် တည်ဆောက်ရာတွင် လုံခြုံရေးသည် အရေးကြီးသော အချက်ဖြစ်ပြီး အမျိုးမျိုးသော တိုက်ခိုက်မှုနည်းလမ်းများနှင့် ကာကွယ်မှုစနစ်များကို ဂရုစိုက်စွာ စီမံရမည်ဖြစ်သည်။

### အနှစ်ချုပ်

MCP ဆာဗာများကို HTTP ဖြင့် ဖော်ပြရာတွင် လုံခြုံရေးသည် အရေးကြီးသည်။ Streamable HTTP သည် အသစ်သော တိုက်ခိုက်မှု မျက်နှာပြင်များကို ဖန်တီးပြီး သေချာစွာ ဖွဲ့စည်းရန် လိုအပ်သည်။

အောက်ပါ လုံခြုံရေး အချက်များကို သတိပြုပါ-

- **Origin Header စစ်ဆေးခြင်း**: DNS rebinding တိုက်ခိုက်မှုများကို ကာကွယ်ရန် `Origin` header ကို အမြဲစစ်ဆေးပါ။
- **Localhost Binding**: ဒေသတွင်း ဖွံ့ဖြိုးရေးအတွက် ဆာဗာများကို `localhost` တွင်သာ ချိတ်ဆက်ပါ၊ အများပြည်သူအင်တာနက်သို့ မဖော်ပြပါနှင့်။
- **Authentication**: ထုတ်လုပ်မှုတွင် API key များ၊ OAuth စသည်ဖြင့် အတည်ပြုမှု စနစ်များ ထည့်သွင်းပါ။
- **CORS**: Cross-Origin Resource Sharing (CORS) မူဝါဒများကို သတ်မှတ်၍ ဝင်ရောက်ခွင့်ကို ကန့်သတ်ပါ။
- **HTTPS**: ထုတ်လုပ်မှုတွင် HTTPS ကို အသုံးပြု၍ သတင်းအချက်အလက်များကို စာလုံးကောက်ထားပါ။

### အကောင်းဆုံး လေ့လာမှုများ

MCP streaming ဆာဗာတွင် လုံခြုံရေးကို တည်ဆောက်ရာတွင် အောက်ပါအချက်များကို လိုက်နာပါ-

- စစ်ဆေးမှုမရှိဘဲ ဝင်ရောက်လာသော တောင်းဆိုမှုများကို ယုံကြည်မထားပါနှင့်။
- ဝင်ရောက်မှုများနှင့် အမှားများအားလုံးကို မှတ်တမ်းတင်ပြီး စောင့်ကြည့်ပါ။
- လုံခြုံရေး ချို့ယွင်းချက်များကို ပြုပြင်ရန် အချိန်နှင့်တပြေးညီ အခြားပစ္စည်းများကို အပ်ဒိတ်လုပ်ပါ။

### စိန်ခေါ်မှုများ

MCP streaming ဆာဗာများတွင် လုံခြုံရေး တည်ဆောက်ရာတွင် အောက်ပါ စိန်ခေါ်မှုများ ရင်ဆိုင်ရမည်-

- ဖွံ့ဖြိုးရေး လွယ်ကူမှုနှင့် လုံခြုံရေးကို ညီမျှစွာ ထိန်းသိမ်းရခြင်း
- client ပတ်ဝန်းကျင် အမျိုးမျိုးနှင့် ကိုက်ညီမှု ရှိစေရန်

### လုပ်ငန်းတာဝန်: ကိုယ်ပိုင် Streaming MCP App တည်ဆောက်ခြင်း

**အခြေအနေ:**
ဆာဗာသည် အရာဝတ္ထုစာရင်း (ဥပမာ- ဖိုင်များ သို့မဟုတ် စာရွက်စာတမ်းများ) ကို ကိုင်တွယ်ပြီး အရာဝတ္ထုတစ်ခုချင်းစီအတွက် အသိပေးချက် ပို့ပေးသည်။ client သည် အသိပေးချက်များကို ရောက်ရှိသလို ပြသရမည်။

**အဆင့်များ:**

1. အရာဝတ္ထုစာရင်းကို ကိုင်တွယ်ပြီး အသိပေးချက်များ ပို့ပေးသော ဆာဗာကိရိယာ တစ်ခု တည်ဆောက်ပါ။
2. အသိပေးချက်များကို အချိန်နှင့်တပြေးညီ ပြသနိုင်ရန် message handler ပါရှိသော client တစ်ခု တည်ဆောက်ပါ။
3. ဆာဗာနှင့် client နှစ်ခုလုံးကို လည်ပတ်စစ်ဆေးပြီး အသိပေးချက်များကို ကြည့်ရှုပါ။

[Solution](./solution/README.md)

## နောက်ထပ် ဖတ်ရှုရန်နှင့် နောက်တစ်ဆင့်

MCP streaming နှင့် ပိုမိုကျွမ်းကျင်ရန်၊ အဆင့်မြှင့် အက်ပလီကေးရှင်းများ တည်ဆောက်ရန် အောက်ပါ အရင်းအမြစ်များနှင့် အကြံပြုချက်များကို ဖော်ပြထားသည်။

### နောက်ထပ် ဖတ်ရှုရန်

- [Microsoft: HTTP Streaming အကြောင်း မိတ်ဆက်](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core တွင် CORS](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### နောက်တစ်ဆင့်

- အချိန်နှင့်တပြေးညီ သုံးသပ်ချက်များ၊ စကားပြောခြင်း သို့မဟုတ် ပူးပေါင်းတည်းဖြတ်ခြင်းများအတွက် streaming ကို အသုံးပြုသော MCP ကိရိယာများ ပိုမိုတိုးတက်စွာ တည်ဆောက်ကြည့်ပါ။
- MCP streaming ကို frontend framework များ (React, Vue စသည်) နှင့် ပေါင်းစပ်၍ အသက်သွင်း UI အပ်ဒိတ်များ ပြုလုပ်ပါ။
- နောက်တစ်ဆင့်: [VSCode အတွက် AI Toolkit အသုံးပြုခြင်း](../07-aitk/README.md)

**အကြောင်းကြားချက်**  
ဤစာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ဖြင့် ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှန်ကန်မှုအတွက် ကြိုးစားသော်လည်း အလိုအလျောက် ဘာသာပြန်ခြင်းတွင် အမှားများ သို့မဟုတ် မှားယွင်းချက်များ ပါဝင်နိုင်ကြောင်း သတိပြုပါရန် မေတ္တာရပ်ခံအပ်ပါသည်။ မူရင်းစာတမ်းကို မိမိဘာသာစကားဖြင့်သာ တရားဝင်အချက်အလက်အဖြစ် ယူဆသင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်မှ ဘာသာပြန်ခြင်းကို အကြံပြုပါသည်။ ဤဘာသာပြန်ချက်ကို အသုံးပြုရာမှ ဖြစ်ပေါ်လာနိုင်သည့် နားလည်မှုမှားယွင်းမှုများအတွက် ကျွန်ုပ်တို့ တာဝန်မယူပါ။