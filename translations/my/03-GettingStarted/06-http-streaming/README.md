<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-10T16:29:30+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "my"
}
-->
# HTTPS Streaming with Model Context Protocol (MCP)

ဤအခန်းတွင် HTTPS ကို အသုံးပြု၍ Model Context Protocol (MCP) ဖြင့် လုံခြုံပြီး၊ တိုးချဲ့နိုင်ပြီး၊ အချိန်နှင့်တပြေးညီ စတရီမင်းလုပ်ဆောင်နိုင်ရန် လမ်းညွှန်ချက်များကို အသေးစိတ် ဖော်ပြထားသည်။ စတရီမင်း၏ အကြောင်းရင်း၊ ရရှိနိုင်သော သယ်ယူပို့ဆောင်မှုနည်းလမ်းများ၊ MCP တွင် streamable HTTP ကို မည်သို့ အကောင်အထည်ဖော်မည်၊ လုံခြုံရေးအကောင်းဆုံး လေ့လာမှုများ၊ SSE မှ ပြောင်းရွှေ့ခြင်းနှင့် သင့်ကိုယ်ပိုင် streaming MCP အက်ပလီကေးရှင်းများ တည်ဆောက်ရာတွင် လက်တွေ့ လမ်းညွှန်ချက်များ ပါဝင်သည်။

## MCP တွင် သယ်ယူပို့ဆောင်မှုနည်းလမ်းများနှင့် စတရီမင်း

ဤအပိုင်းတွင် MCP တွင် ရရှိနိုင်သည့် သယ်ယူပို့ဆောင်မှုနည်းလမ်းများနှင့် ၎င်းတို့၏ အခန်းကဏ္ဍကို ရှင်းလင်းပြသထားပြီး၊ client နှင့် server များအကြား အချိန်နှင့်တပြေးညီ ဆက်သွယ်မှုအတွက် စတရီမင်း လုပ်ဆောင်နိုင်စေရန် အရေးပါသည်။

### သယ်ယူပို့ဆောင်မှုနည်းလမ်း ဆိုသည်မှာ?

သယ်ယူပို့ဆောင်မှုနည်းလမ်းသည် client နှင့် server အကြား ဒေတာကို မည်သို့ လဲလှယ်ပေးမည်ကို သတ်မှတ်သည်။ MCP သည် ပတ်ဝန်းကျင်နှင့် လိုအပ်ချက်အမျိုးမျိုးကို ဖြည့်ဆည်းနိုင်ရန် သယ်ယူပို့ဆောင်မှုအမျိုးအစားများစွာကို ထောက်ခံပေးသည်-

- **stdio**: စံသတ်မှတ် input/output ဖြစ်ပြီး ဒေသတွင်းနှင့် CLI အခြေပြု ကိရိယာများအတွက် သင့်တော်သည်။ ရိုးရှင်းသော်လည်း web သို့မဟုတ် cloud အတွက် မသင့်တော်ပါ။
- **SSE (Server-Sent Events)**: server များမှ client များသို့ HTTP ဖြင့် အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ ပို့ပေးနိုင်သည်။ web UI များအတွက် ကောင်းမွန်သော်လည်း တိုးချဲ့နိုင်မှုနှင့် လွတ်လပ်မှုမှာ ကန့်သတ်ချက်ရှိသည်။
- **Streamable HTTP**: ခေတ်မီ HTTP အခြေပြု စတရီမင်း သယ်ယူပို့ဆောင်မှုဖြစ်ပြီး အသိပေးချက်များနှင့် တိုးချဲ့နိုင်မှုကောင်းမွန်မှုကို ထောက်ပံ့သည်။ ထုတ်လုပ်မှုနှင့် cloud ပတ်ဝန်းကျင်များအတွက် အကြံပြုသည်။

### နှိုင်းယှဉ်ဇယား

အောက်ပါ နှိုင်းယှဉ်ဇယားမှတဆင့် သယ်ယူပို့ဆောင်မှုနည်းလမ်းများ၏ ကွာခြားချက်များကို နားလည်နိုင်ပါသည်-

| သယ်ယူပို့ဆောင်မှု | အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ | စတရီမင်း | တိုးချဲ့နိုင်မှု | အသုံးပြုမှုအခြေအနေ          |
|-------------------|------------------------------|-----------|---------------|-----------------------------|
| stdio             | မဟုတ်ပါ                     | မဟုတ်ပါ  | နည်းပါးသည်  | ဒေသတွင်း CLI ကိရိယာများ     |
| SSE               | ဟုတ်သည်                      | ဟုတ်သည်   | အလယ်အလတ်    | web, အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ |
| Streamable HTTP   | ဟုတ်သည်                      | ဟုတ်သည်   | မြင့်မားသည်  | cloud, multi-client          |

> **Tip:** သင့်တော်သော သယ်ယူပို့ဆောင်မှုကို ရွေးချယ်ခြင်းသည် စွမ်းဆောင်ရည်၊ တိုးချဲ့နိုင်မှုနှင့် အသုံးပြုသူ အတွေ့အကြုံကို ထိခိုက်စေသည်။ **Streamable HTTP** ကို ခေတ်မီ၊ တိုးချဲ့နိုင်ပြီး cloud အတွက် အကြံပြုသည်။

ယခင်အခန်းများတွင် ပြသခဲ့သည့် stdio နှင့် SSE သယ်ယူပို့ဆောင်မှုများနှင့် ယခုအခန်းတွင် ဖော်ပြထားသည့် streamable HTTP သယ်ယူပို့ဆောင်မှုကို သတိပြုပါ။

## စတရီမင်း- အယူအဆများနှင့် အကြောင်းရင်း

စတရီမင်း၏ အခြေခံအယူအဆများနှင့် အကြောင်းရင်းများကို နားလည်ခြင်းသည် အချိန်နှင့်တပြေးညီ ဆက်သွယ်မှုစနစ်များကို ထိရောက်စွာ တည်ဆောက်ရာတွင် အရေးကြီးသည်။

**စတရီမင်း** ဆိုသည်မှာ ကွန်ယက်ပရိုဂရမ်မင်းတွင် ဒေတာကို တစ်ပြိုင်နက်လုံး ပြီးစီးရန် မစောင့်ဘဲ၊ အစိတ်အပိုင်းသေးသေးလေးများ သို့မဟုတ် ဖြစ်ရပ်စဉ်များ အစဉ်လိုက် ပို့ပေးခြင်းနှင့် လက်ခံခြင်းနည်းလမ်းဖြစ်သည်။ ၎င်းသည် အထူးသဖြင့်-

- ဖိုင်ကြီးများ သို့မဟုတ် ဒေတာစုစည်းမှုများအတွက်
- အချိန်နှင့်တပြေးညီ အပ်ဒိတ်များ (ဥပမာ- စကားပြောခြင်း၊ တိုးတက်မှု အတန်းများ)
- ရေရှည် ဆောင်ရွက်မှုများတွင် အသုံးပြုသူကို သတင်းပေးရန်

အထက်တန်းအဆင့်တွင် စတရီမင်းအကြောင်း သိထားသင့်သည်-

- ဒေတာကို တဖြည်းဖြည်း ပို့ပေးသည်၊ တပြိုင်နက်လုံး မဟုတ်ပါ။
- client သည် ဒေတာရောက်ရှိသည့်အခါ ချက်ချင်း လုပ်ဆောင်နိုင်သည်။
- ခံစားရသော နောက်ကျမှုကို လျော့နည်းစေပြီး အသုံးပြုသူ အတွေ့အကြုံကို တိုးတက်စေသည်။

### စတရီမင်းကို မည်သို့ အသုံးပြုသနည်း?

စတရီမင်းကို အသုံးပြုရခြင်း၏ အကြောင်းရင်းများမှာ-

- အသုံးပြုသူများသည် အဆုံးမရောက်ခင်မှ မျက်နှာပြင်တွင် တုံ့ပြန်ချက် ချက်ချင်း ရရှိသည်။
- အချိန်နှင့်တပြေးညီ အက်ပလီကေးရှင်းများနှင့် တုံ့ပြန်မှုရှိသော UI များ ဖန်တီးနိုင်သည်။
- ကွန်ယက်နှင့် ကွန်ပျူတာ အရင်းအမြစ်များကို ထိရောက်စွာ အသုံးပြုနိုင်သည်။

### ရိုးရှင်းသော ဥပမာ- HTTP Streaming Server နှင့် Client

စတရီမင်းကို မည်သို့ အကောင်အထည်ဖော်နိုင်သည်ဆိုသည်ကို ရိုးရှင်းသော ဥပမာဖြင့် ဖော်ပြထားသည်-

<details>
<summary>Python</summary>

**Server (Python, FastAPI နှင့် StreamingResponse အသုံးပြု):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**Client (Python, requests အသုံးပြု):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

ဤဥပမာတွင် server သည် မက်ဆေ့ခ်ျများအားလုံး ပြီးစီးရန် မစောင့်ဘဲ မက်ဆေ့ခ်ျတစ်ခုချင်းစီကို client သို့ ပို့ပေးသည်။

**လုပ်ဆောင်ပုံ:**
- server သည် မက်ဆေ့ခ်ျတစ်ခုချင်းစီ ပြင်ဆင်ပြီးချိန်တွင် ပေးပို့သည်။
- client သည် ရောက်ရှိသည့် အစိတ်အပိုင်းများကို လက်ခံပြီး ပုံနှိပ်ပြသည်။

**လိုအပ်ချက်များ:**
- server သည် streaming response (ဥပမာ- FastAPI တွင် `StreamingResponse`) ကို အသုံးပြုရမည်။
- client သည် stream အဖြစ် response ကို လက်ခံရမည် (`stream=True` in requests)။
- Content-Type သည် ပုံမှန်အားဖြင့် `text/event-stream` သို့မဟုတ် `application/octet-stream` ဖြစ်သည်။

</details>

<details>
<summary>Java</summary>

**Server (Java, Spring Boot နှင့် Server-Sent Events အသုံးပြု):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Client (Java, Spring WebFlux WebClient အသုံးပြု):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java အကောင်အထည်ဖော်မှု မှတ်ချက်များ:**
- Spring Boot ၏ reactive stack ကို `Flux` ဖြင့် စတရီမင်းအတွက် အသုံးပြုသည်။
- `ServerSentEvent` သည် event အမျိုးအစားများပါဝင်သည့် ဖွဲ့စည်းထားသော event စတရီမင်းကို ပံ့ပိုးသည်။
- `WebClient` ၏ `bodyToFlux()` သည် reactive streaming ကို လက်ခံနိုင်စေသည်။
- `delayElements()` သည် event များအကြား အချိန်ကြာမြင့်မှုကို အတုယူသည်။
- event များတွင် `info`, `result` ကဲ့သို့ အမျိုးအစားများ ပါဝင်နိုင်သည်။

</details>

### နှိုင်းယှဉ်ခြင်း- Classic Streaming နှင့် MCP Streaming

Classic streaming နှင့် MCP streaming ၏ ကွာခြားချက်များကို အောက်ပါဇယားဖြင့် ဖော်ပြနိုင်သည်-

| အင်္ဂါရပ်               | Classic HTTP Streaming          | MCP Streaming (Notifications)      |
|------------------------|-------------------------------|-------------------------------------|
| အဓိက တုံ့ပြန်ချက်       | အစိတ်အပိုင်းများဖြင့် ပေးပို့သည် | တစ်ခုတည်း၊ အဆုံးတွင် ပေးပို့သည်       |
| တိုးတက်မှု အပ်ဒိတ်များ    | ဒေတာအစိတ်အပိုင်းများအဖြစ် ပေးပို့သည် | အသိပေးချက်များအဖြစ် ပေးပို့သည်         |
| client လိုအပ်ချက်များ    | stream ကို လုပ်ဆောင်နိုင်ရမည်    | မက်ဆေ့ခ်ျ handler ကို အကောင်အထည်ဖော်ရမည် |
| အသုံးပြုမှုအခြေအနေ     | ဖိုင်ကြီးများ၊ AI token streams | တိုးတက်မှု၊ မှတ်တမ်းများ၊ အချိန်နှင့်တပြေးညီ တုံ့ပြန်ချက် |

### တွေ့ရှိရသော အဓိက ကွာခြားချက်များ

ထို့အပြင် အဓိက ကွာခြားချက်များမှာ-

- **ဆက်သွယ်မှု ပုံစံ:**
   - Classic HTTP streaming: ဒေတာကို အစိတ်အပိုင်းများဖြင့် ပေးပို့ရန် chunked transfer encoding ကို အသုံးပြုသည်။
   - MCP streaming: JSON-RPC protocol ဖြင့် ဖွဲ့စည်းထားသော အသိပေးချက် စနစ်ကို အသုံးပြုသည်။

- **မက်ဆေ့ခ်ျ ပုံစံ:**
   - Classic HTTP: စာသားအစိတ်အပိုင်းများ၊ newlines ပါဝင်သည်။
   - MCP: metadata ပါဝင်သည့် LoggingMessageNotification အရာဝတ္ထုများဖြစ်သည်။

- **client အကောင်အထည်ဖော်မှု:**
   - Classic HTTP: streaming response ကို လက်ခံနိုင်သည့် ရိုးရှင်းသော client ဖြစ်သည်။
   - MCP: မက်ဆေ့ခ်ျအမျိုးအစားများကို ခွဲခြားစီမံနိုင်သည့် message handler ပါဝင်သည်။

- **တိုးတက်မှု အပ်ဒိတ်များ:**
   - Classic HTTP: အဓိက response stream ၏ အစိတ်အပိုင်းတစ်ခုအဖြစ် ပါဝင်သည်။
   - MCP: အဓိက response အဆုံးတွင် ရောက်ရှိသည့်အပြင် တိုးတက်မှုများကို သီးခြား အသိပေးချက်များဖြင့် ပေးပို့သည်။

### အကြံပြုချက်များ

Classic streaming (ဥပမာ `/stream` endpoint ဖြင့် ပြသထားသည့်) နှင့် MCP streaming တို့အကြား ရွေးချယ်ရာတွင် အောက်ပါအချက်များကို အကြံပြုသည်-

- **ရိုးရှင်းသော စတရီမင်း လိုအပ်ချက်များအတွက်:** Classic HTTP streaming သည် ရိုးရှင်းပြီး အခြေခံ စတရီမင်း လိုအပ်ချက်များအတွက် လုံလောက်သည်။

- **ရှုပ်ထွေးပြီး အပြန်အလှန် ဆက်သွယ်မှုများလိုအပ်သော အက်ပလီကေးရှင်းများအတွက်:** MCP streaming သည် ပိုမိုဖွဲ့စည်းထားသော နည်းလမ်းဖြင့် metadata ပိုများပြီး အသိပေးချက်များနှင့် နောက်ဆုံးရလဒ်ကို ခွဲခြားထားသည်။

- **AI အက်ပလီကေးရှင်းများအတွက်:** MCP ၏ အသိပေးချက် စနစ်သည် ရေရှည် ဆောင်ရွက်မှုရှိသော AI လုပ်ငန်းများတွင် အသုံးပြုသူများအား တိုးတက်မှုအခြေအနေများကို သတင်းပေးရန် အထူးအသုံးဝင်သည်။

## MCP တွင် စတရီမင်း

ယခုအထိ Classic streaming နှင့် MCP streaming ၏ ကွာခြားချက်များနှင့် အကြံပြုချက်များကို ကြည့်ရှုခဲ့ပါပြီ။ ယခု MCP တွင် စတရီမင်းကို မည်သို့ အသုံးချနိုင်သည်ကို အသေးစိတ် ရှင်းပြပါမည်။

MCP ဖရိမ်ဝတ်အတွင်း စတရီမင်းသည် ရေရှည် ဆောင်ရွက်မှုများအတွင်း အသုံးပြုသူများအား အချိန်နှင့်တပြေးညီ တုံ့ပြန်ချက်ပေးနိုင်သော အက်ပလီကေးရှင်းများ ဖန်တီးရာတွင် အရေးကြီးသည်။

MCP တွင် စတရီမင်းဆိုသည်မှာ အဓိက တုံ့ပြန်ချက်ကို အစိတ်အပိုင်းများဖြင့် မပို့ပဲ၊ ကိရိယာတစ်ခုက တောင်းဆိုမှုကို ဆောင်ရွက်နေစဉ် အသိပေးချက်များ (notifications) ကို client သို့ ပို့ပေးခြင်းဖြစ်သည်။ ၎င်းအသိပေးချက်များတွင် တိုးတက်မှု အပ်ဒိတ်များ၊ မှတ်တမ်းများ သို့မဟုတ် အခြား ဖြစ်ရပ်များ ပါဝင်နိုင်သည်။

### လုပ်ဆောင်ပုံ

အဓိက ရလဒ်ကို တစ်ခုတည်းသော တုံ့ပြန်ချက်အဖြစ် ပေးပို့သည်။ သို့သော် ဆောင်ရွက်နေစဉ် အသိပေးချက်များကို သီးခြား မက်ဆေ့ခ်ျများအဖြစ် ပို့ပေးနိုင်ပြီး client ကို အချိန်နှင့်တပြေးညီ အပ်ဒိတ်ပေးနိုင်သည်။ client သည် ၎င်းအသိပေးချက်များကို လက်ခံ၍ ပြသနိုင်ရမည်။

## အသိပေးချက် (Notification) ဆိုသည်မှာ?

"အသိပေးချက်" ဟု ဆိုသည်မှာ MCP အတွင်း ဘာကို ဆိုလိုသနည်း?

အသိပေးချက်သည် ရေရှည် ဆောင်ရွက်မှုများအတွင်း တိုးတက်မှု၊ အခြေအနေ သို့မဟုတ် အခြား ဖြစ်ရပ်များအကြောင်း server မှ client သို့ ပို့သော မက်ဆေ့ခ်ျဖြစ်သည်။ အသိပေးချက်များသည် ထင်ရှားမှုနှင့် အသုံးပြုသူ အတွေ့အကြုံကို တိုးတက်စေသည်။

ဥပမာအားဖြင့် client သည် server နှင့် ပထမဆုံး handshake ပြီးဆုံးသည့်အခါ အသိပေးချက် တစ်ခု ပို့ရမည်ဖြစ်သည်။

အသိပေးချက်သည် JSON မက်ဆေ့ခ်ျအဖြစ် အောက်ပါပုံစံဖြစ်သည်-

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

အသိပေးချက်များသည် MCP တွင် ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) ဟု ခေါ်သော topic တစ်ခုတွင် ပါဝင်သည်။

logging ကို အလုပ်လုပ်စေရန် server သည် အောက်ပါအတိုင်း feature/capability အဖြစ် ဖွင့်ထားရမည်-

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> အသုံးပြုသော SDK အပေါ်မူတည်၍ logging ကို ပုံမှန်အားဖြင့် ဖွင့်ထားနိုင်သော်လည်း၊ သင့် server configuration တွင် ထိရောက်စွာ ဖွင့်ရန် လိုအပ်နိုင်သည်။

အသိပေးချက်အမျိုးအစားများမှာ-

| အဆင့်     | ဖော်ပြချက်                      | အသုံးပြုမှု ဥပမာ               |
|-----------|-------------------------------|---------------------------------|
| debug     | အသေးစိတ် debugging အချက်အလက်များ | function ဝင်/ထွက် အချက်များ    |
| info      | အထွေထွေ သတင်းအချက်အလက်များ   | လုပ်ငန်းတိုးတက်မှု အပ်ဒိတ်များ   |
| notice    | ပုံမှန် သို့သော် အရေးကြီးသော ဖြစ်ရပ်များ | configuration ပြောင်းလဲမှုများ  |
| warning   | သတိပေးချက် အခြေအနေများ         | အသုံးမပြုသင့်သော feature အသုံးပြုမှု |
| error     | အမှားအခြေအနေများ               |

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**Client Example:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## လုံခြုံရေးဆိုင်ရာစဉ်းစားချက်များ

HTTP အခြေပြု ပို့ဆောင်မှုများဖြင့် MCP ဆာဗာများကို တည်ဆောက်ရာတွင် လုံခြုံရေးသည် အလွန်အရေးကြီးပြီး၊ အမျိုးမျိုးသောတိုက်ခိုက်မှုနည်းလမ်းများနှင့် ကာကွယ်မှုစနစ်များကို ဂရုစိုက်စွာ စီမံရန် လိုအပ်ပါသည်။

### အနှစ်ချုပ်

MCP ဆာဗာများကို HTTP မှတဆင့် ဖော်ပြရာတွင် လုံခြုံရေးသည် အရေးကြီးပါသည်။ Streamable HTTP သည် တိုက်ခိုက်မှုအလားအလာအသစ်များကို ဖန်တီးပြီး၊ သေချာစွာ ပြင်ဆင်ရန် လိုအပ်ပါသည်။

### အဓိကအချက်များ
- **Origin Header စစ်ဆေးခြင်း**: DNS rebinding တိုက်ခိုက်မှုများကို ကာကွယ်ရန် `Origin` header ကို အမြဲစစ်ဆေးပါ။
- **Localhost Binding**: ဒေသတွင်း ဖွံ့ဖြိုးရေးအတွက် ဆာဗာများကို `localhost` တွင်သာ ချိတ်ဆက်ပါ၊ အများပြည်သူအင်တာနက်တွင် ဖော်ပြခြင်းမှ ရှောင်ကြဉ်ရန်။
- **Authentication**: ထုတ်လုပ်မှုတွင် API key များ၊ OAuth စသည့် အတည်ပြုမှုစနစ်များကို ထည့်သွင်းပါ။
- **CORS**: Cross-Origin Resource Sharing (CORS) မူဝါဒများကို သတ်မှတ်၍ ဝင်ရောက်ခွင့်ကို ကန့်သတ်ပါ။
- **HTTPS**: ထုတ်လုပ်မှုတွင် HTTPS ကို အသုံးပြု၍ သတင်းအချက်အလက်များကို စာလုံးကောက်ထားပါ။

### အကောင်းဆုံး လုပ်ထုံးလုပ်နည်းများ
- စစ်ဆေးမှုမရှိဘဲ ဝင်ရောက်လာသော တောင်းဆိုမှုများကို ယုံကြည်မထားပါနှင့်။
- ဝင်ရောက်မှုများနှင့် အမှားများအားလုံးကို မှတ်တမ်းတင်ပြီး စောင့်ကြည့်ပါ။
- လုံခြုံရေး ချို့ယွင်းချက်များကို ပြုပြင်ရန် အချိန်နှင့်တပြေးညီ အခြားပစ္စည်းများကို အဆက်မပြတ် update လုပ်ပါ။

### စိန်ခေါ်မှုများ
- ဖွံ့ဖြိုးရေး လွယ်ကူမှုနှင့် လုံခြုံရေးကို ညီမျှစွာ ထိန်းသိမ်းရခြင်း
- မတူညီသော client ပတ်ဝန်းကျင်များနှင့် ကိုက်ညီမှုရှိစေရန်

## SSE မှ Streamable HTTP သို့ အဆင့်မြှင့်ခြင်း

Server-Sent Events (SSE) ကို အသုံးပြုနေသော အပလီကေးရှင်းများအတွက် Streamable HTTP သို့ ပြောင်းရွှေ့ခြင်းသည် MCP အကောင်အထည်ဖော်မှုများအတွက် ပိုမိုကောင်းမွန်သော စွမ်းဆောင်ရည်နှင့် ရေရှည်တည်တံ့မှုကို ပေးစွမ်းပါသည်။

### အဆင့်မြှင့်ရသည့် အကြောင်းရင်း

SSE မှ Streamable HTTP သို့ အဆင့်မြှင့်ရန် အကြောင်းရင်း ၂ ချက်ရှိပါသည်-

- Streamable HTTP သည် SSE ထက် ပိုမိုတိုးတက်သော စွမ်းဆောင်ရည်၊ ကိုက်ညီမှုနှင့် အသိပေးမှုများ ပိုမိုကြွယ်ဝစေပါသည်။
- MCP အသစ်များအတွက် အကြံပြုထားသော ပို့ဆောင်မှုနည်းလမ်းဖြစ်ပါသည်။

### ပြောင်းရွှေ့ခြင်း အဆင့်များ

MCP အပလီကေးရှင်းများတွင် SSE မှ Streamable HTTP သို့ ပြောင်းရွှေ့ရန် အောက်ပါအတိုင်း လုပ်ဆောင်နိုင်ပါသည်-

- `mcp.run()` တွင် `transport="streamable-http"` ကို အသုံးပြုရန် ဆာဗာကုဒ်ကို update လုပ်ပါ။
- SSE client အစား `streamablehttp_client` ကို အသုံးပြုရန် client ကုဒ်ကို update လုပ်ပါ။
- အသိပေးချက်များကို ကိုင်တွယ်ရန် client တွင် message handler တစ်ခု ထည့်သွင်းပါ။
- ရှိပြီးသား ကိရိယာများနှင့် workflow များနှင့် ကိုက်ညီမှုရှိမရှိ စမ်းသပ်ပါ။

### ကိုက်ညီမှု ထိန်းသိမ်းခြင်း

ပြောင်းရွှေ့မှုကာလအတွင်း ရှိပြီးသား SSE client များနှင့် ကိုက်ညီမှုရှိစေရန် အောက်ပါနည်းလမ်းများကို အသုံးပြုနိုင်ပါသည်-

- SSE နှင့် Streamable HTTP နှစ်မျိုးလုံးကို endpoint မတူကွဲပြားစွာ တပြိုင်နက်တွင် ထောက်ပံ့နိုင်ပါသည်။
- Client များကို တဖြည်းဖြည်း အသစ်သော ပို့ဆောင်မှုသို့ ပြောင်းရွှေ့ပါ။

### စိန်ခေါ်မှုများ

ပြောင်းရွှေ့မှုအတွင်း အောက်ပါ စိန်ခေါ်မှုများကို ဖြေရှင်းရန် လိုအပ်ပါသည်-

- Client များအားလုံးကို update လုပ်ထားခြင်း
- အသိပေးချက် ပေးပို့မှုကွာခြားချက်များကို ကိုင်တွယ်ခြင်း

## လုံခြုံရေးဆိုင်ရာစဉ်းစားချက်များ

HTTP အခြေပြု ပို့ဆောင်မှုများဖြင့် MCP ဆာဗာများ တည်ဆောက်ရာတွင် လုံခြုံရေးသည် အလွန်အရေးကြီးပြီး၊ အမျိုးမျိုးသောတိုက်ခိုက်မှုနည်းလမ်းများနှင့် ကာကွယ်မှုစနစ်များကို ဂရုစိုက်စွာ စီမံရန် လိုအပ်ပါသည်။

### အနှစ်ချုပ်

MCP ဆာဗာများကို HTTP မှတဆင့် ဖော်ပြရာတွင် လုံခြုံရေးသည် အရေးကြီးပါသည်။ Streamable HTTP သည် တိုက်ခိုက်မှုအလားအလာအသစ်များကို ဖန်တီးပြီး၊ သေချာစွာ ပြင်ဆင်ရန် လိုအပ်ပါသည်။

အောက်ပါ လုံခြုံရေးအချက်များကို သတိပြုပါ-

- **Origin Header စစ်ဆေးခြင်း**: DNS rebinding တိုက်ခိုက်မှုများကို ကာကွယ်ရန် `Origin` header ကို အမြဲစစ်ဆေးပါ။
- **Localhost Binding**: ဒေသတွင်း ဖွံ့ဖြိုးရေးအတွက် ဆာဗာများကို `localhost` တွင်သာ ချိတ်ဆက်ပါ၊ အများပြည်သူအင်တာနက်တွင် ဖော်ပြခြင်းမှ ရှောင်ကြဉ်ရန်။
- **Authentication**: ထုတ်လုပ်မှုတွင် API key များ၊ OAuth စသည့် အတည်ပြုမှုစနစ်များကို ထည့်သွင်းပါ။
- **CORS**: Cross-Origin Resource Sharing (CORS) မူဝါဒများကို သတ်မှတ်၍ ဝင်ရောက်ခွင့်ကို ကန့်သတ်ပါ။
- **HTTPS**: ထုတ်လုပ်မှုတွင် HTTPS ကို အသုံးပြု၍ သတင်းအချက်အလက်များကို စာလုံးကောက်ထားပါ။

### အကောင်းဆုံး လုပ်ထုံးလုပ်နည်းများ

MCP streaming ဆာဗာတွင် လုံခြုံရေးကို ထည့်သွင်းရာတွင် အောက်ပါ အကောင်းဆုံး လုပ်ထုံးလုပ်နည်းများကို လိုက်နာပါ-

- စစ်ဆေးမှုမရှိဘဲ ဝင်ရောက်လာသော တောင်းဆိုမှုများကို ယုံကြည်မထားပါနှင့်။
- ဝင်ရောက်မှုများနှင့် အမှားများအားလုံးကို မှတ်တမ်းတင်ပြီး စောင့်ကြည့်ပါ။
- လုံခြုံရေး ချို့ယွင်းချက်များကို ပြုပြင်ရန် အချိန်နှင့်တပြေးညီ အခြားပစ္စည်းများကို အဆက်မပြတ် update လုပ်ပါ။

### စိန်ခေါ်မှုများ

MCP streaming ဆာဗာများတွင် လုံခြုံရေး ထည့်သွင်းရာတွင် အောက်ပါ စိန်ခေါ်မှုများကို ကြုံတွေ့ရပါမည်-

- ဖွံ့ဖြိုးရေး လွယ်ကူမှုနှင့် လုံခြုံရေးကို ညီမျှစွာ ထိန်းသိမ်းရခြင်း
- မတူညီသော client ပတ်ဝန်းကျင်များနှင့် ကိုက်ညီမှုရှိစေရန်

### လုပ်ငန်းတာဝန်: ကိုယ်ပိုင် Streaming MCP အက်ပ် တည်ဆောက်ခြင်း

**အခြေအနေ:**
MCP ဆာဗာနှင့် client တစ်ခုကို တည်ဆောက်ပါ၊ ဆာဗာသည် အချက်အလက်စာရင်း (ဥပမာ ဖိုင်များ သို့မဟုတ် စာရွက်စာတမ်းများ) ကို လုပ်ဆောင်ပြီး၊ အချက်တစ်ခုစီအတွက် အသိပေးချက် ပို့ပေးပါမည်။ Client သည် အသိပေးချက်များကို ရောက်ရှိသလို ပြသပေးရမည်။

**အဆင့်များ:**

1. အချက်အလက်စာရင်းကို လုပ်ဆောင်ပြီး အသိပေးချက်များ ပို့ပေးသော ဆာဗာကိရိယာ တစ်ခုကို တည်ဆောက်ပါ။
2. အသိပေးချက်များကို အချိန်နှင့်တပြေးညီ ပြသနိုင်ရန် message handler ပါရှိသော client ကို တည်ဆောက်ပါ။
3. ဆာဗာနှင့် client နှစ်ခုလုံးကို လည်ပတ်စစ်ဆေးပြီး အသိပေးချက်များကို ကြည့်ရှုပါ။

[Solution](./solution/README.md)

## နောက်ထပ်ဖတ်ရှုရန်နှင့် နောက်တစ်ဆင့်

MCP streaming နှင့် ပိုမိုကျွမ်းကျင်ရန်၊ ဒီအပိုင်းတွင် နောက်ထပ် အရင်းအမြစ်များနှင့် ပိုမိုတိုးတက်သော အက်ပ်များ တည်ဆောက်ရန် အကြံပြုချက်များ ပါဝင်သည်။

### နောက်ထပ်ဖတ်ရှုရန်

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### နောက်တစ်ဆင့်

- အချိန်နှင့်တပြေးညီ သုံးစွဲသူများအတွက် အချက်အလက်များကို တိုက်ရိုက်သုံးသပ်ခြင်း၊ စကားပြောခြင်း သို့မဟုတ် ပူးပေါင်းတည်းဖြတ်ခြင်းများအတွက် streaming ကို အသုံးပြုသော MCP ကိရိယာများ ပိုမိုတိုးတက်စွာ တည်ဆောက်ကြည့်ပါ။
- MCP streaming ကို frontend framework များ (React, Vue စသည်) နှင့် ပေါင်းစပ်၍ အသက်ဝင်သော UI အပ်ဒိတ်များ ပြုလုပ်ပါ။
- နောက်တစ်ဆင့်: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**အကြောင်းကြားချက်**  
ဤစာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ဖြင့် ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှန်ကန်မှုအတွက် ကြိုးစားသော်လည်း၊ အလိုအလျောက် ဘာသာပြန်ခြင်းတွင် အမှားများ သို့မဟုတ် မှားယွင်းချက်များ ပါဝင်နိုင်ကြောင်း သတိပြုပါရန် မေတ္တာရပ်ခံအပ်ပါသည်။ မူရင်းစာတမ်းကို မူလဘာသာဖြင့်သာ တရားဝင်အချက်အလက်အဖြစ် ယူဆသင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်မှ ဘာသာပြန်ခြင်းကို အကြံပြုပါသည်။ ဤဘာသာပြန်ချက်ကို အသုံးပြုရာမှ ဖြစ်ပေါ်လာနိုင်သည့် နားလည်မှုမှားယွင်းမှုများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။