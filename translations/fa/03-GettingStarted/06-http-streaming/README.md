<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-10T15:55:36+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "fa"
}
-->
# پخش HTTPS با پروتکل مدل کانتکست (MCP)

این فصل راهنمای جامعی برای پیاده‌سازی پخش امن، مقیاس‌پذیر و بلادرنگ با استفاده از پروتکل مدل کانتکست (MCP) از طریق HTTPS ارائه می‌دهد. در این فصل به انگیزه پخش، مکانیزم‌های انتقال موجود، نحوه پیاده‌سازی HTTP قابل پخش در MCP، بهترین شیوه‌های امنیتی، مهاجرت از SSE و راهنمایی‌های عملی برای ساخت برنامه‌های پخش MCP پرداخته شده است.

## مکانیزم‌های انتقال و پخش در MCP

در این بخش، مکانیزم‌های انتقال مختلف موجود در MCP و نقش آن‌ها در فعال‌سازی قابلیت‌های پخش برای ارتباط بلادرنگ بین کلاینت‌ها و سرورها بررسی می‌شود.

### مکانیزم انتقال چیست؟

مکانیزم انتقال نحوه تبادل داده بین کلاینت و سرور را تعریف می‌کند. MCP از چندین نوع انتقال پشتیبانی می‌کند تا با محیط‌ها و نیازهای مختلف سازگار باشد:

- **stdio**: ورودی/خروجی استاندارد، مناسب برای ابزارهای محلی و خط فرمان. ساده اما برای وب یا فضای ابری مناسب نیست.
- **SSE (Server-Sent Events)**: به سرورها اجازه می‌دهد به‌روزرسانی‌های بلادرنگ را از طریق HTTP به کلاینت‌ها ارسال کنند. برای رابط‌های وب مناسب است اما در مقیاس‌پذیری و انعطاف‌پذیری محدودیت دارد.
- **Streamable HTTP**: انتقال پخش مبتنی بر HTTP مدرن، با پشتیبانی از اعلان‌ها و مقیاس‌پذیری بهتر. برای اکثر سناریوهای تولید و ابری توصیه می‌شود.

### جدول مقایسه

برای درک تفاوت‌های این مکانیزم‌های انتقال، جدول زیر را ببینید:

| مکانیزم انتقال    | به‌روزرسانی بلادرنگ | پخش       | مقیاس‌پذیری | مورد استفاده               |
|-------------------|----------------------|-----------|-------------|----------------------------|
| stdio             | خیر                  | خیر       | کم          | ابزارهای محلی خط فرمان     |
| SSE               | بله                  | بله       | متوسط       | وب، به‌روزرسانی‌های بلادرنگ |
| Streamable HTTP   | بله                  | بله       | بالا        | فضای ابری، چند کلاینت     |

> **نکته:** انتخاب مکانیزم انتقال مناسب بر عملکرد، مقیاس‌پذیری و تجربه کاربری تأثیر می‌گذارد. **Streamable HTTP** برای برنامه‌های مدرن، مقیاس‌پذیر و آماده فضای ابری توصیه می‌شود.

به مکانیزم‌های stdio و SSE که در فصل‌های قبلی معرفی شدند توجه کنید و ببینید که در این فصل تمرکز بر روی Streamable HTTP است.

## پخش: مفاهیم و انگیزه

درک مفاهیم پایه و انگیزه‌های پشت پخش برای پیاده‌سازی سیستم‌های ارتباط بلادرنگ مؤثر ضروری است.

**پخش** تکنیکی در برنامه‌نویسی شبکه است که اجازه می‌دهد داده‌ها به صورت بخش‌های کوچک و قابل مدیریت یا به شکل دنباله‌ای از رویدادها ارسال و دریافت شوند، به جای اینکه منتظر آماده شدن کل پاسخ بمانیم. این روش به ویژه برای موارد زیر مفید است:

- فایل‌ها یا داده‌های بزرگ
- به‌روزرسانی‌های بلادرنگ (مثلاً چت، نوارهای پیشرفت)
- محاسبات طولانی که می‌خواهید کاربر را در جریان نگه دارید

در سطح کلی، نکات زیر را باید درباره پخش بدانید:

- داده به صورت تدریجی ارسال می‌شود، نه همه یکجا
- کلاینت می‌تواند داده‌ها را به محض رسیدن پردازش کند
- تأخیر درک شده را کاهش داده و تجربه کاربری را بهبود می‌بخشد

### چرا از پخش استفاده کنیم؟

دلایل استفاده از پخش عبارتند از:

- کاربران بلافاصله بازخورد می‌گیرند، نه فقط در پایان
- امکان ساخت برنامه‌های بلادرنگ و رابط‌های پاسخگو را فراهم می‌کند
- استفاده بهینه‌تر از منابع شبکه و محاسباتی

### مثال ساده: سرور و کلاینت پخش HTTP

در اینجا یک مثال ساده از نحوه پیاده‌سازی پخش آورده شده است:

<details>
<summary>Python</summary>

**سرور (Python، با استفاده از FastAPI و StreamingResponse):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**کلاینت (Python، با استفاده از requests):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

این مثال نشان می‌دهد که سرور پیام‌ها را به محض آماده شدن به کلاینت ارسال می‌کند، به جای اینکه منتظر آماده شدن همه پیام‌ها باشد.

**نحوه کار:**
- سرور هر پیام را به محض آماده شدن ارسال می‌کند.
- کلاینت هر بخش را به محض دریافت پردازش و چاپ می‌کند.

**نیازمندی‌ها:**
- سرور باید از پاسخ پخش استفاده کند (مثلاً `StreamingResponse` در FastAPI).
- کلاینت باید پاسخ را به صورت جریان پردازش کند (`stream=True` در requests).
- نوع محتوا معمولاً `text/event-stream` یا `application/octet-stream` است.

</details>

<details>
<summary>Java</summary>

**سرور (Java، با استفاده از Spring Boot و Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**کلاینت (Java، با استفاده از Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**نکات پیاده‌سازی Java:**
- استفاده از استک واکنشی Spring Boot با `Flux` برای پخش
- `ServerSentEvent` امکان پخش رویدادهای ساختاریافته با انواع رویداد را فراهم می‌کند
- `WebClient` با `bodyToFlux()` مصرف پخش واکنشی را ممکن می‌سازد
- `delayElements()` زمان پردازش بین رویدادها را شبیه‌سازی می‌کند
- رویدادها می‌توانند انواعی مانند (`info`, `result`) داشته باشند تا کلاینت بهتر آن‌ها را مدیریت کند

</details>

### مقایسه: پخش کلاسیک در مقابل پخش MCP

تفاوت‌های نحوه کار پخش به صورت «کلاسیک» و نحوه کار آن در MCP به شکل زیر است:

| ویژگی                 | پخش کلاسیک HTTP             | پخش MCP (اعلان‌ها)              |
|-----------------------|-----------------------------|---------------------------------|
| پاسخ اصلی             | بخش‌بندی شده (Chunked)      | یک پاسخ واحد در پایان           |
| به‌روزرسانی پیشرفت    | به صورت بخش‌های داده ارسال می‌شود | به صورت اعلان‌ها ارسال می‌شود    |
| نیازمندی‌های کلاینت   | باید جریان را پردازش کند    | باید هندلر پیام پیاده‌سازی کند  |
| مورد استفاده          | فایل‌های بزرگ، جریان توکن‌های AI | پیشرفت، لاگ‌ها، بازخورد بلادرنگ |

### تفاوت‌های کلیدی مشاهده شده

همچنین، تفاوت‌های کلیدی زیر وجود دارد:

- **الگوی ارتباط:**
   - پخش کلاسیک HTTP: از رمزگذاری انتقال بخش‌بندی شده ساده برای ارسال داده‌ها استفاده می‌کند
   - پخش MCP: از سیستم اعلان ساختاریافته با پروتکل JSON-RPC بهره می‌برد

- **فرمت پیام:**
   - پخش کلاسیک HTTP: بخش‌های متن ساده با خطوط جدید
   - MCP: اشیاء ساختاریافته LoggingMessageNotification با متادیتا

- **پیاده‌سازی کلاینت:**
   - پخش کلاسیک HTTP: کلاینت ساده که پاسخ‌های پخش را پردازش می‌کند
   - MCP: کلاینت پیشرفته‌تر با هندلر پیام برای پردازش انواع مختلف پیام‌ها

- **به‌روزرسانی پیشرفت:**
   - پخش کلاسیک HTTP: پیشرفت بخشی از جریان پاسخ اصلی است
   - MCP: پیشرفت از طریق پیام‌های اعلان جداگانه ارسال می‌شود در حالی که پاسخ اصلی در پایان می‌آید

### توصیه‌ها

چند نکته در انتخاب بین پیاده‌سازی پخش کلاسیک (مثلاً نقطه انتهایی `/stream` که در بالا نشان داده شد) و پخش از طریق MCP وجود دارد:

- **برای نیازهای ساده پخش:** پخش کلاسیک HTTP ساده‌تر است و برای نیازهای پایه کافی است.

- **برای برنامه‌های پیچیده و تعاملی:** پخش MCP رویکرد ساختاریافته‌تری با متادیتای غنی‌تر و جداسازی بین اعلان‌ها و نتایج نهایی ارائه می‌دهد.

- **برای برنامه‌های AI:** سیستم اعلان MCP به ویژه برای وظایف طولانی AI که می‌خواهید کاربران را از پیشرفت مطلع کنید، مفید است.

## پخش در MCP

خب، تا اینجا توصیه‌ها و مقایسه‌هایی درباره تفاوت پخش کلاسیک و پخش در MCP دیدید. حالا بیایید دقیق‌تر بررسی کنیم که چگونه می‌توانید از پخش در MCP بهره ببرید.

درک نحوه کار پخش در چارچوب MCP برای ساخت برنامه‌های پاسخگو که بازخورد بلادرنگ به کاربران در طول عملیات طولانی ارائه می‌دهند، ضروری است.

در MCP، پخش به معنای ارسال پاسخ اصلی به صورت بخش‌بندی شده نیست، بلکه ارسال **اعلان‌ها** به کلاینت در حین پردازش درخواست توسط ابزار است. این اعلان‌ها می‌توانند شامل به‌روزرسانی پیشرفت، لاگ‌ها یا رویدادهای دیگر باشند.

### نحوه کار

نتیجه اصلی همچنان به صورت یک پاسخ واحد ارسال می‌شود. با این حال، اعلان‌ها می‌توانند به صورت پیام‌های جداگانه در طول پردازش ارسال شوند و بدین ترتیب کلاینت را به صورت بلادرنگ به‌روزرسانی کنند. کلاینت باید قادر به دریافت و نمایش این اعلان‌ها باشد.

## اعلان چیست؟

گفتیم «اعلان»، این در زمینه MCP به چه معناست؟

اعلان پیامی است که از سرور به کلاینت ارسال می‌شود تا درباره پیشرفت، وضعیت یا رویدادهای دیگر در طول یک عملیات طولانی اطلاع‌رسانی کند. اعلان‌ها شفافیت و تجربه کاربری را بهبود می‌بخشند.

برای مثال، کلاینت باید پس از انجام handshake اولیه با سرور یک اعلان ارسال کند.

یک اعلان به صورت پیام JSON به شکل زیر است:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

اعلان‌ها به موضوعی در MCP تعلق دارند که به آن ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) گفته می‌شود.

برای فعال کردن لاگینگ، سرور باید آن را به عنوان یک ویژگی/قابلیت فعال کند، به این صورت:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> بسته به SDK استفاده شده، ممکن است لاگینگ به طور پیش‌فرض فعال باشد یا لازم باشد به صورت صریح در پیکربندی سرور فعال شود.

انواع مختلفی از اعلان‌ها وجود دارد:

| سطح       | توضیح                         | مثال مورد استفاده              |
|-----------|-------------------------------|-------------------------------|
| debug     | اطلاعات دقیق اشکال‌زدایی       | نقاط ورود/خروج تابع           |
| info      | پیام‌های اطلاعاتی عمومی        | به‌روزرسانی پیشرفت عملیات     |
| notice    | رویدادهای عادی اما مهم         | تغییرات پیکربندی              |
| warning   | شرایط هشدار                   | استفاده از ویژگی منسوخ شده    |
| error     | شرایط خطا                    | شکست عملیات                   |
| critical  | شرایط بحرانی                 | خرابی اجزای سیستم            |
| alert     | نیاز به اقدام فوری            | شناسایی فساد داده             |
| emergency | سیستم غیرقابل استفاده است     | خرابی کامل سیستم              |

## پیاده‌سازی اعلان‌ها در MCP

برای پیاده‌سازی اعلان‌ها در MCP، باید هر دو سمت سرور و کلاینت را برای دریافت به‌روزرسانی‌های بلادرنگ آماده کنید. این امکان را به برنامه شما می‌دهد که در طول عملیات طولانی بازخورد فوری به کاربران ارائه دهد.

### سمت سرور: ارسال اعلان‌ها

بیایید با سمت سرور شروع کنیم. در MCP، ابزارهایی تعریف می‌کنید که می‌توانند در حین پردازش درخواست‌ها اعلان ارسال کنند. سرور از شیء context (معمولاً `ctx`) برای ارسال پیام به کلاینت استفاده می‌کند.

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

در مثال بالا، ابزار `process_files` در حین پردازش هر فایل سه اعلان به کلاینت ارسال می‌کند. متد `ctx.info()` برای ارسال پیام‌های اطلاعاتی استفاده شده است.

</details>

علاوه بر این، برای فعال کردن اعلان‌ها، مطمئن شوید سرور شما از انتقال پخش (مانند `streamable-http`) استفاده می‌کند و کلاینت شما هندلر پیام برای پردازش اعلان‌ها را پیاده‌سازی کرده است. در اینجا نحوه تنظیم سرور برای استفاده از انتقال `streamable-http` آمده است:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

در این مثال .NET، ابزار `ProcessFiles` با ویژگی `Tool` تزئین شده و در حین پردازش هر فایل سه اعلان به کلاینت ارسال می‌کند. متد `ctx.Info()` برای ارسال پیام‌های اطلاعاتی استفاده شده است.

برای فعال کردن اعلان‌ها در سرور MCP خود در .NET، مطمئن شوید از انتقال پخش استفاده می‌کنید:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### سمت کلاینت: دریافت اعلان‌ها

کلاینت باید هندلر پیام را پیاده‌سازی کند تا اعلان‌ها را هنگام رسیدن پردازش و نمایش دهد.

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

در کد بالا، تابع `message_handler` بررسی می‌کند که آیا پیام ورودی یک اعلان است یا خیر. اگر باشد، اعلان را چاپ می‌کند؛ در غیر این صورت، آن را به عنوان پیام عادی سرور پردازش می‌کند. همچنین توجه کنید که `ClientSession` با `message_handler` برای مدیریت اعلان‌های ورودی مقداردهی اولیه شده است.

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

در این مثال .NET، تابع `MessageHandler` بررسی می‌کند که آیا پیام ورودی یک اعلان است یا خیر. اگر باشد، اعلان را چاپ می‌کند؛ در غیر این صورت، آن را به عنوان پیام عادی سرور پردازش می‌کند. `ClientSession` با هندلر پیام از طریق `ClientSessionOptions` مقداردهی اولیه شده است.

</details>

برای فعال کردن اعلان‌ها، مطمئن شوید سرور شما از انتقال پخش (مانند `streamable-http`) استفاده می‌کند و کلاینت شما هندلر پیام برای پردازش اعلان‌ها را پیاده‌سازی کرده است.

## اعلان‌های پیشرفت و سناریوها

این بخش مفهوم اعلان‌های پیشرفت در MCP، اهمیت آن‌ها و نحوه پیاده‌سازی آن‌ها با استفاده از Streamable HTTP را توضیح می‌دهد. همچنین یک تمرین عملی برای تقویت درک شما ارائه شده است.

اعلان‌های پیشرفت پیام‌های بلادرنگی هستند که از سرور به کلاینت در طول عملیات طولانی ارسال می‌شوند. به جای اینکه منتظر پایان کل فرآیند بمانیم، سرور کلاینت را از وضعیت فعلی مطلع می‌کند. این موضوع شفافیت، تجربه کاربری و اشکال‌زدایی را بهبود می‌بخشد.

**مثال:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### چرا از اعلان‌های پیشرفت استفاده کنیم؟

اعلان‌های پیشرفت به دلایل زیر اهمیت دارند:

- **تجربه کاربری بهتر:** کاربران به محض پیشرفت کار، به‌روزرسانی‌ها را می‌بینند، نه فقط در پایان.
- **بازخورد بلادرنگ:** کلاینت‌ها می‌توانند نوارهای پیشرفت یا لاگ‌ها را نمایش دهند و برنامه را پاسخگو نشان دهند.
- **اشکال‌زدایی و نظارت آسان‌تر:** توسعه‌دهندگان و کاربران می‌توانند ببینند فرآیند در کجا ممکن است کند یا متوقف شده باشد.

### چگونه اعلان‌های پیشرفت را پیاده‌سازی کنیم

نحوه پیاده‌سازی اعلان‌های پیشرفت در MCP به شرح زیر است:

- **در سرور:** از `ctx.info()` یا `ctx.log()` برای ارسال اعلان‌ها هنگام پردازش هر مورد استفاده کنید. این پیام‌ها قبل از آماده شدن نتیجه اصلی به کلاینت ارسال می‌شوند.
- **در کلاینت:** هندلر پیام پیاده‌سازی کنید که اعلان‌ها را هنگام رسیدن دریافت و نمایش دهد. این هندلر بین اعلان‌ها و نتیجه نهایی تمایز قائل می‌شود.

**مثال سرور:**

<summary>پایتون</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**مثال کلاینت:**

<details>
<summary>پایتون</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## ملاحظات امنیتی

هنگام پیاده‌سازی سرورهای MCP با استفاده از پروتکل‌های مبتنی بر HTTP، امنیت به یک نگرانی اساسی تبدیل می‌شود که نیازمند توجه دقیق به چندین مسیر حمله و مکانیزم‌های حفاظتی است.

### مرور کلی

امنیت هنگام در معرض قرار دادن سرورهای MCP روی HTTP بسیار حیاتی است. HTTP قابل پخش سطوح جدیدی از حملات را ایجاد می‌کند و نیازمند پیکربندی دقیق است.

### نکات کلیدی
- **اعتبارسنجی هدر Origin**: همیشه هدر `Origin` را اعتبارسنجی کنید تا از حملات DNS rebinding جلوگیری شود.
- **بستن به localhost**: برای توسعه محلی، سرورها را به `localhost` محدود کنید تا از دسترسی عمومی جلوگیری شود.
- **احراز هویت**: برای استقرار در محیط تولید، احراز هویت (مانند کلیدهای API، OAuth) را پیاده‌سازی کنید.
- **CORS**: سیاست‌های Cross-Origin Resource Sharing (CORS) را برای محدود کردن دسترسی تنظیم کنید.
- **HTTPS**: در محیط تولید از HTTPS برای رمزنگاری ترافیک استفاده کنید.

### بهترین شیوه‌ها
- هرگز به درخواست‌های ورودی بدون اعتبارسنجی اعتماد نکنید.
- تمام دسترسی‌ها و خطاها را ثبت و نظارت کنید.
- به‌روزرسانی منظم وابستگی‌ها برای رفع آسیب‌پذیری‌های امنیتی را فراموش نکنید.

### چالش‌ها
- تعادل بین امنیت و سهولت توسعه
- اطمینان از سازگاری با محیط‌های مختلف کلاینت

## ارتقا از SSE به HTTP قابل پخش

برای برنامه‌هایی که در حال حاضر از Server-Sent Events (SSE) استفاده می‌کنند، مهاجرت به HTTP قابل پخش امکانات بیشتری فراهم می‌کند و پایداری بلندمدت بهتری برای پیاده‌سازی‌های MCP شما به ارمغان می‌آورد.

### چرا ارتقا دهیم؟

دو دلیل قوی برای ارتقا از SSE به HTTP قابل پخش وجود دارد:

- HTTP قابل پخش مقیاس‌پذیری، سازگاری و پشتیبانی غنی‌تری از اعلان‌ها نسبت به SSE ارائه می‌دهد.
- این روش حمل و نقل توصیه‌شده برای برنامه‌های جدید MCP است.

### مراحل مهاجرت

در اینجا نحوه مهاجرت از SSE به HTTP قابل پخش در برنامه‌های MCP شما آمده است:

- **کد سرور را به‌روزرسانی کنید** تا از `transport="streamable-http"` در `mcp.run()` استفاده کند.
- **کد کلاینت را به‌روزرسانی کنید** تا به جای کلاینت SSE از `streamablehttp_client` استفاده شود.
- **یک هندلر پیام** در کلاینت پیاده‌سازی کنید تا اعلان‌ها را پردازش کند.
- **سازگاری با ابزارها و جریان‌های کاری موجود را تست کنید.**

### حفظ سازگاری

توصیه می‌شود در طول فرآیند مهاجرت، سازگاری با کلاینت‌های SSE موجود حفظ شود. چند راهکار عبارتند از:

- می‌توانید هر دو پروتکل SSE و HTTP قابل پخش را با اجرای هر کدام روی نقاط انتهایی مختلف پشتیبانی کنید.
- به تدریج کلاینت‌ها را به پروتکل جدید منتقل کنید.

### چالش‌ها

در طول مهاجرت باید به چالش‌های زیر توجه کنید:

- اطمینان از به‌روزرسانی همه کلاینت‌ها
- مدیریت تفاوت‌ها در نحوه ارسال اعلان‌ها

## ملاحظات امنیتی

امنیت باید اولویت اصلی هنگام پیاده‌سازی هر سروری باشد، به‌ویژه زمانی که از پروتکل‌های مبتنی بر HTTP مانند HTTP قابل پخش در MCP استفاده می‌کنید.

هنگام پیاده‌سازی سرورهای MCP با پروتکل‌های مبتنی بر HTTP، امنیت به یک نگرانی اساسی تبدیل می‌شود که نیازمند توجه دقیق به چندین مسیر حمله و مکانیزم‌های حفاظتی است.

### مرور کلی

امنیت هنگام در معرض قرار دادن سرورهای MCP روی HTTP بسیار حیاتی است. HTTP قابل پخش سطوح جدیدی از حملات را ایجاد می‌کند و نیازمند پیکربندی دقیق است.

در اینجا چند ملاحظه کلیدی امنیتی آورده شده است:

- **اعتبارسنجی هدر Origin**: همیشه هدر `Origin` را اعتبارسنجی کنید تا از حملات DNS rebinding جلوگیری شود.
- **بستن به localhost**: برای توسعه محلی، سرورها را به `localhost` محدود کنید تا از دسترسی عمومی جلوگیری شود.
- **احراز هویت**: برای استقرار در محیط تولید، احراز هویت (مانند کلیدهای API، OAuth) را پیاده‌سازی کنید.
- **CORS**: سیاست‌های Cross-Origin Resource Sharing (CORS) را برای محدود کردن دسترسی تنظیم کنید.
- **HTTPS**: در محیط تولید از HTTPS برای رمزنگاری ترافیک استفاده کنید.

### بهترین شیوه‌ها

علاوه بر این، در هنگام پیاده‌سازی امنیت در سرور استریمینگ MCP، بهتر است موارد زیر را رعایت کنید:

- هرگز به درخواست‌های ورودی بدون اعتبارسنجی اعتماد نکنید.
- تمام دسترسی‌ها و خطاها را ثبت و نظارت کنید.
- به‌روزرسانی منظم وابستگی‌ها برای رفع آسیب‌پذیری‌های امنیتی را فراموش نکنید.

### چالش‌ها

در پیاده‌سازی امنیت در سرورهای استریمینگ MCP با چالش‌هایی مواجه خواهید شد:

- تعادل بین امنیت و سهولت توسعه
- اطمینان از سازگاری با محیط‌های مختلف کلاینت

### تمرین: ساخت اپلیکیشن استریمینگ MCP خودتان

**سناریو:**
یک سرور و کلاینت MCP بسازید که سرور یک لیست از آیتم‌ها (مثلاً فایل‌ها یا اسناد) را پردازش کند و برای هر آیتم پردازش شده یک اعلان ارسال کند. کلاینت باید هر اعلان را به محض دریافت نمایش دهد.

**مراحل:**

1. یک ابزار سرور پیاده‌سازی کنید که لیستی را پردازش کرده و برای هر آیتم اعلان ارسال کند.
2. یک کلاینت با هندلر پیام پیاده‌سازی کنید که اعلان‌ها را به صورت زنده نمایش دهد.
3. پیاده‌سازی خود را با اجرای همزمان سرور و کلاینت تست کنید و اعلان‌ها را مشاهده کنید.

[Solution](./solution/README.md)

## مطالعه بیشتر و گام‌های بعدی

برای ادامه مسیر خود در استریمینگ MCP و گسترش دانش، این بخش منابع اضافی و گام‌های پیشنهادی برای ساخت برنامه‌های پیشرفته‌تر را ارائه می‌دهد.

### مطالعه بیشتر

- [Microsoft: معرفی HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS در ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: درخواست‌های استریمینگ](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### گام بعدی؟

- تلاش کنید ابزارهای MCP پیشرفته‌تری بسازید که از استریمینگ برای تحلیل‌های بلادرنگ، چت یا ویرایش مشترک استفاده می‌کنند.
- بررسی کنید چگونه می‌توان استریمینگ MCP را با فریم‌ورک‌های فرانت‌اند (React، Vue و غیره) برای به‌روزرسانی زنده رابط کاربری ادغام کرد.
- گام بعدی: [استفاده از AI Toolkit برای VSCode](../07-aitk/README.md)

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما در تلاش برای دقت هستیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است حاوی خطاها یا نادرستی‌هایی باشند. سند اصلی به زبان بومی خود باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حیاتی، ترجمه حرفه‌ای انسانی توصیه می‌شود. ما مسئول هیچ گونه سوءتفاهم یا تفسیر نادرستی که از استفاده این ترجمه ناشی شود، نیستیم.