<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "80e5c8949af5af0f401fce6f905990aa",
  "translation_date": "2025-07-17T10:05:25+00:00",
  "source_file": "08-BestPractices/README.md",
  "language_code": "sw"
}
-->
# Mazoea Bora ya Maendeleo ya MCP

## Muhtasari

Somo hili linazingatia mazoea bora ya hali ya juu kwa ajili ya kuendeleza, kupima, na kupeleka seva na vipengele vya MCP katika mazingira ya uzalishaji. Kadiri mifumo ya MCP inavyoongezeka kwa ugumu na umuhimu, kufuata mifumo iliyowekwa kunahakikisha kuaminika, urahisi wa matengenezo, na ushirikiano. Somo hili linakusanya hekima ya vitendo iliyopatikana kutoka kwa utekelezaji halisi wa MCP ili kukuongoza katika kuunda seva imara, yenye ufanisi na rasilimali, maelekezo, na zana zinazofaa.

## Malengo ya Kujifunza

Mwisho wa somo hili, utaweza:
- Kutumia mazoea bora ya sekta katika muundo wa seva na vipengele vya MCP
- Kuunda mikakati kamili ya upimaji kwa seva za MCP
- Kubuni mifumo ya kazi yenye ufanisi na inayoweza kutumika tena kwa programu tata za MCP
- Kutekeleza usimamizi sahihi wa makosa, uandikishaji, na ufuatiliaji katika seva za MCP
- Kuboresha utekelezaji wa MCP kwa ajili ya utendaji, usalama, na urahisi wa matengenezo

## Kanuni Msingi za MCP

Kabla ya kuingia katika mazoea maalum ya utekelezaji, ni muhimu kuelewa kanuni msingi zinazowaongoza maendeleo bora ya MCP:

1. **Mawasiliano Yaliyopangwa Kawaida**: MCP hutumia JSON-RPC 2.0 kama msingi wake, ikitoa muundo thabiti kwa maombi, majibu, na usimamizi wa makosa katika utekelezaji wote.

2. **Muundo Unaomzingatia Mtumiaji**: Daima weka kipaumbele ridhaa, udhibiti, na uwazi kwa mtumiaji katika utekelezaji wako wa MCP.

3. **Usalama Kwanza**: Tekeleza hatua madhubuti za usalama ikiwemo uthibitishaji, idhini, uhakiki, na ukomo wa kiwango cha maombi.

4. **Mimambo ya Moduli**: Buni seva zako za MCP kwa mtazamo wa moduli, ambapo kila zana na rasilimali ina lengo wazi na lililolengwa.

5. **Mihusiano Inayohifadhi Hali**: Tumia uwezo wa MCP kuhifadhi hali kati ya maombi mengi kwa mawasiliano yenye muktadha na muendelezo mzuri.

## Mazoea Bora Rasmi ya MCP

Mazoea bora yafuatayo yanatokana na nyaraka rasmi za Itifaki ya Muktadha wa Mfano:

### Mazoea Bora ya Usalama

1. **Ridhaa na Udhibiti wa Mtumiaji**: Daima omba ridhaa wazi ya mtumiaji kabla ya kufikia data au kufanya shughuli. Toa udhibiti wazi juu ya data inayoshirikiwa na hatua zinazoruhusiwa.

2. **Faragha ya Data**: Fichua data ya mtumiaji tu kwa ridhaa wazi na ilinde kwa udhibiti unaofaa wa upatikanaji. Linda dhidi ya usambazaji wa data usioidhinishwa.

3. **Usalama wa Zana**: Omba ridhaa wazi ya mtumiaji kabla ya kuitumia zana yoyote. Hakikisha watumiaji wanaelewa kazi ya kila zana na weka mipaka madhubuti ya usalama.

4. **Udhibiti wa Ruhusa za Zana**: Sanidi ni zana gani modeli inaruhusiwa kutumia wakati wa kikao, kuhakikisha zana zilizoidhinishwa tu ndizo zinapatikana.

5. **Uthibitishaji**: Omba uthibitishaji sahihi kabla ya kutoa upatikanaji wa zana, rasilimali, au shughuli nyeti kwa kutumia funguo za API, tokeni za OAuth, au njia nyingine salama za uthibitishaji.

6. **Uhakiki wa Vigezo**: Tekeleza uhakiki kwa kila matumizi ya zana ili kuzuia pembejeo zisizo sahihi au zenye madhara kufikia utekelezaji wa zana.

7. **Ukomo wa Kiwango cha Maombi**: Tekeleza ukomo wa kiwango cha maombi ili kuzuia matumizi mabaya na kuhakikisha usawa wa matumizi ya rasilimali za seva.

### Mazoea Bora ya Utekelezaji

1. **Mazungumzo ya Uwezo**: Wakati wa kuanzisha muunganisho, badilisha taarifa kuhusu vipengele vinavyotegemewa, matoleo ya itifaki, zana na rasilimali zinazopatikana.

2. **Muundo wa Zana**: Unda zana zilizo na lengo moja lililolengwa vizuri, badala ya zana kubwa zinazojaribu kushughulikia masuala mengi.

3. **Usimamizi wa Makosa**: Tekeleza ujumbe na nambari za makosa zilizopangwa ili kusaidia kugundua matatizo, kushughulikia kushindwa kwa heshima, na kutoa mrejesho unaoweza kutekelezeka.

4. **Uandikishaji**: Sanidi kumbukumbu zilizo na muundo kwa ajili ya ukaguzi, utatuzi wa matatizo, na ufuatiliaji wa mwingiliano wa itifaki.

5. **Ufuatiliaji wa Maendeleo**: Kwa shughuli zinazochukua muda mrefu, ripoti maendeleo ili kuwezesha interface za mtumiaji zenye majibu ya haraka.

6. **Kughairi Maombi**: Ruhusu wateja kughairi maombi yanayoendelea ambayo hayahitajiki tena au yanachukua muda mrefu sana.

## Marejeleo Zaidi

Kwa taarifa za kisasa zaidi kuhusu mazoea bora ya MCP, rejelea:
- [MCP Documentation](https://modelcontextprotocol.io/)
- [MCP Specification](https://spec.modelcontextprotocol.io/)
- [GitHub Repository](https://github.com/modelcontextprotocol)
- [Security Best Practices](https://modelcontextprotocol.io/specification/draft/basic/security_best_practices)

## Mifano ya Utekelezaji wa Vitendo

### Mazoea Bora ya Muundo wa Zana

#### 1. Kanuni ya Wajibu Mmoja

Kila zana ya MCP inapaswa kuwa na lengo wazi na lililolengwa. Badala ya kuunda zana kubwa zinazojaribu kushughulikia masuala mengi, tengeneza zana maalum zinazobobea katika kazi fulani.

```csharp
// A focused tool that does one thing well
public class WeatherForecastTool : ITool
{
    private readonly IWeatherService _weatherService;
    
    public WeatherForecastTool(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }
    
    public string Name => "weatherForecast";
    public string Description => "Gets weather forecast for a specific location";
    
    public ToolDefinition GetDefinition()
    {
        return new ToolDefinition
        {
            Name = Name,
            Description = Description,
            Parameters = new Dictionary<string, ParameterDefinition>
            {
                ["location"] = new ParameterDefinition
                {
                    Type = ParameterType.String,
                    Description = "City or location name"
                },
                ["days"] = new ParameterDefinition
                {
                    Type = ParameterType.Integer,
                    Description = "Number of forecast days",
                    Default = 3
                }
            },
            Required = new[] { "location" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = parameters.ContainsKey("days") 
            ? Convert.ToInt32(parameters["days"]) 
            : 3;
            
        var forecast = await _weatherService.GetForecastAsync(location, days);
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(JsonSerializer.Serialize(forecast))
            }
        };
    }
}
```

#### 2. Usimamizi Thabiti wa Makosa

Tekeleza usimamizi madhubuti wa makosa kwa ujumbe wa makosa yenye taarifa na mbinu zinazofaa za kupona.

```python
# Python example with comprehensive error handling
class DataQueryTool:
    def get_name(self):
        return "dataQuery"
        
    def get_description(self):
        return "Queries data from specified database tables"
    
    async def execute(self, parameters):
        try:
            # Parameter validation
            if "query" not in parameters:
                raise ToolParameterError("Missing required parameter: query")
                
            query = parameters["query"]
            
            # Security validation
            if self._contains_unsafe_sql(query):
                raise ToolSecurityError("Query contains potentially unsafe SQL")
            
            try:
                # Database operation with timeout
                async with timeout(10):  # 10 second timeout
                    result = await self._database.execute_query(query)
                    
                return ToolResponse(
                    content=[TextContent(json.dumps(result))]
                )
            except asyncio.TimeoutError:
                raise ToolExecutionError("Database query timed out after 10 seconds")
            except DatabaseConnectionError as e:
                # Connection errors might be transient
                self._log_error("Database connection error", e)
                raise ToolExecutionError(f"Database connection error: {str(e)}")
            except DatabaseQueryError as e:
                # Query errors are likely client errors
                self._log_error("Database query error", e)
                raise ToolExecutionError(f"Invalid query: {str(e)}")
                
        except ToolError:
            # Let tool-specific errors pass through
            raise
        except Exception as e:
            # Catch-all for unexpected errors
            self._log_error("Unexpected error in DataQueryTool", e)
            raise ToolExecutionError(f"An unexpected error occurred: {str(e)}")
    
    def _contains_unsafe_sql(self, query):
        # Implementation of SQL injection detection
        pass
        
    def _log_error(self, message, error):
        # Implementation of error logging
        pass
```

#### 3. Uhakiki wa Vigezo

Daima hakiki vigezo kwa kina ili kuzuia pembejeo zisizo sahihi au zenye madhara.

```javascript
// JavaScript/TypeScript example with detailed parameter validation
class FileOperationTool {
  getName() {
    return "fileOperation";
  }
  
  getDescription() {
    return "Performs file operations like read, write, and delete";
  }
  
  getDefinition() {
    return {
      name: this.getName(),
      description: this.getDescription(),
      parameters: {
        operation: {
          type: "string",
          description: "Operation to perform",
          enum: ["read", "write", "delete"]
        },
        path: {
          type: "string",
          description: "File path (must be within allowed directories)"
        },
        content: {
          type: "string",
          description: "Content to write (only for write operation)",
          optional: true
        }
      },
      required: ["operation", "path"]
    };
  }
  
  async execute(parameters) {
    // 1. Validate parameter presence
    if (!parameters.operation) {
      throw new ToolError("Missing required parameter: operation");
    }
    
    if (!parameters.path) {
      throw new ToolError("Missing required parameter: path");
    }
    
    // 2. Validate parameter types
    if (typeof parameters.operation !== "string") {
      throw new ToolError("Parameter 'operation' must be a string");
    }
    
    if (typeof parameters.path !== "string") {
      throw new ToolError("Parameter 'path' must be a string");
    }
    
    // 3. Validate parameter values
    const validOperations = ["read", "write", "delete"];
    if (!validOperations.includes(parameters.operation)) {
      throw new ToolError(`Invalid operation. Must be one of: ${validOperations.join(", ")}`);
    }
    
    // 4. Validate content presence for write operation
    if (parameters.operation === "write" && !parameters.content) {
      throw new ToolError("Content parameter is required for write operation");
    }
    
    // 5. Path safety validation
    if (!this.isPathWithinAllowedDirectories(parameters.path)) {
      throw new ToolError("Access denied: path is outside of allowed directories");
    }
    
    // Implementation based on validated parameters
    // ...
  }
  
  isPathWithinAllowedDirectories(path) {
    // Implementation of path safety check
    // ...
  }
}
```

### Mifano ya Utekelezaji wa Usalama

#### 1. Uthibitishaji na Idhini

```java
// Java example with authentication and authorization
public class SecureDataAccessTool implements Tool {
    private final AuthenticationService authService;
    private final AuthorizationService authzService;
    private final DataService dataService;
    
    // Dependency injection
    public SecureDataAccessTool(
            AuthenticationService authService,
            AuthorizationService authzService,
            DataService dataService) {
        this.authService = authService;
        this.authzService = authzService;
        this.dataService = dataService;
    }
    
    @Override
    public String getName() {
        return "secureDataAccess";
    }
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        // 1. Extract authentication context
        String authToken = request.getContext().getAuthToken();
        
        // 2. Authenticate user
        UserIdentity user;
        try {
            user = authService.validateToken(authToken);
        } catch (AuthenticationException e) {
            return ToolResponse.error("Authentication failed: " + e.getMessage());
        }
        
        // 3. Check authorization for the specific operation
        String dataId = request.getParameters().get("dataId").getAsString();
        String operation = request.getParameters().get("operation").getAsString();
        
        boolean isAuthorized = authzService.isAuthorized(user, "data:" + dataId, operation);
        if (!isAuthorized) {
            return ToolResponse.error("Access denied: Insufficient permissions for this operation");
        }
        
        // 4. Proceed with authorized operation
        try {
            switch (operation) {
                case "read":
                    Object data = dataService.getData(dataId, user.getId());
                    return ToolResponse.success(data);
                case "update":
                    JsonNode newData = request.getParameters().get("newData");
                    dataService.updateData(dataId, newData, user.getId());
                    return ToolResponse.success("Data updated successfully");
                default:
                    return ToolResponse.error("Unsupported operation: " + operation);
            }
        } catch (Exception e) {
            return ToolResponse.error("Operation failed: " + e.getMessage());
        }
    }
}
```

#### 2. Ukomo wa Kiwango cha Maombi

```csharp
// C# rate limiting implementation
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    private readonly ILogger<RateLimitingMiddleware> _logger;
    
    // Configuration options
    private readonly int _maxRequestsPerMinute;
    
    public RateLimitingMiddleware(
        RequestDelegate next,
        IMemoryCache cache,
        ILogger<RateLimitingMiddleware> logger,
        IConfiguration config)
    {
        _next = next;
        _cache = cache;
        _logger = logger;
        _maxRequestsPerMinute = config.GetValue<int>("RateLimit:MaxRequestsPerMinute", 60);
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // 1. Get client identifier (API key or user ID)
        string clientId = GetClientIdentifier(context);
        
        // 2. Get rate limiting key for this minute
        string cacheKey = $"rate_limit:{clientId}:{DateTime.UtcNow:yyyyMMddHHmm}";
        
        // 3. Check current request count
        if (!_cache.TryGetValue(cacheKey, out int requestCount))
        {
            requestCount = 0;
        }
        
        // 4. Enforce rate limit
        if (requestCount >= _maxRequestsPerMinute)
        {
            _logger.LogWarning("Rate limit exceeded for client {ClientId}", clientId);
            
            context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            context.Response.Headers.Add("Retry-After", "60");
            
            await context.Response.WriteAsJsonAsync(new
            {
                error = "Rate limit exceeded",
                message = "Too many requests. Please try again later.",
                retryAfterSeconds = 60
            });
            
            return;
        }
        
        // 5. Increment request count
        _cache.Set(cacheKey, requestCount + 1, TimeSpan.FromMinutes(2));
        
        // 6. Add rate limit headers
        context.Response.Headers.Add("X-RateLimit-Limit", _maxRequestsPerMinute.ToString());
        context.Response.Headers.Add("X-RateLimit-Remaining", (_maxRequestsPerMinute - requestCount - 1).ToString());
        
        // 7. Continue with the request
        await _next(context);
    }
    
    private string GetClientIdentifier(HttpContext context)
    {
        // Implementation to extract API key or user ID
        // ...
    }
}
```

## Mazoea Bora ya Upimaji

### 1. Upimaji wa Zana za MCP kwa Kifungu

Daima jaribu zana zako peke yake, ukitumia majaribio ya kuiga utegemezi wa nje:

```typescript
// TypeScript example of a tool unit test
describe('WeatherForecastTool', () => {
  let tool: WeatherForecastTool;
  let mockWeatherService: jest.Mocked<IWeatherService>;
  
  beforeEach(() => {
    // Create a mock weather service
    mockWeatherService = {
      getForecasts: jest.fn()
    } as any;
    
    // Create the tool with the mock dependency
    tool = new WeatherForecastTool(mockWeatherService);
  });
  
  it('should return weather forecast for a location', async () => {
    // Arrange
    const mockForecast = {
      location: 'Seattle',
      forecasts: [
        { date: '2025-07-16', temperature: 72, conditions: 'Sunny' },
        { date: '2025-07-17', temperature: 68, conditions: 'Partly Cloudy' },
        { date: '2025-07-18', temperature: 65, conditions: 'Rain' }
      ]
    };
    
    mockWeatherService.getForecasts.mockResolvedValue(mockForecast);
    
    // Act
    const response = await tool.execute({
      location: 'Seattle',
      days: 3
    });
    
    // Assert
    expect(mockWeatherService.getForecasts).toHaveBeenCalledWith('Seattle', 3);
    expect(response.content[0].text).toContain('Seattle');
    expect(response.content[0].text).toContain('Sunny');
  });
  
  it('should handle errors from the weather service', async () => {
    // Arrange
    mockWeatherService.getForecasts.mockRejectedValue(new Error('Service unavailable'));
    
    // Act & Assert
    await expect(tool.execute({
      location: 'Seattle',
      days: 3
    })).rejects.toThrow('Weather service error: Service unavailable');
  });
});
```

### 2. Upimaji wa Muunganisho

Jaribu mzunguko kamili kutoka kwa maombi ya mteja hadi majibu ya seva:

```python
# Python integration test example
@pytest.mark.asyncio
async def test_mcp_server_integration():
    # Start a test server
    server = McpServer()
    server.register_tool(WeatherForecastTool(MockWeatherService()))
    await server.start(port=5000)
    
    try:
        # Create a client
        client = McpClient("http://localhost:5000")
        
        # Test tool discovery
        tools = await client.discover_tools()
        assert "weatherForecast" in [t.name for t in tools]
        
        # Test tool execution
        response = await client.execute_tool("weatherForecast", {
            "location": "Seattle",
            "days": 3
        })
        
        # Verify response
        assert response.status_code == 200
        assert "Seattle" in response.content[0].text
        assert len(json.loads(response.content[0].text)["forecasts"]) == 3
        
    finally:
        # Clean up
        await server.stop()
```

## Uboreshaji wa Utendaji

### 1. Mikakati ya Kuhifadhi Kumbukumbu (Caching)

Tekeleza uhifadhi kumbukumbu unaofaa kupunguza ucheleweshaji na matumizi ya rasilimali:

```csharp
// C# example with caching
public class CachedWeatherTool : ITool
{
    private readonly IWeatherService _weatherService;
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachedWeatherTool> _logger;
    
    public CachedWeatherTool(
        IWeatherService weatherService,
        IDistributedCache cache,
        ILogger<CachedWeatherTool> logger)
    {
        _weatherService = weatherService;
        _cache = cache;
        _logger = logger;
    }
    
    public string Name => "weatherForecast";
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = Convert.ToInt32(parameters.GetValueOrDefault("days", 3));
        
        // Create cache key
        string cacheKey = $"weather:{location}:{days}";
        
        // Try to get from cache
        string cachedForecast = await _cache.GetStringAsync(cacheKey);
        if (!string.IsNullOrEmpty(cachedForecast))
        {
            _logger.LogInformation("Cache hit for weather forecast: {Location}", location);
            return new ToolResponse
            {
                Content = new List<ContentItem>
                {
                    new TextContent(cachedForecast)
                }
            };
        }
        
        // Cache miss - get from service
        _logger.LogInformation("Cache miss for weather forecast: {Location}", location);
        var forecast = await _weatherService.GetForecastAsync(location, days);
        string forecastJson = JsonSerializer.Serialize(forecast);
        
        // Store in cache (weather forecasts valid for 1 hour)
        await _cache.SetStringAsync(
            cacheKey,
            forecastJson,
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
            });
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(forecastJson)
            }
        };
    }
}

#### 2. Dependency Injection and Testability

Design tools to receive their dependencies through constructor injection, making them testable and configurable:

```java
// Mfano wa Java na sindano ya utegemezi
public class CurrencyConversionTool implements Tool {
    private final ExchangeRateService exchangeService;
    private final CacheService cacheService;
    private final Logger logger;
    
    // Utegemezi umeingizwa kupitia muundaji
    public CurrencyConversionTool(
            ExchangeRateService exchangeService,
            CacheService cacheService,
            Logger logger) {
        this.exchangeService = exchangeService;
        this.cacheService = cacheService;
        this.logger = logger;
    }
    
    // Utekelezaji wa zana
    // ...
}
```

#### 3. Composable Tools

Design tools that can be composed together to create more complex workflows:

```python
# Mfano wa Python unaoonyesha zana zinazoweza kuunganishwa
class DataFetchTool(Tool):
    def get_name(self):
        return "dataFetch"
    
    # Utekelezaji...

class DataAnalysisTool(Tool):
    def get_name(self):
        return "dataAnalysis"
    
    # Zana hii inaweza kutumia matokeo kutoka kwa zana ya dataFetch
    async def execute_async(self, request):
        # Utekelezaji...
        pass

class DataVisualizationTool(Tool):
    def get_name(self):
        return "dataVisualize"
    
    # Zana hii inaweza kutumia matokeo kutoka kwa zana ya dataAnalysis
    async def execute_async(self, request):
        # Utekelezaji...
        pass

# Zana hizi zinaweza kutumika peke yake au kama sehemu ya mtiririko wa kazi
```

### Schema Design Best Practices

The schema is the contract between the model and your tool. Well-designed schemas lead to better tool usability.

#### 1. Clear Parameter Descriptions

Always include descriptive information for each parameter:

```csharp
public object GetSchema()
{
    return new {
        type = "object",
        properties = new {
            query = new { 
                type = "string", 
                description = "Maandishi ya utafutaji. Tumia maneno sahihi kwa matokeo bora." 
            },
            filters = new {
                type = "object",
                description = "Vichujio hiari kupunguza matokeo ya utafutaji",
                properties = new {
                    dateRange = new { 
                        type = "string", 
                        description = "Muda wa tarehe kwa muundo YYYY-MM-DD:YYYY-MM-DD" 
                    },
                    category = new { 
                        type = "string", 
                        description = "Jina la kategoria kwa kuchuja" 
                    }
                }
            },
            limit = new { 
                type = "integer", 
                description = "Idadi kubwa ya matokeo kurudishwa (1-50)",
                default = 10
            }
        },
        required = new[] { "query" }
    };
}
```

#### 2. Validation Constraints

Include validation constraints to prevent invalid inputs:

```java
Map<String, Object> getSchema() {
    Map<String, Object> schema = new HashMap<>();
    schema.put("type", "object");
    
    Map<String, Object> properties = new HashMap<>();
    
    // Sifa ya barua pepe na uhakiki wa muundo
    Map<String, Object> email = new HashMap<>();
    email.put("type", "string");
    email.put("format", "email");
    email.put("description", "Anwani ya barua pepe ya mtumiaji");
    
    // Sifa ya umri na vizingiti vya nambari
    Map<String, Object> age = new HashMap<>();
    age.put("type", "integer");
    age.put("minimum", 13);
    age.put("maximum", 120);
    age.put("description", "Umri wa mtumiaji kwa miaka");
    
    // Sifa ya orodha ya chaguo
    Map<String, Object> subscription = new HashMap<>();
    subscription.put("type", "string");
    subscription.put("enum", Arrays.asList("free", "basic", "premium"));
    subscription.put("default", "free");
    subscription.put("description", "Kiwango cha usajili");
    
    properties.put("email", email);
    properties.put("age", age);
    properties.put("subscription", subscription);
    
    schema.put("properties", properties);
    schema.put("required", Arrays.asList("email"));
    
    return schema;
}
```

#### 3. Consistent Return Structures

Maintain consistency in your response structures to make it easier for models to interpret results:

```python
async def execute_async(self, request):
    try:
        # Fanya usindikaji wa ombi
        results = await self._search_database(request.parameters["query"])
        
        # Daima rudisha muundo thabiti
        return ToolResponse(
            result={
                "matches": [self._format_item(item) for item in results],
                "totalCount": len(results),
                "queryTime": calculation_time_ms,
                "status": "success"
            }
        )
    except Exception as e:
        return ToolResponse(
            result={
                "matches": [],
                "totalCount": 0,
                "queryTime": 0,
                "status": "error",
                "error": str(e)
            }
        )
    
def _format_item(self, item):
    """Hakikisha kila kipengee kina muundo thabiti"""
    return {
        "id": item.id,
        "title": item.title,
        "summary": item.summary[:100] + "..." if len(item.summary) > 100 else item.summary,
        "url": item.url,
        "relevance": item.score
    }
```

### Error Handling

Robust error handling is crucial for MCP tools to maintain reliability.

#### 1. Graceful Error Handling

Handle errors at appropriate levels and provide informative messages:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    try
    {
        string fileId = request.Parameters.GetProperty("fileId").GetString();
        
        try
        {
            var fileData = await _fileService.GetFileAsync(fileId);
            return new ToolResponse { 
                Result = JsonSerializer.SerializeToElement(fileData) 
            };
        }
        catch (FileNotFoundException)
        {
            throw new ToolExecutionException($"Faili haikupatikana: {fileId}");
        }
        catch (UnauthorizedAccessException)
        {
            throw new ToolExecutionException("Huna ruhusa ya kufikia faili hii");
        }
        catch (Exception ex) when (ex is IOException || ex is TimeoutException)
        {
            _logger.LogError(ex, "Hitilafu katika kufikia faili {FileId}", fileId);
            throw new ToolExecutionException("Hitilafu katika kufikia faili: Huduma haipatikani kwa sasa");
        }
    }
    catch (JsonException)
    {
        throw new ToolExecutionException("Muundo wa kitambulisho cha faili si sahihi");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Hitilafu isiyotarajiwa katika FileAccessTool");
        throw new ToolExecutionException("Hitilafu isiyotarajiwa imetokea");
    }
}
```

#### 2. Structured Error Responses

Return structured error information when possible:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    try {
        // Utekelezaji
    } catch (Exception ex) {
        Map<String, Object> errorResult = new HashMap<>();
        
        errorResult.put("success", false);
        
        if (ex instanceof ValidationException) {
            ValidationException validationEx = (ValidationException) ex;
            
            errorResult.put("errorType", "validation");
            errorResult.put("errorMessage", validationEx.getMessage());
            errorResult.put("validationErrors", validationEx.getErrors());
            
            return new ToolResponse.Builder()
                .setResult(errorResult)
                .build();
        }
        
        // Rudisha tena makosa mengine kama ToolExecutionException
        throw new ToolExecutionException("Utekelezaji wa zana umefaulu: " + ex.getMessage(), ex);
    }
}
```

#### 3. Retry Logic

Implement appropriate retry logic for transient failures:

```python
async def execute_async(self, request):
    max_retries = 3
    retry_count = 0
    base_delay = 1  # sekunde
    
    while retry_count < max_retries:
        try:
            # Piga API ya nje
            return await self._call_api(request.parameters)
        except TransientError as e:
            retry_count += 1
            if retry_count >= max_retries:
                raise ToolExecutionException(f"Shughuli imekosa baada ya majaribio {max_retries}: {str(e)}")
                
            # Kuchelewesha kwa mfululizo wa mara mbili
            delay = base_delay * (2 ** (retry_count - 1))
            logging.warning(f"Hitilafu ya muda, jaribu tena baada ya {delay}s: {str(e)}")
            await asyncio.sleep(delay)
        except Exception as e:
            # Hitilafu isiyo ya muda mfupi, usijaribu tena
            raise ToolExecutionException(f"Shughuli imekosa: {str(e)}")
```

### Performance Optimization

#### 1. Caching

Implement caching for expensive operations:

```csharp
public class CachedDataTool : IMcpTool
{
    private readonly IDatabase _database;
    private readonly IMemoryCache _cache;
    
    public CachedDataTool(IDatabase database, IMemoryCache cache)
    {
        _database = database;
        _cache = cache;
    }
    
    public async Task

ExecuteAsync(ToolRequest request)
    {
        var query = request.Parameters.GetProperty("query").GetString();
        
        // Tengeneza ufunguo wa cache kulingana na vigezo
        var cacheKey = $"data_query_{ComputeHash(query)}";
        
        // Jaribu kupata kutoka cache kwanza
        if (_cache.TryGetValue(cacheKey, out var cachedResult))
        {
            return new ToolResponse { Result = cachedResult };
        }
        
        // Cache haikupatikana - fanya utafutaji halisi
        var result = await _database.QueryAsync(query);
        
        // Hifadhi kwenye cache na muda wa kumalizika
        var cacheOptions = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(15));
            
        _cache.Set(cacheKey, JsonSerializer.SerializeToElement(result), cacheOptions);
        
        return new ToolResponse { Result = JsonSerializer.SerializeToElement(result) };
    }
    
    private string ComputeHash(string input)
    {
        // Utekelezaji wa kuunda hash thabiti kwa ufunguo wa cache
    }
}
```

#### 2. Asynchronous Processing

Use asynchronous programming patterns for I/O-bound operations:

```java
public class AsyncDocumentProcessingTool implements Tool {
    private final DocumentService documentService;
    private final ExecutorService executorService;
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        String documentId = request.getParameters().get("documentId").asText();
        
        // Kwa shughuli zinazochukua muda mrefu, rudisha ID ya mchakato mara moja
        String processId = UUID.randomUUID().toString();
        
        // Anza usindikaji wa async
        CompletableFuture.runAsync(() -> {
            try {
                // Fanya shughuli inayochukua muda mrefu
                documentService.processDocument(documentId);
                
                // Sasisha hali (kawaida huhifadhiwa kwenye database)
                processStatusRepository.updateStatus(processId, "completed");
            } catch (Exception ex) {
                processStatusRepository.updateStatus(processId, "failed", ex.getMessage());
            }
        }, executorService);
        
        // Rudisha jibu la haraka lenye process ID
        Map<String, Object> result = new HashMap<>();
        result.put("processId", processId);
        result.put("status", "processing");
        result.put("estimatedCompletionTime", ZonedDateTime.now().plusMinutes(5));
        
        return new ToolResponse.Builder().setResult(result).build();
    }
    
    // Zana ya kuangalia hali ya mchakato
    public class ProcessStatusTool implements Tool {
        @Override
        public ToolResponse execute(ToolRequest request) {
            String processId = request.getParameters().get("processId").asText();
            ProcessStatus status = processStatusRepository.getStatus(processId);
            
            return new ToolResponse.Builder().setResult(status).build();
        }
    }
}
```

#### 3. Resource Throttling

Implement resource throttling to prevent overload:

```python
class ThrottledApiTool(Tool):
    def __init__(self):
        self.rate_limiter = TokenBucketRateLimiter(
            tokens_per_second=5,  # Ruhusu maombi 5 kwa sekunde
            bucket_size=10        # Ruhusu mlipuko wa maombi hadi 10
        )
    
    async def execute_async(self, request):
        # Angalia kama tunaweza kuendelea au tunahitaji kusubiri
        delay = self.rate_limiter.get_delay_time()
        
        if delay > 0:
            if delay > 2.0:  # Ikiwa kusubiri ni kwa muda mrefu sana
                raise ToolExecutionException(
                    f"Kiwango cha maombi kimezidiwa. Tafadhali jaribu tena baada ya sekunde {delay:.1f}."
                )
            else:
                # Subiri kwa muda unaofaa
                await asyncio.sleep(delay)
        
        # Tumia tokeni moja na endelea na ombi
        self.rate_limiter.consume()
        
        # Piga API
        result = await self._call_api(request.parameters)
        return ToolResponse(result=result)

class TokenBucketRateLimiter:
    def __init__(self, tokens_per_second, bucket_size):
        self.tokens_per_second = tokens_per_second
        self.bucket_size = bucket_size
        self.tokens = bucket_size
        self.last_refill = time.time()
        self.lock = asyncio.Lock()
    
    async def get_delay_time(self):
        async with self.lock:
            self._refill()
            if self.tokens >= 1:
                return 0
            
            # Hesabu muda hadi tokeni ijapatikana
            return (1 - self.tokens) / self.tokens_per_second
    
    async def consume(self):
        async with self.lock:
            self._refill()
            self.tokens -= 1
    
    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        
        # Ongeza tokeni mpya kulingana na muda uliopita
        new_tokens = elapsed * self.tokens_per_second
        self.tokens = min(self.bucket_size, self.tokens + new_tokens)
        self.last_refill = now
```

### Security Best Practices

#### 1. Input Validation

Always validate input parameters thoroughly:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    // Thibitisha vigezo vipo
    if (!request.Parameters.TryGetProperty("query", out var queryProp))
    {
        throw new ToolExecutionException("Kigezo kinachohitajika hakipo: query");
    }
    
    // Thibitisha aina sahihi
    if (queryProp.ValueKind != JsonValueKind.String)
    {
        throw new ToolExecutionException("Kigezo cha query lazima kiwe aina ya string");
    }
    
    var query = queryProp.GetString();
    
    // Thibitisha maudhui ya string
    if (string.IsNullOrWhiteSpace(query))
    {
        throw new ToolExecutionException("Kigezo cha query hakiwezi kuwa tupu");
    }
    
    if (query.Length > 500)
    {
        throw new ToolExecutionException("Kigezo cha query kimezidi urefu wa herufi 500");
    }
    
    // Angalia mashambulizi ya SQL injection ikiwa yanahitajika
    if (ContainsSqlInjection(query))
    {
        throw new ToolExecutionException("Query si halali: ina SQL isiyo salama");
    }
    
    // Endelea na utekelezaji
    // ...
}
```

#### 2. Authorization Checks

Implement proper authorization checks:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    // Pata muktadha wa mtumiaji kutoka kwa ombi
    UserContext user = request.getContext().getUserContext();
    
    // Angalia kama mtumiaji ana ruhusa zinazohitajika
    if (!authorizationService.hasPermission(user, "documents:read")) {
        throw new ToolExecutionException("Mtumiaji hana ruhusa ya kufikia nyaraka");
    }
    
    // Kwa rasilimali maalum, angalia upatikanaji wa rasilimali hiyo
    String documentId = request.getParameters().get("documentId").asText();
    if (!documentService.canUserAccess(user.getId(), documentId)) {
        throw new ToolExecutionException("Upatikanaji umekataliwa kwa nyaraka iliyotakiwa");
    }
    
    // Endelea na utekelezaji wa zana
    // ...
}
```

#### 3. Sensitive Data Handling

Handle sensitive data carefully:

```python
class SecureDataTool(Tool):
    def get_schema(self):
        return {
            "type": "object",
            "properties": {
                "userId": {"type": "string"},
                "includeSensitiveData": {"type": "boolean", "default": False}
            },
            "required": ["userId"]
        }
    
    async def execute_async(self, request):
        user_id = request.parameters["userId"]
        include_sensitive = request.parameters.get("includeSensitiveData", False)
        
        # Pata data za mtumiaji
        user_data = await self.user_service.get_user_data(user_id)
        
        # Chuja sehemu nyeti isipokuwa zilitakikana wazi NA mtumiaji ana ruhusa
        if not include_sensitive or not self._is_authorized_for_sensitive_data(request):
            user_data = self._redact_sensitive_fields(user_data)
        
        return ToolResponse(result=user_data)
    
    def _is_authorized_for_sensitive_data(self, request):
        # Angalia kiwango cha ruhusa katika muktadha wa ombi
        auth_level = request.context.get("authorizationLevel")
        return auth_level == "admin"
    
    def _redact_sensitive_fields(self, user_data):
        # Tengeneza nakala ili kuepuka kubadilisha asili
        redacted = user_data.copy()
        
        # Ficha sehemu maalum nyeti
        sensitive_fields = ["ssn", "creditCardNumber", "password"]
        for field in sensitive_fields:
            if field in redacted:
                redacted[field] = "REDACTED"
        
        # Ficha data nyeti zilizomo ndani
        if "financialInfo" in redacted:
            redacted["financialInfo"] = {"available": True, "accessRestricted": True}
        
        return redacted
```

## Testing Best Practices for MCP Tools

Comprehensive testing ensures that MCP tools function correctly, handle edge cases, and integrate properly with the rest of the system.

### Unit Testing

#### 1. Test Each Tool in Isolation

Create focused tests for each tool's functionality:

```csharp
[Fact]
public async Task WeatherTool_ValidLocation_ReturnsCorrectForecast()
{
    // Andaa
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("Seattle", 3))
        .ReturnsAsync(new WeatherForecast(/* data ya mtihani */));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "Seattle", 
            days = 3 
        })
    );
    
    // Fanya
    var response = await tool.ExecuteAsync(request);
    
    // Thibitisha
    Assert.NotNull(response);
    var result = JsonSerializer.Deserialize<WeatherForecast>(response.Result);
    Assert.Equal("Seattle", result.Location);
    Assert.Equal(3, result.DailyForecasts.Count);
}

[Fact]
public async Task WeatherTool_InvalidLocation_ThrowsToolExecutionException()
{
    // Andaa
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("InvalidLocation", It.IsAny<int>()))
        .ThrowsAsync(new LocationNotFoundException("Location not found"));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "InvalidLocation", 
            days = 3 
        })
    );
    
    // Fanya & Thibitisha
    var exception = await Assert.ThrowsAsync<ToolExecutionException>(
        () => tool.ExecuteAsync(request)
    );
    
    Assert.Contains("Location not found", exception.Message);
}
```

#### 2. Schema Validation Testing

Test that schemas are valid and properly enforce constraints:

```java
@Test
public void testSchemaValidation() {
    // Tengeneza mfano wa zana
    SearchTool searchTool = new SearchTool();
    
    // Pata schema
    Object schema = searchTool.getSchema();
    
    // Badilisha schema kuwa JSON kwa ajili ya uthibitisho
    String schemaJson = objectMapper.writeValueAsString(schema);
    
    // Thibitisha schema ni JSONSchema halali
    JsonSchemaFactory factory = JsonSchemaFactory.byDefault();
    JsonSchema jsonSchema = factory.getJsonSchema(schemaJson);
    
    // Jaribu vigezo halali
    JsonNode validParams = objectMapper.createObjectNode()
        .put("query", "test query")
        .put("limit", 5);
        
    ProcessingReport validReport = jsonSchema.validate(validParams);
    assertTrue(validReport.isSuccess());
    
    // Jaribu kigezo kinachokosekana
    JsonNode missingRequired = objectMapper.createObjectNode()
        .put("limit", 5);
        
    ProcessingReport missingReport = jsonSchema.validate(missingRequired);
    assertFalse(missingReport.isSuccess());
    
    // Jaribu aina ya kigezo isiyo sahihi
    JsonNode invalidType = objectMapper.createObjectNode()
        .put("query", "test")
        .put("limit", "not-a-number");
        
    ProcessingReport invalidReport = jsonSchema.validate(invalidType);
    assertFalse(invalidReport.isSuccess());
}
```

#### 3. Error Handling Tests

Create specific tests for error conditions:

```python
@pytest.mark.asyncio
async def test_api_tool_handles_timeout():
    # Andaa
    tool = ApiTool(timeout=0.1)  # Muda mfupi sana wa kusubiri
    
    # Tengeneza ombi ambalo litaisha muda
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            callback=lambda *args, **kwargs: asyncio.sleep(0.5)  # Zaidi ya muda wa kusubiri
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # Fanya & Thibitisha
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # Thibitisha ujumbe wa kosa
        assert "timed out" in str(exc_info.value).lower()

@pytest.mark.asyncio
async def test_api_tool_handles_rate_limiting():
    # Andaa
    tool = ApiTool()
    
    # Tengeneza jibu lililozuiliwa kwa kiwango cha maombi
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            status=429,
            headers={"Retry-After": "2"},
            body=json.dumps({"error": "Rate limit exceeded"})
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # Fanya & Thibitisha
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # Thibitisha kosa lina taarifa za kiwango cha maombi
        error_msg = str(exc_info.value).lower()
        assert "rate limit" in error_msg
        assert "try again" in error_msg
```

### Integration Testing

#### 1. Tool Chain Testing

Test tools working together in expected combinations:

```csharp
[Fact]
public async Task DataProcessingWorkflow_CompletesSuccessfully()
{
    // Andaa
    var dataFetchTool = new DataFetchTool(mockDataService.Object);
    var analysisTools = new DataAnalysisTool(mockAnalysisService.Object);
    var visualizationTool = new DataVisualizationTool(mockVisualizationService.Object);
    
    var toolRegistry = new ToolRegistry();
    toolRegistry.RegisterTool(dataFetchTool);
    toolRegistry.RegisterTool(analysisTools);
    toolRegistry.RegisterTool(visualizationTool);
    
    var workflowExecutor = new WorkflowExecutor(toolRegistry);
    
    // Fanya
var result = await workflowExecutor.ExecuteWorkflowAsync(new[] {
    new ToolCall("dataFetch", new { source = "sales2023" }),
    new ToolCall("dataAnalysis", ctx =>
        new { 
            data = ctx.GetResult("dataFetch"),
            analysis = "trend" 
        }),
    new ToolCall("dataVisualize", ctx => new {
        analysisResult = ctx.GetResult("dataAnalysis"),
        type = "line-chart"
    })
});

// Thibitisha
Assert.NotNull(result);
Assert.True(result.Success);
Assert.NotNull(result.GetResult("dataVisualize"));
Assert.Contains("chartUrl", result.GetResult("dataVisualize").ToString());
}
```

#### 2. MCP Server Testing

Test the MCP server with full tool registration and execution:

```java
@SpringBootTest
@AutoConfigureMockMvc
public class McpServerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void testToolDiscovery() throws Exception {
        // Jaribu kiungo cha kugundua zana
        mockMvc.perform(get("/mcp/tools"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.tools").isArray())
            .andExpect(jsonPath("$.tools[*].name").value(hasItems(
                "weatherForecast", "calculator", "documentSearch"
            )));
    }
    
    @Test
    public void testToolExecution() throws Exception {
        // Tengeneza ombi la zana
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "add");
        parameters.put("a", 5);
        parameters.put("b", 7);
        request.put("parameters", parameters);
        
        // Tuma ombi na hakiki jibu
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.result.value").value(12));
    }
    
    @Test
    public void testToolValidation() throws Exception {
        // Tengeneza ombi batili la zana
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "divide");
        parameters.put("a", 10);
        // Parameter "b" haipo
        request.put("parameters", parameters);
        
        // Tuma ombi na hakiki jibu la kosa
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.error").exists());
    }
}
```

#### 3. End-to-End Testing

Test complete workflows from model prompt to tool execution:

```python
@pytest.mark.asyncio
async def test_model_interaction_with_tool():
    # Andaa - Weka mteja wa MCP na mfano wa kuigiza
    mcp_client = McpClient(server_url="http://localhost:5000")
    
    # Majibu ya mfano wa kuigiza
    mock_model = MockLanguageModel([
        MockResponse(
            "Hali ya hewa iko vipi Seattle?",
            tool_calls=[{
                "tool_name": "weatherForecast",
                "parameters": {"location": "Seattle", "days": 3}
            }]
        ),
        MockResponse(
            "Hapa ni utabiri wa hali ya hewa kwa Seattle:\n- Leo: 65°F, Mawingu kidogo\n- Kesho: 68°F, Jua\n- Baada ya kesho: 62°F, Mvua",
            tool_calls=[]
        )
    ])
    
    # Jibu la zana ya hali ya hewa ya kuigiza
    with aioresponses() as mocked:
        mocked.post(
            "http://localhost:5000/mcp/execute",
            payload={
                "result": {
                    "location": "Seattle",
                    "forecast": [
                        {"date": "2023-06-01", "temperature": 65, "conditions": "Partly Cloudy"},
                        {"date": "2023-06-02", "temperature": 68, "conditions": "Sunny"},
                        {"date": "2023-06-03", "temperature": 62, "conditions": "Rain"}
                    ]
                }
            }
        )
        
        # Fanya
        response = await mcp_client.send_prompt(
            "Hali ya hewa iko vipi Seattle?",
            model=mock_model,
            allowed_tools=["weatherForecast"]
        )
        
        # Thibitisha
        assert "Seattle" in response.generated_text
        assert "65" in response.generated_text
        assert "Sunny" in response.generated_text
        assert "Rain" in response.generated_text
        assert len(response.tool_calls) == 1
        assert response.tool_calls[0].tool_name == "weatherForecast"
```

### Performance Testing

#### 1. Load Testing

Test how many concurrent requests your MCP server can handle:

```csharp
[Fact]
public async Task McpServer_HandlesHighConcurrency()
{
    // Andaa
    var server = new McpServer(
        name: "TestServer",
        version: "1.0",
        maxConcurrentRequests: 100
    );
    
    server.RegisterTool(new FastExecutingTool());
    await server.StartAsync();
    
    var client = new McpClient("http://localhost:5000");
    
    // Fanya
    var tasks = new List<Task<McpResponse>>();
    for (int i = 0; i < 1000; i++)
    {
        tasks.Add(client.ExecuteToolAsync("fastTool", new { iteration = i }));
    }
    
    var results = await Task.WhenAll(tasks);
    
    // Thibitisha
    Assert.Equal(1000, results.Length);
    Assert.All(results, r => Assert.NotNull(r));
}
```

#### 2. Stress Testing

Test the system under extreme load:

```java
@Test
public void testServerUnderStress() {
    int maxUsers = 1000;
    int rampUpTimeSeconds = 60;
    int testDurationSeconds = 300;
    
    // Weka JMeter kwa mtihani wa msongo
    StandardJMeterEngine jmeter = new StandardJMeterEngine();
    
    // Sanidi mpango wa mtihani wa JMeter
    HashTree testPlanTree = new HashTree();
    
    // Tengeneza mpango wa mtihani, kikundi cha thread, samplers, n.k.
    TestPlan testPlan = new TestPlan("MCP Server Stress Test");
    testPlanTree.add(testPlan);
    
    ThreadGroup threadGroup = new ThreadGroup();
    threadGroup.setNumThreads(maxUsers);
    threadGroup.setRampUp(rampUpTimeSeconds);
    threadGroup.setScheduler(true);
    threadGroup.setDuration(testDurationSeconds);
    
    testPlanTree.add(threadGroup);
    
    // Ongeza sampler ya HTTP kwa utekelezaji wa zana
    HTTPSampler toolExecutionSampler = new HTTPSampler();
    toolExecutionSampler.setDomain("localhost");
    toolExecutionSampler.setPort(5000);
    toolExecutionSampler.setPath("/mcp/execute");
    toolExecutionSampler.setMethod("POST");
    toolExecutionSampler.addArgument("toolName", "calculator");
    toolExecutionSampler.addArgument("parameters", "{\"operation\":\"add\",\"a\":5,\"b\":7}");
    
    threadGroup.add(toolExecutionSampler);
    
    // Ongeza wasikilizaji
    SummaryReport summaryReport = new SummaryReport();
    threadGroup.add(summaryReport);
    
    // Endesha mtihani
    jmeter.configure(testPlanTree);
    jmeter.run();
    
    // Hakiki matokeo
    assertEquals(0, summaryReport.getErrorCount());
    assertTrue(summaryReport.getAverage() < 200); // Muda wa majibu wastani < 200ms
    assertTrue(summaryReport.getPercentile(90.0) < 500); // Asilimia 90 < 500ms
}
```

#### 3. Monitoring and Profiling

Set up monitoring for long-term performance analysis:

```python
# Sanidi ufuatiliaji kwa server ya MCP
def configure_monitoring(server):
    # Weka vipimo vya Prometheus
    prometheus_metrics = {
        "request_count": Counter("mcp_requests_total", "Jumla ya maombi ya MCP"),
        "request_latency": Histogram(
            "mcp_request_duration_seconds", 
            "Muda wa ombi kwa sekunde",
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_execution_count": Counter(
            "mcp_tool_executions_total", 
            "Idadi ya utekelezaji wa zana",
            labelnames=["tool_name"]
        ),
        "tool_execution_latency": Histogram(
            "mcp_tool_duration_seconds", 
            "Muda wa utekelezaji wa zana kwa sekunde",
            labelnames=["tool_name"],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_errors": Counter(
            "mcp_tool_errors_total",
            "Makosa ya utekelezaji wa zana",
            labelnames=["tool_name", "error_type"]
        )
    }
    
    # Ongeza middleware kwa kupima muda na kurekodi vipimo
    server.add_middleware(PrometheusMiddleware(prometheus_metrics))
    
    # Fungua kiungo cha vipimo
    @server.router.get("/metrics")
    async def metrics():
        return generate_latest()
    
    return server
```

## MCP Workflow Design Patterns

Well-designed MCP workflows improve efficiency, reliability, and maintainability. Here are key patterns to follow:

### 1. Chain of Tools Pattern

Connect multiple tools in a sequence where each tool's output becomes the input for the next:

```python
# Utekelezaji wa mnyororo wa zana kwa Python
class ChainWorkflow:
    def __init__(self, tools_chain):
        self.tools_chain = tools_chain  # Orodha ya majina ya zana za kutekeleza kwa mfululizo
    
    async def execute(self, mcp_client, initial_input):
        current_result = initial_input
        all_results = {"input": initial_input}
        
        for tool_name in self.tools_chain:
            # Tekeleza kila zana katika mnyororo, ukitumia matokeo ya awali
            response = await mcp_client.execute_tool(tool_name, current_result)
            
            # Hifadhi matokeo na tumia kama ingizo kwa zana inayofuata
            all_results[tool_name] = response.result
            current_result = response.result
        
        return {
            "final_result": current_result,
            "all_results": all_results
        }

# Mfano wa matumizi
data_processing_chain = ChainWorkflow([
    "dataFetch",
    "dataCleaner",
    "dataAnalyzer",
    "dataVisualizer"
])

result = await data_processing_chain.execute(
    mcp_client,
    {"source": "sales_database", "table": "transactions"}
)
```

### 2. Dispatcher Pattern

Use a central tool that dispatches to specialized tools based on input:

```csharp
public class ContentDispatcherTool : IMcpTool
{
    private readonly IMcpClient _mcpClient;
    
    public ContentDispatcherTool(IMcpClient mcpClient)
    {
        _mcpClient = mcpClient;
    }
    
    public string Name => "contentProcessor";
    public string Description => "Inashughulikia aina mbalimbali za maudhui";
    
    public object GetSchema()
    {
        return new {
            type = "object",
            properties = new {
                content = new { type = "string" },
                contentType = new { 
                    type = "string",
                    enum = new[] { "text", "html", "markdown", "csv", "code" }
                },
                operation = new { 
                    type = "string",
                    enum = new[] { "summarize", "analyze", "extract", "convert" }
                }
            },
            required = new[] { "content", "contentType", "operation" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
    {
        var content = request.Parameters.GetProperty("content").GetString();
        var contentType = request.Parameters.GetProperty("contentType").GetString();
        var operation = request.Parameters.GetProperty("operation").GetString();
        
        // Amua zana maalum itakayotumika
        string targetTool = DetermineTargetTool(contentType, operation);
        
        // Peleka kwa zana maalum
        var specializedResponse = await _mcpClient.ExecuteToolAsync(
            targetTool,
            new { content, options = GetOptionsForTool(targetTool, operation) }
        );
        
        return new ToolResponse { Result = specializedResponse.Result };
    }
    
    private string DetermineTargetTool(string contentType, string operation)
    {
        return (contentType, operation) switch
        {
            ("text", "summarize") => "textSummarizer",
            ("text", "analyze") => "textAnalyzer",
            ("html", _) => "htmlProcessor",
            ("markdown", _) => "markdownProcessor",
            ("csv", _) =>
# Muhtasari wa csvProcessor

csvProcessor ni zana yenye nguvu inayotumiwa kusindika faili za CSV kwa urahisi na kwa ufanisi. Inakuwezesha kusoma, kuandika, na kubadilisha data za CSV kwa njia rahisi.

## Sifa kuu

- Kusoma faili za CSV na kuunda orodha za vitu
- Kuandika data kwenye faili za CSV kwa muundo unaotakiwa
- Kubadilisha data kwa kutumia vichujio na mabadiliko mbalimbali
- Kushughulikia makosa ya kawaida ya CSV kwa ustadi

## Jinsi ya kutumia

1. Ingiza csvProcessor kwenye mradi wako.
2. Tumia `readCSV()` kusoma faili za CSV.
3. Tumia `processData()` kubadilisha data kama inavyohitajika.
4. Tumia `writeCSV()` kuandika data zilizobadilishwa kwenye faili mpya.

## Vidokezo vya matumizi

- Hakikisha faili za CSV zina muundo unaotarajiwa ili kuepuka makosa.
- Tumia vichujio vya csvProcessor kuboresha ubora wa data.
- Angalia maelezo ya makosa kwa usahihi ili kutatua matatizo kwa haraka.

[!NOTE] csvProcessor inasaidia aina mbalimbali za faili za CSV, ikiwa ni pamoja na zile zenye vichwa vya safu na zile zisizo na vichwa.

[!WARNING] Usisahau kufunga rasilimali baada ya kumaliza kusindika faili ili kuepuka matatizo ya kumbukumbu.

[!TIP] Tumia vipengele vya csvProcessor vya kuunganisha data ili kuunda ripoti za kina kwa urahisi.

[!IMPORTANT] Hakikisha unatumia toleo la hivi karibuni la csvProcessor kwa utendaji bora na usalama.

[!CAUTION] Epuka kubadilisha majina ya vigezo vya csvProcessor ili kuepuka makosa ya utekelezaji.
            ("code", _) => "codeAnalyzer",
            _ => throw new ToolExecutionException($"Hakuna chombo kinachopatikana kwa {contentType}/{operation}")
        };
    }
    
    private object GetOptionsForTool(string toolName, string operation)
    {
        // Rudisha chaguzi zinazofaa kwa kila chombo maalum
        return toolName switch
        {
            "textSummarizer" => new { length = "medium" },
            "htmlProcessor" => new { cleanUp = true, operation },
            // Chaguzi kwa vyombo vingine...
            _ => new { }
        };
    }
}
```

### 3. Parallel Processing Pattern

Execute multiple tools simultaneously for efficiency:

```java
public class ParallelDataProcessingWorkflow {
    private final McpClient mcpClient;
    
    public ParallelDataProcessingWorkflow(McpClient mcpClient) {
        this.mcpClient = mcpClient;
    }
    
    public WorkflowResult execute(String datasetId) {
        // Hatua 1: Pata metadata ya dataset (kwa mfululizo)
        ToolResponse metadataResponse = mcpClient.executeTool("datasetMetadata", 
            Map.of("datasetId", datasetId));
        
        // Hatua 2: Anzisha uchambuzi mwingi kwa wakati mmoja
        CompletableFuture<ToolResponse> statisticalAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("statisticalAnalysis", Map.of(
                "datasetId", datasetId,
                "type", "comprehensive"
            ))
        );
        
        CompletableFuture<ToolResponse> correlationAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("correlationAnalysis", Map.of(
                "datasetId", datasetId,
                "method", "pearson"
            ))
        );
        
        CompletableFuture<ToolResponse> outlierDetection = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("outlierDetection", Map.of(
                "datasetId", datasetId,
                "sensitivity", "medium"
            ))
        );
        
        // Subiri kazi zote za sambamba kukamilika
        CompletableFuture<Void> allAnalyses = CompletableFuture.allOf(
            statisticalAnalysis, correlationAnalysis, outlierDetection
        );
        
        allAnalyses.join();  // Subiri kukamilika
        
        // Hatua 3: Changanya matokeo
        Map<String, Object> combinedResults = new HashMap<>();
        combinedResults.put("metadata", metadataResponse.getResult());
        combinedResults.put("statistics", statisticalAnalysis.join().getResult());
        combinedResults.put("correlations", correlationAnalysis.join().getResult());
        combinedResults.put("outliers", outlierDetection.join().getResult());
        
        // Hatua 4: Tengeneza ripoti ya muhtasari
        ToolResponse summaryResponse = mcpClient.executeTool("reportGenerator", 
            Map.of("analysisResults", combinedResults));
        
        // Rudisha matokeo kamili ya workflow
        WorkflowResult result = new WorkflowResult();
        result.setDatasetId(datasetId);
        result.setAnalysisResults(combinedResults);
        result.setSummaryReport(summaryResponse.getResult());
        
        return result;
    }
}
```

### 4. Error Recovery Pattern

Implement graceful fallbacks for tool failures:

```python
class ResilientWorkflow:
    def __init__(self, mcp_client):
        self.client = mcp_client
    
    async def execute_with_fallback(self, primary_tool, fallback_tool, parameters):
        try:
            # Jaribu chombo cha msingi kwanza
            response = await self.client.execute_tool(primary_tool, parameters)
            return {
                "result": response.result,
                "source": "primary",
                "tool": primary_tool
            }
        except ToolExecutionException as e:
            # Rekodi kushindwa
            logging.warning(f"Chombo cha msingi '{primary_tool}' kimeshindwa: {str(e)}")
            
            # Tumia chombo cha ziada
            try:
                # Huenda ukahitaji kubadilisha vigezo kwa chombo cha ziada
                fallback_params = self._adapt_parameters(parameters, primary_tool, fallback_tool)
                
                response = await self.client.execute_tool(fallback_tool, fallback_params)
                return {
                    "result": response.result,
                    "source": "fallback",
                    "tool": fallback_tool,
                    "primaryError": str(e)
                }
            except ToolExecutionException as fallback_error:
                # Vyombo vyote vimekosa
                logging.error(f"Vyombo vya msingi na vya ziada vimekosa. Hitilafu ya ziada: {str(fallback_error)}")
                raise WorkflowExecutionException(
                    f"Workflow imeshindwa: hitilafu ya msingi: {str(e)}; hitilafu ya ziada: {str(fallback_error)}"
                )
    
    def _adapt_parameters(self, params, from_tool, to_tool):
        """Badilisha vigezo kati ya vyombo tofauti ikiwa inahitajika"""
        # Utekelezaji huu utategemea vyombo maalum
        # Kwa mfano huu, tutarudisha vigezo vya awali tu
        return params

# Mfano wa matumizi
async def get_weather(workflow, location):
    return await workflow.execute_with_fallback(
        "premiumWeatherService",  # API ya hali ya hewa ya msingi (inayolipiwa)
        "basicWeatherService",    # API ya hali ya hewa ya ziada (bure)
        {"location": location}
    )
```

### 5. Workflow Composition Pattern

Build complex workflows by composing simpler ones:

```csharp
public class CompositeWorkflow : IWorkflow
{
    private readonly List<IWorkflow> _workflows;
    
    public CompositeWorkflow(IEnumerable<IWorkflow> workflows)
    {
        _workflows = new List<IWorkflow>(workflows);
    }
    
    public async Task<WorkflowResult> ExecuteAsync(WorkflowContext context)
    {
        var results = new Dictionary<string, object>();
        
        foreach (var workflow in _workflows)
        {
            var workflowResult = await workflow.ExecuteAsync(context);
            
            // Hifadhi matokeo ya kila workflow
            results[workflow.Name] = workflowResult;
            
            // Sasisha muktadha na matokeo kwa workflow inayofuata
            context = context.WithResult(workflow.Name, workflowResult);
        }
        
        return new WorkflowResult(results);
    }
    
    public string Name => "CompositeWorkflow";
    public string Description => "Hutekeleza workflows nyingi mfululizo";
}

// Mfano wa matumizi
var documentWorkflow = new CompositeWorkflow(new IWorkflow[] {
    new DocumentFetchWorkflow(),
    new DocumentProcessingWorkflow(),
    new InsightGenerationWorkflow(),
    new ReportGenerationWorkflow()
});

var result = await documentWorkflow.ExecuteAsync(new WorkflowContext {
    Parameters = new { documentId = "12345" }
});
```

# Testing MCP Servers: Best Practices and Top Tips

## Overview

Testing is a critical aspect of developing reliable, high-quality MCP servers. This guide provides comprehensive best practices and tips for testing your MCP servers throughout the development lifecycle, from unit tests to integration tests and end-to-end validation.

## Why Testing Matters for MCP Servers

MCP servers serve as crucial middleware between AI models and client applications. Thorough testing ensures:

- Reliability in production environments
- Accurate handling of requests and responses
- Proper implementation of MCP specifications
- Resilience against failures and edge cases
- Consistent performance under various loads

## Unit Testing for MCP Servers

### Unit Testing (Foundation)

Unit tests verify individual components of your MCP server in isolation.

#### What to Test

1. **Resource Handlers**: Test each resource handler's logic independently
2. **Tool Implementations**: Verify tool behavior with various inputs
3. **Prompt Templates**: Ensure prompt templates render correctly
4. **Schema Validation**: Test parameter validation logic
5. **Error Handling**: Verify error responses for invalid inputs

#### Best Practices for Unit Testing

```csharp
// Mfano wa mtihani wa unit kwa chombo cha calculator katika C#
[Fact]
public async Task CalculatorTool_Add_ReturnsCorrectSum()
{
    // Andaa
    var calculator = new CalculatorTool();
    var parameters = new Dictionary<string, object>
    {
        ["operation"] = "add",
        ["a"] = 5,
        ["b"] = 7
    };
    
    // Fanya
    var response = await calculator.ExecuteAsync(parameters);
    var result = JsonSerializer.Deserialize<CalculationResult>(response.Content[0].ToString());
    
    // Thibitisha
    Assert.Equal(12, result.Value);
}
```

```python
# Mfano wa mtihani wa unit kwa chombo cha calculator katika Python
def test_calculator_tool_add():
    # Andaa
    calculator = CalculatorTool()
    parameters = {
        "operation": "add",
        "a": 5,
        "b": 7
    }
    
    # Fanya
    response = calculator.execute(parameters)
    result = json.loads(response.content[0].text)
    
    # Thibitisha
    assert result["value"] == 12
```

### Integration Testing (Middle Layer)

Integration tests verify interactions between components of your MCP server.

#### What to Test

1. **Server Initialization**: Test server startup with various configurations
2. **Route Registration**: Verify all endpoints are correctly registered
3. **Request Processing**: Test the full request-response cycle
4. **Error Propagation**: Ensure errors are properly handled across components
5. **Authentication & Authorization**: Test security mechanisms

#### Best Practices for Integration Testing

```csharp
// Mfano wa mtihani wa muunganisho kwa server ya MCP katika C#
[Fact]
public async Task Server_ProcessToolRequest_ReturnsValidResponse()
{
    // Andaa
    var server = new McpServer();
    server.RegisterTool(new CalculatorTool());
    await server.StartAsync();
    
    var request = new McpRequest
    {
        Tool = "calculator",
        Parameters = new Dictionary<string, object>
        {
            ["operation"] = "multiply",
            ["a"] = 6,
            ["b"] = 7
        }
    };
    
    // Fanya
    var response = await server.ProcessRequestAsync(request);
    
    // Thibitisha
    Assert.NotNull(response);
    Assert.Equal(McpStatusCodes.Success, response.StatusCode);
    // Thibitisho za ziada kwa maudhui ya jibu
    
    // Safisha
    await server.StopAsync();
}
```

### End-to-End Testing (Top Layer)

End-to-end tests verify the complete system behavior from client to server.

#### What to Test

1. **Client-Server Communication**: Test complete request-response cycles
2. **Real Client SDKs**: Test with actual client implementations
3. **Performance Under Load**: Verify behavior with multiple concurrent requests
4. **Error Recovery**: Test system recovery from failures
5. **Long-Running Operations**: Verify handling of streaming and long operations

#### Best Practices for E2E Testing

```typescript
// Mfano wa mtihani wa E2E na mteja katika TypeScript
describe('MCP Server E2E Tests', () => {
  let client: McpClient;
  
  beforeAll(async () => {
    // Anzisha server katika mazingira ya mtihani
    await startTestServer();
    client = new McpClient('http://localhost:5000');
  });
  
  afterAll(async () => {
    await stopTestServer();
  });
  
  test('Mteja anaweza kuitisha chombo cha calculator na kupata jibu sahihi', async () => {
    // Fanya
    const response = await client.invokeToolAsync('calculator', {
      operation: 'divide',
      a: 20,
      b: 4
    });
    
    // Thibitisha
    expect(response.statusCode).toBe(200);
    expect(response.content[0].text).toContain('5');
  });
});
```

## Mocking Strategies for MCP Testing

Mocking is essential for isolating components during testing.

### Components to Mock

1. **External AI Models**: Mock model responses for predictable testing
2. **External Services**: Mock API dependencies (databases, third-party services)
3. **Authentication Services**: Mock identity providers
4. **Resource Providers**: Mock expensive resource handlers

### Example: Mocking an AI Model Response

```csharp
// Mfano wa C# na Moq
var mockModel = new Mock<ILanguageModel>();
mockModel
    .Setup(m => m.GenerateResponseAsync(
        It.IsAny<string>(),
        It.IsAny<McpRequestContext>()))
    .ReturnsAsync(new ModelResponse { 
        Text = "Mocked model response",
        FinishReason = FinishReason.Completed
    });

var server = new McpServer(modelClient: mockModel.Object);
```

```python
# Mfano wa Python na unittest.mock
@patch('mcp_server.models.OpenAIModel')
def test_with_mock_model(mock_model):
    # Sanidi mock
    mock_model.return_value.generate_response.return_value = {
        "text": "Mocked model response",
        "finish_reason": "completed"
    }
    
    # Tumia mock katika mtihani
    server = McpServer(model_client=mock_model)
    # Endelea na mtihani
```

## Performance Testing

Performance testing is crucial for production MCP servers.

### What to Measure

1. **Latency**: Response time for requests
2. **Throughput**: Requests handled per second
3. **Resource Utilization**: CPU, memory, network usage
4. **Concurrency Handling**: Behavior under parallel requests
5. **Scaling Characteristics**: Performance as load increases

### Tools for Performance Testing

- **k6**: Open-source load testing tool
- **JMeter**: Comprehensive performance testing
- **Locust**: Python-based load testing
- **Azure Load Testing**: Cloud-based performance testing

### Example: Basic Load Test with k6

```javascript
// script ya k6 kwa mtihani wa mzigo wa server ya MCP
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  vus: 10,  // watumiaji wa mtandao 10
  duration: '30s',
};

export default function () {
  const payload = JSON.stringify({
    tool: 'calculator',
    parameters: {
      operation: 'add',
      a: Math.floor(Math.random() * 100),
      b: Math.floor(Math.random() * 100)
    }
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token'
    },
  };

  const res = http.post('http://localhost:5000/api/tools/invoke', payload, params);
  
  check(res, {
    'status ni 200': (r) => r.status === 200,
    'muda wa jibu < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

## Test Automation for MCP Servers

Automating your tests ensures consistent quality and faster feedback loops.

### CI/CD Integration

1. **Run Unit Tests on Pull Requests**: Ensure code changes don't break existing functionality
2. **Integration Tests in Staging**: Run integration tests in pre-production environments
3. **Performance Baselines**: Maintain performance benchmarks to catch regressions
4. **Security Scans**: Automate security testing as part of the pipeline

### Example CI Pipeline (GitHub Actions)

```yaml
name: MCP Server Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Weka Runtime
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: '8.0.x'
    
    - name: Rudisha utegemezi
      run: dotnet restore
    
    - name: Jenga
      run: dotnet build --no-restore
    
    - name: Mitihani ya Unit
      run: dotnet test --no-build --filter Category=Unit
    
    - name: Mitihani ya Muunganisho
      run: dotnet test --no-build --filter Category=Integration
      
    - name: Mitihani ya Utendaji
      run: dotnet run --project tests/PerformanceTests/PerformanceTests.csproj
```

## Testing for Compliance with MCP Specification

Verify your server correctly implements the MCP specification.

### Key Compliance Areas

1. **API Endpoints**: Test required endpoints (/resources, /tools, etc.)
2. **Request/Response Format**: Validate schema compliance
3. **Error Codes**: Verify correct status codes for various scenarios
4. **Content Types**: Test handling of different content types
5. **Authentication Flow**: Verify spec-compliant auth mechanisms

### Compliance Test Suite

```csharp
[Fact]
public async Task Server_ResourceEndpoint_ReturnsCorrectSchema()
{
    // Andaa
    var client = new HttpClient();
    client.DefaultRequestHeaders.Add("Authorization", "Bearer test-token");
    
    // Fanya
    var response = await client.GetAsync("http://localhost:5000/api/resources");
    var content = await response.Content.ReadAsStringAsync();
    var resources = JsonSerializer.Deserialize

// Assert
Assert.Equal(HttpStatusCode.OK, response.StatusCode);
Assert.NotNull(resources);
Assert.All(resources.Resources, resource => 
{
    Assert.NotNull(resource.Id);
    Assert.NotNull(resource.Type);
    // Uthibitishaji wa ziada wa muundo
});
}

## Vidokezo 10 Bora kwa Upimaji Bora wa MCP Server

1. **Jaribu Maelezo ya Zana Kwenye Sehemu Zake**: Hakiki maelezo ya muundo kwa kujitegemea kutoka kwa mantiki ya zana
2. **Tumia Vipimo Vilivyopangwa**: Jaribu zana kwa aina mbalimbali za ingizo, ikiwa ni pamoja na kesi za kipekee
3. **Angalia Majibu ya Makosa**: Hakiki usimamizi sahihi wa makosa kwa hali zote zinazowezekana za makosa
4. **Jaribu Mantiki ya Idhini**: Hakikisha udhibiti sahihi wa upatikanaji kwa majukumu tofauti ya watumiaji
5. **Fuatilia Ufungaji wa Vipimo**: Lenga kufikia kufunikwa kwa kiwango kikubwa cha msimbo wa njia muhimu
6. **Jaribu Majibu ya Mtiririko**: Hakiki usimamizi sahihi wa maudhui yanayotiririka
7. **Fanikisha Matatizo ya Mtandao**: Jaribu tabia chini ya hali mbaya za mtandao
8. **Jaribu Mipaka ya Rasilimali**: Hakiki tabia wakati wa kufikia vizingiti au mipaka ya kiwango
9. **Fanya Vipimo vya Kurudiwa Kiotomatiki**: Tengeneza mkusanyiko unaoendesha kila mabadiliko ya msimbo
10. **Andika Kesi za Vipimo**: Dumisha nyaraka wazi za hali za vipimo

## Makosa Yanayojirudia Mara kwa Mara Katika Upimaji

- **Kutegemea sana vipimo vya njia rahisi**: Hakikisha kupima kesi za makosa kwa kina
- **Kupuuzia upimaji wa utendaji**: Tambua vikwazo kabla havijaathiri uzalishaji
- **Kupima peke yake bila muktadha**: Changanya vipimo vya kitengo, muingiliano, na mwisho-mwisho
- **Kufunika API kwa sehemu tu**: Hakikisha sehemu zote na vipengele vimejaribiwa
- **Mazingira ya vipimo yasiyo thabiti**: Tumia kontena ili kuhakikisha mazingira ya vipimo ni thabiti

## Hitimisho

Mikakati kamili ya upimaji ni muhimu kwa kuendeleza seva za MCP zenye kuaminika na ubora wa juu. Kwa kutekeleza mbinu bora na vidokezo vilivyoelezwa katika mwongozo huu, unaweza kuhakikisha utekelezaji wako wa MCP unakidhi viwango vya juu vya ubora, kuaminika, na utendaji.

## Muhimu Kumbuka

1. **Ubunifu wa Zana**: Fuata kanuni ya jukumu moja, tumia sindano ya utegemezi, na ubuni kwa ajili ya muundo unaoweza kuunganishwa
2. **Ubunifu wa Muundo**: Tengeneza miundo wazi, yenye nyaraka nzuri na vizingiti sahihi vya uthibitishaji
3. **Usimamizi wa Makosa**: Tekeleza usimamizi wa makosa kwa heshima, majibu ya makosa yaliyopangwa, na mantiki ya jaribio tena
4. **Utendaji**: Tumia kuhifadhi muda, usindikaji usio sambamba, na udhibiti wa rasilimali
5. **Usalama**: Tekeleza uthibitishaji wa kina wa ingizo, ukaguzi wa idhini, na usimamizi wa data nyeti
6. **Upimaji**: Tengeneza vipimo kamili vya kitengo, muingiliano, na mwisho-mwisho
7. **Mifumo ya Kazi**: Tekeleza mifumo iliyothibitishwa kama minyororo, wasambazaji, na usindikaji sambamba

## Zoef

Buni zana ya MCP na mtiririko wa kazi kwa mfumo wa usindikaji wa hati unaofanya:

1. Kupokea hati katika miundo mbalimbali (PDF, DOCX, TXT)
2. Kuchambua maandishi na taarifa muhimu kutoka kwa hati
3. Kuweka hati kwa aina na maudhui
4. Kutengeneza muhtasari wa kila hati

Tekeleza miundo ya zana, usimamizi wa makosa, na mfumo wa kazi unaofaa zaidi kwa hali hii. Fikiria jinsi unavyoweza kupima utekelezaji huu.

## Rasilimali

1. Jiunge na jamii ya MCP kwenye [Azure AI Foundry Discord Community](https://aka.ms/foundrydevs) ili kupata taarifa za maendeleo ya hivi karibuni
2. Changia kwenye miradi ya chanzo huria ya [MCP projects](https://github.com/modelcontextprotocol)
3. Tumia kanuni za MCP katika miradi ya AI ya shirika lako
4. Chunguza utekelezaji maalum wa MCP kwa sekta yako
5. Fikiria kuchukua kozi za juu juu ya mada maalum za MCP, kama vile muingiliano wa njia nyingi au muingiliano wa programu za biashara
6. Jaribu kujenga zana na mitiririko yako ya MCP kwa kutumia kanuni ulizojifunza kupitia [Hands on Lab](../10-StreamliningAIWorkflowsBuildingAnMCPServerWithAIToolkit/README.md)

Ifuatayo: Mbinu Bora [masomo ya kesi](../09-CaseStudy/README.md)

**Kiarifu cha Msamaha**:  
Hati hii imetafsiriwa kwa kutumia huduma ya tafsiri ya AI [Co-op Translator](https://github.com/Azure/co-op-translator). Ingawa tunajitahidi kuhakikisha usahihi, tafadhali fahamu kwamba tafsiri za kiotomatiki zinaweza kuwa na makosa au upungufu wa usahihi. Hati ya asili katika lugha yake ya asili inapaswa kuchukuliwa kama chanzo cha mamlaka. Kwa taarifa muhimu, tafsiri ya kitaalamu inayofanywa na binadamu inapendekezwa. Hatubebei dhamana kwa kutoelewana au tafsiri potofu zinazotokana na matumizi ya tafsiri hii.