<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "6e562d7e5a77c8982da4aa8f762ad1d8",
  "translation_date": "2025-07-02T09:24:04+00:00",
  "source_file": "05-AdvancedTopics/mcp-security-entra/README.md",
  "language_code": "pl"
}
-->
# Zabezpieczanie przep≈Çyw√≥w pracy AI: Uwierzytelnianie Entra ID dla serwer√≥w Model Context Protocol

## Wprowadzenie
Zabezpieczenie serwera Model Context Protocol (MCP) jest r√≥wnie wa≈ºne, jak zamkniƒôcie drzwi wej≈õciowych do domu. Pozostawienie serwera MCP otwartym nara≈ºa Twoje narzƒôdzia i dane na nieautoryzowany dostƒôp, co mo≈ºe prowadziƒá do narusze≈Ñ bezpiecze≈Ñstwa. Microsoft Entra ID oferuje solidne, oparte na chmurze rozwiƒÖzanie do zarzƒÖdzania to≈ºsamo≈õciƒÖ i dostƒôpem, kt√≥re pomaga zapewniƒá, ≈ºe tylko uprawnieni u≈ºytkownicy i aplikacje mogƒÖ komunikowaƒá siƒô z Twoim serwerem MCP. W tej sekcji dowiesz siƒô, jak chroniƒá swoje przep≈Çywy pracy AI za pomocƒÖ uwierzytelniania Entra ID.

## Cele nauki
Po zako≈Ñczeniu tej sekcji bƒôdziesz potrafi≈Ç:

- Zrozumieƒá znaczenie zabezpieczania serwer√≥w MCP.
- Wyja≈õniƒá podstawy Microsoft Entra ID i uwierzytelniania OAuth 2.0.
- Rozr√≥≈ºniƒá klient√≥w publicznych i poufnych.
- Wdro≈ºyƒá uwierzytelnianie Entra ID zar√≥wno w scenariuszach lokalnych (klient publiczny), jak i zdalnych (klient poufny) serwer√≥w MCP.
- Stosowaƒá najlepsze praktyki bezpiecze≈Ñstwa podczas tworzenia przep≈Çyw√≥w pracy AI.

## Bezpiecze≈Ñstwo i MCP

Tak jak nie zostawiasz otwartych drzwi do domu, tak nie powiniene≈õ pozostawiaƒá serwera MCP otwartym dla ka≈ºdego. Zabezpieczenie przep≈Çyw√≥w pracy AI jest kluczowe dla tworzenia solidnych, godnych zaufania i bezpiecznych aplikacji. Ten rozdzia≈Ç wprowadzi Ciƒô w korzystanie z Microsoft Entra ID do zabezpieczania serwer√≥w MCP, zapewniajƒÖc, ≈ºe tylko uprawnieni u≈ºytkownicy i aplikacje mogƒÖ korzystaƒá z Twoich narzƒôdzi i danych.

## Dlaczego bezpiecze≈Ñstwo jest wa≈ºne dla serwer√≥w MCP

Wyobra≈∫ sobie, ≈ºe Tw√≥j serwer MCP ma narzƒôdzie, kt√≥re mo≈ºe wysy≈Çaƒá e-maile lub uzyskiwaƒá dostƒôp do bazy danych klient√≥w. Niezabezpieczony serwer oznacza, ≈ºe ka≈ºdy mo≈ºe potencjalnie u≈ºywaƒá tego narzƒôdzia, co prowadzi do nieautoryzowanego dostƒôpu do danych, spamu lub innych z≈Ço≈õliwych dzia≈Ça≈Ñ.

Wdro≈ºenie uwierzytelniania zapewnia, ≈ºe ka≈ºde ≈ºƒÖdanie do serwera jest weryfikowane, potwierdzajƒÖc to≈ºsamo≈õƒá u≈ºytkownika lub aplikacji wysy≈ÇajƒÖcej ≈ºƒÖdanie. To pierwszy i najwa≈ºniejszy krok w zabezpieczaniu przep≈Çyw√≥w pracy AI.

## Wprowadzenie do Microsoft Entra ID

[**Microsoft Entra ID**](https://adoption.microsoft.com/microsoft-security/entra/) to us≈Çuga zarzƒÖdzania to≈ºsamo≈õciƒÖ i dostƒôpem oparta na chmurze. Mo≈ºna jƒÖ por√≥wnaƒá do uniwersalnego ochroniarza dla Twoich aplikacji. Zajmuje siƒô skomplikowanym procesem weryfikacji to≈ºsamo≈õci u≈ºytkownik√≥w (uwierzytelnianie) oraz okre≈õlania, co im wolno robiƒá (autoryzacja).

KorzystajƒÖc z Entra ID, mo≈ºesz:

- Umo≈ºliwiƒá bezpieczne logowanie u≈ºytkownik√≥w.
- Chroniƒá API i us≈Çugi.
- ZarzƒÖdzaƒá politykami dostƒôpu z jednego miejsca.

Dla serwer√≥w MCP Entra ID oferuje solidne i powszechnie zaufane rozwiƒÖzanie do zarzƒÖdzania tym, kto mo≈ºe korzystaƒá z funkcji Twojego serwera.

---

## Zrozumienie mechanizmu: Jak dzia≈Ça uwierzytelnianie Entra ID

Entra ID korzysta z otwartych standard√≥w, takich jak **OAuth 2.0**, do obs≈Çugi uwierzytelniania. Choƒá szczeg√≥≈Çy mogƒÖ byƒá skomplikowane, podstawowƒÖ ideƒô mo≈ºna wyja≈õniƒá za pomocƒÖ analogii.

### ≈Åagodne wprowadzenie do OAuth 2.0: Klucz do samochodu na parkingu

Pomy≈õl o OAuth 2.0 jak o us≈Çudze valet parkingu dla Twojego samochodu. Kiedy przyje≈ºd≈ºasz do restauracji, nie dajesz valetowi swojego g≈Ç√≥wnego klucza. Zamiast tego przekazujesz **klucz valet**, kt√≥ry ma ograniczone uprawnienia ‚Äî mo≈ºe uruchomiƒá samoch√≥d i zamknƒÖƒá drzwi, ale nie mo≈ºe otworzyƒá baga≈ºnika ani schowka.

W tej analogii:

- **Ty** jeste≈õ **U≈ºytkownikiem**.
- **Tw√≥j samoch√≥d** to **serwer MCP** z jego cennymi narzƒôdziami i danymi.
- **Valet** to **Microsoft Entra ID**.
- **Parkingowy** to **klient MCP** (aplikacja pr√≥bujƒÖca uzyskaƒá dostƒôp do serwera).
- **Klucz valet** to **Access Token**.

Access token to bezpieczny ciƒÖg znak√≥w, kt√≥ry klient MCP otrzymuje od Entra ID po zalogowaniu siƒô u≈ºytkownika. Klient przekazuje ten token serwerowi MCP przy ka≈ºdym ≈ºƒÖdaniu. Serwer mo≈ºe zweryfikowaƒá token, aby upewniƒá siƒô, ≈ºe ≈ºƒÖdanie jest prawid≈Çowe, a klient ma odpowiednie uprawnienia, bez konieczno≈õci operowania Twoimi rzeczywistymi danymi uwierzytelniajƒÖcymi (np. has≈Çem).

### Przebieg uwierzytelniania

Oto jak ten proces dzia≈Ça w praktyce:

```mermaid
sequenceDiagram
    actor User as üë§ User
    participant Client as üñ•Ô∏è MCP Client
    participant Entra as üîê Microsoft Entra ID
    participant Server as üîß MCP Server

    Client->>+User: Please sign in to continue.
    User->>+Entra: Enters credentials (username/password).
    Entra-->>Client: Here is your access token.
    User-->>-Client: (Returns to the application)

    Client->>+Server: I need to use a tool. Here is my access token.
    Server->>+Entra: Is this access token valid?
    Entra-->>-Server: Yes, it is.
    Server-->>-Client: Token is valid. Here is the result of the tool.
```

### Wprowadzenie do Microsoft Authentication Library (MSAL)

Zanim przejdziemy do kodu, warto przedstawiƒá kluczowy komponent, kt√≥ry zobaczysz w przyk≈Çadach: **Microsoft Authentication Library (MSAL)**.

MSAL to biblioteka stworzona przez Microsoft, kt√≥ra znacznie u≈Çatwia programistom obs≈Çugƒô uwierzytelniania. Zamiast pisaƒá ca≈Çy skomplikowany kod do obs≈Çugi token√≥w bezpiecze≈Ñstwa, zarzƒÖdzania logowaniami i od≈õwie≈ºania sesji, MSAL wykonuje te zadania za Ciebie.

Korzystanie z biblioteki takiej jak MSAL jest bardzo polecane, poniewa≈º:

- **Jest bezpieczna:** Implementuje protoko≈Çy bran≈ºowe i najlepsze praktyki bezpiecze≈Ñstwa, zmniejszajƒÖc ryzyko luk w Twoim kodzie.
- **Uproszcza rozw√≥j:** Ukrywa z≈Ço≈ºono≈õƒá protoko≈Ç√≥w OAuth 2.0 i OpenID Connect, pozwalajƒÖc na dodanie solidnego uwierzytelniania do aplikacji za pomocƒÖ kilku linijek kodu.
- **Jest utrzymywana:** Microsoft aktywnie rozwija i aktualizuje MSAL, aby przeciwdzia≈Çaƒá nowym zagro≈ºeniom i zmianom platform.

MSAL obs≈Çuguje wiele jƒôzyk√≥w i framework√≥w aplikacji, w tym .NET, JavaScript/TypeScript, Python, Java, Go oraz platformy mobilne jak iOS i Android. Dziƒôki temu mo≈ºesz stosowaƒá sp√≥jne wzorce uwierzytelniania w ca≈Çym swoim stosie technologicznym.

Wiƒôcej informacji o MSAL znajdziesz w oficjalnej [dokumentacji przeglƒÖdowej MSAL](https://learn.microsoft.com/entra/identity-platform/msal-overview).

---

## Zabezpieczanie serwera MCP za pomocƒÖ Entra ID: przewodnik krok po kroku

Przejd≈∫my teraz przez proces zabezpieczania lokalnego serwera MCP (komunikujƒÖcego siƒô przez `stdio`) using Entra ID. This example uses a **public client**, which is suitable for applications running on a user's machine, like a desktop app or a local development server.

### Scenario 1: Securing a Local MCP Server (with a Public Client)

In this scenario, we'll look at an MCP server that runs locally, communicates over `stdio`, and uses Entra ID to authenticate the user before allowing access to its tools. The server will have a single tool that fetches the user's profile information from the Microsoft Graph API.

#### 1. Setting Up the Application in Entra ID

Before writing any code, you need to register your application in Microsoft Entra ID. This tells Entra ID about your application and grants it permission to use the authentication service.

1. Navigate to the **[Microsoft Entra portal](https://entra.microsoft.com/)**.
2. Go to **App registrations** and click **New registration**.
3. Give your application a name (e.g., "My Local MCP Server").
4. For **Supported account types**, select **Accounts in this organizational directory only**.
5. You can leave the **Redirect URI** blank for this example.
6. Click **Register**.

Once registered, take note of the **Application (client) ID** and **Directory (tenant) ID**. You'll need these in your code.

#### 2. The Code: A Breakdown

Let's look at the key parts of the code that handle authentication. The full code for this example is available in the [Entra ID - Local - WAM](https://github.com/Azure-Samples/mcp-auth-servers/tree/main/src/entra-id-local-wam) folder of the [mcp-auth-servers GitHub repository](https://github.com/Azure-Samples/mcp-auth-servers).

**`AuthenticationService.cs`**

This class is responsible for handling the interaction with Entra ID.

- **`CreateAsync`**: This method initializes the `PublicClientApplication` from the MSAL (Microsoft Authentication Library). It's configured with your application's `clientId` and `tenantId`.
- **`WithBroker`**: This enables the use of a broker (like the Windows Web Account Manager), which provides a more secure and seamless single sign-on experience.
- **`AcquireTokenAsync`**: To podstawowa metoda. Najpierw pr√≥buje uzyskaƒá token w trybie cichym (co oznacza, ≈ºe u≈ºytkownik nie musi siƒô ponownie logowaƒá, je≈õli ma wa≈ºnƒÖ sesjƒô). Je≈õli token nie mo≈ºe zostaƒá uzyskany w ten spos√≥b, wy≈õwietli interaktywne okno logowania.

```csharp
// Simplified for clarity
public static async Task<AuthenticationService> CreateAsync(ILogger<AuthenticationService> logger)
{
    var msalClient = PublicClientApplicationBuilder
        .Create(_clientId) // Your Application (client) ID
        .WithAuthority(AadAuthorityAudience.AzureAdMyOrg)
        .WithTenantId(_tenantId) // Your Directory (tenant) ID
        .WithBroker(new BrokerOptions(BrokerOptions.OperatingSystems.Windows))
        .Build();

    // ... cache registration ...

    return new AuthenticationService(logger, msalClient);
}

public async Task<string> AcquireTokenAsync()
{
    try
    {
        // Try silent authentication first
        var accounts = await _msalClient.GetAccountsAsync();
        var account = accounts.FirstOrDefault();

        AuthenticationResult? result = null;

        if (account != null)
        {
            result = await _msalClient.AcquireTokenSilent(_scopes, account).ExecuteAsync();
        }
        else
        {
            // If no account, or silent fails, go interactive
            result = await _msalClient.AcquireTokenInteractive(_scopes).ExecuteAsync();
        }

        return result.AccessToken;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "An error occurred while acquiring the token.");
        throw; // Optionally rethrow the exception for higher-level handling
    }
}
```

**`Program.cs`**

This is where the MCP server is set up and the authentication service is integrated.

- **`AddSingleton<AuthenticationService>`**: This registers the `AuthenticationService` with the dependency injection container, so it can be used by other parts of the application (like our tool).
- **`GetUserDetailsFromGraph` tool**: This tool requires an instance of `AuthenticationService`. Before it does anything, it calls `authService.AcquireTokenAsync()` pobiera wa≈ºny token dostƒôpu. Je≈õli uwierzytelnianie powiedzie siƒô, token jest u≈ºywany do wywo≈Çania Microsoft Graph API i pobrania danych u≈ºytkownika.

```csharp
// Simplified for clarity
[McpServerTool(Name = "GetUserDetailsFromGraph")]
public static async Task<string> GetUserDetailsFromGraph(
    AuthenticationService authService)
{
    try
    {
        // This will trigger the authentication flow
        var accessToken = await authService.AcquireTokenAsync();

        // Use the token to create a GraphServiceClient
        var graphClient = new GraphServiceClient(
            new BaseBearerTokenAuthenticationProvider(new TokenProvider(authService)));

        var user = await graphClient.Me.GetAsync();

        return System.Text.Json.JsonSerializer.Serialize(user);
    }
    catch (Exception ex)
    {
        return $"Error: {ex.Message}";
    }
}
```

#### 3. Jak to wszystko dzia≈Ça razem

1. Kiedy klient MCP pr√≥buje u≈ºyƒá `GetUserDetailsFromGraph` tool, the tool first calls `AcquireTokenAsync`.
2. `AcquireTokenAsync` triggers the MSAL library to check for a valid token.
3. If no token is found, MSAL, through the broker, will prompt the user to sign in with their Entra ID account.
4. Once the user signs in, Entra ID issues an access token.
5. The tool receives the token and uses it to make a secure call to the Microsoft Graph API.
6. The user's details are returned to the MCP client.

This process ensures that only authenticated users can use the tool, effectively securing your local MCP server.

### Scenario 2: Securing a Remote MCP Server (with a Confidential Client)

When your MCP server is running on a remote machine (like a cloud server) and communicates over a protocol like HTTP Streaming, the security requirements are different. In this case, you should use a **confidential client** and the **Authorization Code Flow**. This is a more secure method because the application's secrets are never exposed to the browser.

This example uses a TypeScript-based MCP server that uses Express.js to handle HTTP requests.

#### 1. Setting Up the Application in Entra ID

The setup in Entra ID is similar to the public client, but with one key difference: you need to create a **client secret**.

1. Navigate to the **[Microsoft Entra portal](https://entra.microsoft.com/)**.
2. In your app registration, go to the **Certificates & secrets** tab.
3. Click **New client secret**, give it a description, and click **Add**.
4. **Important:** Copy the secret value immediately. You will not be able to see it again.
5. You also need to configure a **Redirect URI**. Go to the **Authentication** tab, click **Add a platform**, select **Web**, and enter the redirect URI for your application (e.g., `http://localhost:3001/auth/callback`).

> **‚ö†Ô∏è Important Security Note:** For production applications, Microsoft strongly recommends using **secretless authentication** methods such as **Managed Identity** or **Workload Identity Federation** instead of client secrets. Client secrets pose security risks as they can be exposed or compromised. Managed identities provide a more secure approach by eliminating the need to store credentials in your code or configuration.
>
> For more information about managed identities and how to implement them, see the [Managed identities for Azure resources overview](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview).

#### 2. The Code: A Breakdown

This example uses a session-based approach. When the user authenticates, the server stores the access token and refresh token in a session and gives the user a session token. This session token is then used for subsequent requests. The full code for this example is available in the [Entra ID - Confidential client](https://github.com/Azure-Samples/mcp-auth-servers/tree/main/src/entra-id-cca-session) folder of the [mcp-auth-servers GitHub repository](https://github.com/Azure-Samples/mcp-auth-servers).

**`Server.ts`**

This file sets up the Express server and the MCP transport layer.

- **`requireBearerAuth`**: This is middleware that protects the `/sse` and `/message` endpoints. It checks for a valid bearer token in the `Authorization` header of the request.
- **`EntraIdServerAuthProvider`**: This is a custom class that implements the `McpServerAuthorizationProvider` interface. It's responsible for handling the OAuth 2.0 flow.
- **`/auth/callback`**: Ten endpoint obs≈Çuguje przekierowanie z Entra ID po uwierzytelnieniu u≈ºytkownika. Wymienia kod autoryzacyjny na token dostƒôpu i token od≈õwie≈ºajƒÖcy.

```typescript
// Simplified for clarity
const app = express();
const { server } = createServer();
const provider = new EntraIdServerAuthProvider();

// Protect the SSE endpoint
app.get("/sse", requireBearerAuth({
  provider,
  requiredScopes: ["User.Read"]
}), async (req, res) => {
  // ... connect to the transport ...
});

// Protect the message endpoint
app.post("/message", requireBearerAuth({
  provider,
  requiredScopes: ["User.Read"]
}), async (req, res) => {
  // ... handle the message ...
});

// Handle the OAuth 2.0 callback
app.get("/auth/callback", (req, res) => {
  provider.handleCallback(req.query.code, req.query.state)
    .then(result => {
      // ... handle success or failure ...
    });
});
```

**`Tools.ts`**

This file defines the tools that the MCP server provides. The `getUserDetails` narzƒôdzie jest podobne do poprzedniego przyk≈Çadu, ale pobiera token dostƒôpu z sesji.

```typescript
// Simplified for clarity
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name } = request.params;
  const context = request.params?.context as { token?: string } | undefined;
  const sessionToken = context?.token;

  if (name === ToolName.GET_USER_DETAILS) {
    if (!sessionToken) {
      throw new AuthenticationError("Authentication token is missing or invalid. Ensure the token is provided in the request context.");
    }

    // Get the Entra ID token from the session store
    const tokenData = tokenStore.getToken(sessionToken);
    const entraIdToken = tokenData.accessToken;

    const graphClient = Client.init({
      authProvider: (done) => {
        done(null, entraIdToken);
      }
    });

    const user = await graphClient.api('/me').get();

    // ... return user details ...
  }
});
```

**`auth/EntraIdServerAuthProvider.ts`**

This class handles the logic for:

- Redirecting the user to the Entra ID sign-in page.
- Exchanging the authorization code for an access token.
- Storing the tokens in the `tokenStore`.
- Refreshing the access token when it expires.

#### 3. How It All Works Together

1. When a user first tries to connect to the MCP server, the `requireBearerAuth` middleware will see that they don't have a valid session and will redirect them to the Entra ID sign-in page.
2. The user signs in with their Entra ID account.
3. Entra ID redirects the user back to the `/auth/callback` endpoint with an authorization code.
4. The server exchanges the code for an access token and a refresh token, stores them, and creates a session token which is sent to the client.
5. The client can now use this session token in the `Authorization` header for all future requests to the MCP server.
6. When the `getUserDetails` narzƒôdzie, gdy jest wywo≈Çywane, u≈ºywa tokena sesji do znalezienia tokena dostƒôpu Entra ID, a nastƒôpnie korzysta z niego do wywo≈Çania Microsoft Graph API.

Ten przep≈Çyw jest bardziej z≈Ço≈ºony ni≈º w przypadku klienta publicznego, ale jest wymagany dla punkt√≥w ko≈Ñcowych dostƒôpnych w internecie. Poniewa≈º zdalne serwery MCP sƒÖ dostƒôpne publicznie, potrzebujƒÖ silniejszych zabezpiecze≈Ñ, aby chroniƒá siƒô przed nieautoryzowanym dostƒôpem i potencjalnymi atakami.

## Najlepsze praktyki bezpiecze≈Ñstwa

- **Zawsze u≈ºywaj HTTPS**: Szyfruj komunikacjƒô miƒôdzy klientem a serwerem, aby chroniƒá tokeny przed przechwyceniem.
- **Wdra≈ºaj kontrolƒô dostƒôpu opartƒÖ na rolach (RBAC)**: Nie sprawdzaj tylko *czy* u≈ºytkownik jest uwierzytelniony, ale *co* jest uprawniony robiƒá. Mo≈ºesz definiowaƒá role w Entra ID i sprawdzaƒá je na serwerze MCP.
- **Monitoruj i audytuj**: Rejestruj wszystkie zdarzenia uwierzytelniania, aby wykrywaƒá i reagowaƒá na podejrzane dzia≈Çania.
- **Obs≈Çuguj ograniczenia szybko≈õci i throttling**: Microsoft Graph i inne API stosujƒÖ ograniczenia liczby ≈ºƒÖda≈Ñ, aby zapobiegaƒá nadu≈ºyciom. Wprowad≈∫ mechanizmy wyk≈Çadniczego op√≥≈∫niania i ponawiania pr√≥b w serwerze MCP, aby ≈Çagodnie obs≈Çugiwaƒá odpowiedzi HTTP 429 (Too Many Requests). Rozwa≈º tak≈ºe buforowanie czƒôsto pobieranych danych, aby zmniejszyƒá liczbƒô wywo≈Ça≈Ñ API.
- **Bezpieczne przechowywanie token√≥w**: Przechowuj access tokeny i refresh tokeny w bezpieczny spos√≥b. Dla aplikacji lokalnych korzystaj z mechanizm√≥w bezpiecznego przechowywania systemu. Dla aplikacji serwerowych rozwa≈º u≈ºycie zaszyfrowanego magazynu lub us≈Çug zarzƒÖdzania kluczami, takich jak Azure Key Vault.
- **Obs≈Çuga wyga≈õniƒôcia token√≥w**: Tokeny dostƒôpu majƒÖ ograniczony czas wa≈ºno≈õci. Wdro≈º automatyczne od≈õwie≈ºanie token√≥w za pomocƒÖ refresh token√≥w, aby zapewniƒá p≈Çynne do≈õwiadczenie u≈ºytkownika bez konieczno≈õci ponownego logowania.
- **Rozwa≈º u≈ºycie Azure API Management**: Choƒá implementacja zabezpiecze≈Ñ bezpo≈õrednio w serwerze MCP daje precyzyjnƒÖ kontrolƒô, bramy API takie jak Azure API Management mogƒÖ automatycznie obs≈Çugiwaƒá wiele aspekt√≥w bezpiecze≈Ñstwa, w tym uwierzytelnianie, autoryzacjƒô, ograniczenia szybko≈õci i monitorowanie. ZapewniajƒÖ one scentralizowanƒÖ warstwƒô zabezpiecze≈Ñ miƒôdzy klientami a serwerami MCP. Wiƒôcej informacji o u≈ºywaniu bram API z MCP znajdziesz w naszym artykule [Azure API Management Your Auth Gateway For MCP Servers](https://techcommunity.microsoft.com/blog/integrationsonazureblog/azure-api-management-your-auth-gateway-for-mcp-servers/4402690).

## Kluczowe wnioski

- Zabezpieczenie serwera MCP jest kluczowe dla ochrony Twoich danych i narzƒôdzi.
- Microsoft Entra ID oferuje solidne i skalowalne rozwiƒÖzanie do uwierzytelniania i autoryzacji.
- U≈ºywaj **klienta publicznego** dla aplikacji lokalnych i **klienta poufnego** dla serwer√≥w zdalnych.
- **Authorization Code Flow** to najbezpieczniejsza opcja dla aplikacji webowych.

## ƒÜwiczenie

1. Pomy≈õl o serwerze MCP, kt√≥ry m√≥g≈Çby≈õ stworzyƒá. Czy by≈Çby to serwer lokalny czy zdalny?
2. Na podstawie odpowiedzi, czy u≈ºy≈Çby≈õ klienta publicznego czy poufnego?
3. Jakie uprawnienia Tw√≥j serwer MCP powinien uzyskaƒá, aby wykonywaƒá operacje na Microsoft Graph?

## ƒÜwiczenia praktyczne

### ƒÜwiczenie 1: Zarejestruj aplikacjƒô w Entra ID
Przejd≈∫ do portalu Microsoft Entra.  
Zarejestruj nowƒÖ aplikacjƒô dla swojego serwera MCP.  
Zapisz identyfikator aplikacji (client ID) oraz identyfikator katalogu (tenant ID).

### ƒÜwiczenie 2: Zabezpiecz lokalny serwer MCP (klient publiczny)
- Postƒôpuj zgodnie z przyk≈Çadem kodu, aby zintegrowaƒá MSAL (Microsoft Authentication Library) do uwierzytelniania u≈ºytkownik√≥w.
- Przetestuj przep≈Çyw uwierzytelniania, wywo≈ÇujƒÖc narzƒôdzie MCP, kt√≥re pobiera dane u≈ºytkownika z Microsoft Graph.

### ƒÜwiczenie 3: Zabezpiecz zdalny serwer MCP (klient poufny)
- Zarejestruj klienta poufnego w Entra ID i utw√≥rz sekret klienta.
- Skonfiguruj sw√≥j serwer Express.js MCP do korzystania z Authorization Code Flow.
- Przetestuj chronione endpointy i potwierd≈∫ dostƒôp oparty na tokenach.

### ƒÜwiczenie 4: Zastosuj najlepsze praktyki bezpiecze≈Ñstwa
- W≈ÇƒÖcz HTTPS dla swojego serwera lokalnego lub zdalnego.
- Wdr√≥≈º kontrolƒô dostƒôpu opartƒÖ na rolach (RBAC) w logice serwera.
- Dodaj obs≈Çugƒô wyga≈õniƒôcia token√≥w oraz bezpieczne przechowywanie token√≥w.

## Zasoby

1. **Dokumentacja przeglƒÖdowa MSAL**  
   Dowiedz siƒô, jak Microsoft Authentication Library (MSAL) umo≈ºliwia bezpieczne pozyskiwanie token√≥w na r√≥≈ºnych platformach:  
   [MSAL Overview on Microsoft Learn](https://learn.microsoft.com/en-gb/entra/msal/overview)

2. **Repozytorium Azure-Samples/mcp-auth-servers na GitHub**  
   Przyk≈Çadowe implementacje serwer√≥w MCP demonstrujƒÖce przep≈Çywy uwierzytelniania:  
   [Azure-Samples/mcp-auth-servers on GitHub](https://github.com/Azure-Samples/mcp-auth-servers)

3. **PrzeglƒÖd Managed Identities dla zasob√≥w Azure**  
   Dowiedz siƒô, jak wyeliminowaƒá sekrety, korzystajƒÖc z zarzƒÖdzanych to≈ºsamo≈õci przypisanych do systemu lub u≈ºytkownika:  
   [Managed Identities Overview on Microsoft Learn](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/)

4. **Azure API Management: Your Auth Gateway for MCP Servers**  
   Szczeg√≥≈Çowy opis u≈ºywania APIM jako bezpiecznej bramy OAuth2 dla serwer√≥w MCP:  
   [Azure API Management Your Auth Gateway For MCP Servers](https://techcommunity.microsoft.com/blog/integrationsonazureblog/azure-api-management-your-auth-gateway-for-mcp-servers/4402690)

5. **Microsoft Graph Permissions Reference**  
   Kompleksowa lista uprawnie≈Ñ delegowanych i aplikacyjnych dla Microsoft Graph:  
   [Microsoft Graph Permissions Reference](https://learn.microsoft.com/zh-tw/graph/permissions-reference)

## Efekty nauki
Po uko≈Ñczeniu tej sekcji bƒôdziesz potrafi≈Ç:

- Wyja≈õniƒá, dlaczego uwierzytelnianie jest kluczowe dla serwer√≥w MCP i przep≈Çyw√≥w pracy AI.
- Skonfigurowaƒá uwierzytelnianie Entra ID dla lokalnych i zdalnych serwer√≥w MCP.
- Wybraƒá odpowiedni typ klienta (publiczny lub poufny) w zale≈ºno≈õci od wdro≈ºenia serwera.
- Wdro≈ºyƒá bezpieczne praktyki programistyczne, w tym przechowywanie token√≥w i autoryzacjƒô opartƒÖ na rolach.
- Pewnie chroniƒá sw√≥j serwer MCP i jego narzƒôdzia przed nieautoryzowanym dostƒôpem.

## Co dalej

- [5.13 Integracja Model Context Protocol (MCP) z Azure AI Foundry](../mcp-foundry-agent-integration/README.md)

**Zastrze≈ºenie**:  
Niniejszy dokument zosta≈Ç przet≈Çumaczony za pomocƒÖ us≈Çugi t≈Çumacze≈Ñ AI [Co-op Translator](https://github.com/Azure/co-op-translator). Mimo ≈ºe dok≈Çadamy stara≈Ñ, aby t≈Çumaczenie by≈Ço jak najbardziej precyzyjne, prosimy mieƒá na uwadze, ≈ºe automatyczne t≈Çumaczenia mogƒÖ zawieraƒá b≈Çƒôdy lub niedok≈Çadno≈õci. Oryginalny dokument w jƒôzyku ≈∫r√≥d≈Çowym powinien byƒá uznawany za ≈∫r√≥d≈Ço autorytatywne. W przypadku informacji o kluczowym znaczeniu zalecane jest skorzystanie z profesjonalnego t≈Çumaczenia wykonanego przez cz≈Çowieka. Nie ponosimy odpowiedzialno≈õci za jakiekolwiek nieporozumienia lub b≈Çƒôdne interpretacje wynikajƒÖce z korzystania z tego t≈Çumaczenia.