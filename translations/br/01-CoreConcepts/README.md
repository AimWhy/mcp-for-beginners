<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "f00defb149ee1ac4a799e44a9783c7fc",
  "translation_date": "2025-06-06T18:19:17+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "br"
}
-->
# üìñ MCP Core Concepts: Ma√Ætriser le Model Context Protocol pour l'int√©gration de l'IA

Le Model Context Protocol (MCP) est un cadre puissant et standardis√© qui optimise la communication entre les grands mod√®les de langage (LLM) et les outils, applications et sources de donn√©es externes. Ce guide optimis√© pour le SEO vous accompagne √† travers les concepts cl√©s du MCP, pour que vous compreniez son architecture client-serveur, ses composants essentiels, ses m√©canismes de communication et ses bonnes pratiques d‚Äôimpl√©mentation.

## Vue d'ensemble

Cette le√ßon explore l‚Äôarchitecture fondamentale et les composants qui composent l‚Äô√©cosyst√®me du Model Context Protocol (MCP). Vous d√©couvrirez l‚Äôarchitecture client-serveur, les composants cl√©s et les m√©canismes de communication qui alimentent les interactions MCP.

## üë©‚Äçüéì Objectifs d‚Äôapprentissage principaux

√Ä la fin de cette le√ßon, vous serez capable de :

- Comprendre l‚Äôarchitecture client-serveur du MCP.
- Identifier les r√¥les et responsabilit√©s des Hosts, Clients et Servers.
- Analyser les fonctionnalit√©s cl√©s qui font du MCP une couche d‚Äôint√©gration flexible.
- Appr√©hender le flux d‚Äôinformations au sein de l‚Äô√©cosyst√®me MCP.
- Obtenir des insights pratiques gr√¢ce √† des exemples de code en .NET, Java, Python et JavaScript.

## üîé Architecture MCP : un regard approfondi

L‚Äô√©cosyst√®me MCP repose sur un mod√®le client-serveur. Cette structure modulaire permet aux applications IA d‚Äôinteragir efficacement avec des outils, bases de donn√©es, APIs et ressources contextuelles. D√©composons cette architecture en ses composants principaux.

### 1. Hosts

Dans le Model Context Protocol (MCP), les Hosts jouent un r√¥le crucial en tant qu‚Äôinterface principale par laquelle les utilisateurs interagissent avec le protocole. Les Hosts sont des applications ou environnements qui initient des connexions avec les serveurs MCP pour acc√©der aux donn√©es, outils et prompts. Par exemple, des environnements de d√©veloppement int√©gr√©s (IDE) comme Visual Studio Code, des outils IA comme Claude Desktop, ou des agents personnalis√©s con√ßus pour des t√¢ches sp√©cifiques.

**Les Hosts** sont des applications LLM qui initient les connexions. Ils :

- Ex√©cutent ou interagissent avec des mod√®les IA pour g√©n√©rer des r√©ponses.
- Initient des connexions avec les serveurs MCP.
- G√®rent le flux de conversation et l‚Äôinterface utilisateur.
- Contr√¥lent les permissions et les contraintes de s√©curit√©.
- G√®rent le consentement utilisateur pour le partage de donn√©es et l‚Äôex√©cution d‚Äôoutils.

### 2. Clients

Les Clients sont des composants essentiels qui facilitent l‚Äôinteraction entre les Hosts et les serveurs MCP. Ils agissent comme interm√©diaires, permettant aux Hosts d‚Äôacc√©der et d‚Äôutiliser les fonctionnalit√©s fournies par les serveurs MCP. Ils jouent un r√¥le cl√© pour assurer une communication fluide et un √©change de donn√©es efficace au sein de l‚Äôarchitecture MCP.

**Les Clients** sont des connecteurs int√©gr√©s √† l‚Äôapplication host. Ils :

- Envoient des requ√™tes aux serveurs avec prompts/instructions.
- N√©gocient les capacit√©s avec les serveurs.
- G√®rent les requ√™tes d‚Äôex√©cution d‚Äôoutils venant des mod√®les.
- Traitent et affichent les r√©ponses aux utilisateurs.

### 3. Servers

Les Servers sont responsables de la gestion des requ√™tes des clients MCP et fournissent des r√©ponses appropri√©es. Ils g√®rent diverses op√©rations telles que la r√©cup√©ration de donn√©es, l‚Äôex√©cution d‚Äôoutils et la g√©n√©ration de prompts. Les Servers garantissent une communication efficace et fiable entre clients et Hosts, en maintenant l‚Äôint√©grit√© du processus d‚Äôinteraction.

**Les Servers** sont des services qui fournissent contexte et fonctionnalit√©s. Ils :

- Enregistrent les fonctionnalit√©s disponibles (ressources, prompts, outils).
- Re√ßoivent et ex√©cutent les appels d‚Äôoutils depuis le client.
- Fournissent des informations contextuelles pour am√©liorer les r√©ponses du mod√®le.
- Renvoient les r√©sultats au client.
- Maintiennent l‚Äô√©tat des interactions si n√©cessaire.

Les Servers peuvent √™tre d√©velopp√©s par n‚Äôimporte qui pour √©tendre les capacit√©s des mod√®les avec des fonctionnalit√©s sp√©cialis√©es.

### 4. Fonctionnalit√©s des Servers

Les serveurs dans le Model Context Protocol (MCP) offrent des briques fondamentales qui permettent des interactions riches entre clients, hosts et mod√®les de langage. Ces fonctionnalit√©s visent √† am√©liorer les capacit√©s du MCP en proposant un contexte structur√©, des outils et des prompts.

Les serveurs MCP peuvent proposer l‚Äôune des fonctionnalit√©s suivantes :

#### üìë Ressources

Les ressources dans le Model Context Protocol (MCP) englobent diff√©rents types de contexte et donn√©es que les utilisateurs ou mod√®les IA peuvent exploiter. Cela inclut :

- **Donn√©es contextuelles** : Informations et contexte que les utilisateurs ou mod√®les IA peuvent utiliser pour la prise de d√©cision et l‚Äôex√©cution des t√¢ches.
- **Bases de connaissances et d√©p√¥ts documentaires** : Collections de donn√©es structur√©es ou non, comme des articles, manuels et publications scientifiques, fournissant des insights pr√©cieux.
- **Fichiers locaux et bases de donn√©es** : Donn√©es stock√©es localement sur des appareils ou dans des bases, accessibles pour traitement et analyse.
- **APIs et services web** : Interfaces externes et services offrant des donn√©es et fonctionnalit√©s suppl√©mentaires, permettant l‚Äôint√©gration avec diverses ressources et outils en ligne.

Un exemple de ressource peut √™tre un sch√©ma de base de donn√©es ou un fichier accessible comme suit :

```text
file://log.txt
database://schema
```

### ü§ñ Prompts

Les prompts dans le Model Context Protocol (MCP) comprennent divers mod√®les pr√©-d√©finis et sch√©mas d‚Äôinteraction con√ßus pour simplifier les flux de travail utilisateurs et am√©liorer la communication. Cela inclut :

- **Messages et workflows templatis√©s** : Messages et processus pr√©-structur√©s qui guident les utilisateurs √† travers des t√¢ches sp√©cifiques.
- **Sch√©mas d‚Äôinteraction pr√©-d√©finis** : S√©quences standardis√©es d‚Äôactions et r√©ponses pour faciliter une communication coh√©rente et efficace.
- **Mod√®les de conversation sp√©cialis√©s** : Templates personnalisables adapt√©s √† des types sp√©cifiques de conversations, assurant des interactions pertinentes et contextuellement appropri√©es.

Un mod√®le de prompt peut ressembler √† ceci :

```markdown
Generate a product slogan based on the following {{product}} with the following {{keywords}}
```

#### ‚õèÔ∏è Outils

Les outils dans le Model Context Protocol (MCP) sont des fonctions que le mod√®le IA peut ex√©cuter pour r√©aliser des t√¢ches sp√©cifiques. Ces outils visent √† enrichir les capacit√©s du mod√®le en fournissant des op√©rations structur√©es et fiables. Les points cl√©s sont :

- **Fonctions ex√©cutables par le mod√®le IA** : Les outils sont des fonctions que le mod√®le peut invoquer pour accomplir diff√©rentes t√¢ches.
- **Nom unique et description** : Chaque outil poss√®de un nom distinct et une description d√©taill√©e expliquant son objectif et sa fonctionnalit√©.
- **Param√®tres et sorties** : Les outils acceptent des param√®tres sp√©cifiques et retournent des sorties structur√©es, garantissant des r√©sultats coh√©rents et pr√©visibles.
- **Fonctions discr√®tes** : Les outils effectuent des fonctions sp√©cifiques comme des recherches web, calculs ou requ√™tes en base de donn√©es.

Un exemple d‚Äôoutil pourrait ressembler √† ceci :

```typescript
server.tool(
  "GetProducts",
  {
    pageSize: z.string().optional(),
    pageCount: z.string().optional()
  }, () => {
    // return results from API
  }
)
```

## Fonctionnalit√©s des Clients

Dans le Model Context Protocol (MCP), les clients offrent plusieurs fonctionnalit√©s cl√©s aux serveurs, am√©liorant la fonctionnalit√© globale et les interactions au sein du protocole. Une fonctionnalit√© notable est le Sampling.

### üëâ Sampling

- **Comportements agentiques initi√©s par le serveur** : Les clients permettent aux serveurs de d√©clencher des actions ou comportements sp√©cifiques de mani√®re autonome, augmentant les capacit√©s dynamiques du syst√®me.
- **Interactions r√©cursives avec les LLM** : Cette fonctionnalit√© autorise des interactions r√©cursives avec les grands mod√®les de langage (LLM), permettant un traitement plus complexe et it√©ratif des t√¢ches.
- **Demande de compl√©tions suppl√©mentaires** : Les serveurs peuvent demander des compl√©tions additionnelles au mod√®le, assurant que les r√©ponses sont compl√®tes et contextuellement pertinentes.

## Flux d‚Äôinformation dans MCP

Le Model Context Protocol (MCP) d√©finit un flux structur√© d‚Äôinformations entre hosts, clients, serveurs et mod√®les. Comprendre ce flux clarifie comment les requ√™tes utilisateurs sont trait√©es et comment les outils externes et donn√©es sont int√©gr√©s dans les r√©ponses du mod√®le.

- **Le Host initie la connexion**  
  L‚Äôapplication host (comme un IDE ou une interface de chat) √©tablit une connexion √† un serveur MCP, g√©n√©ralement via STDIO, WebSocket ou un autre transport support√©.

- **N√©gociation des capacit√©s**  
  Le client (int√©gr√© au host) et le serveur √©changent des informations sur leurs fonctionnalit√©s support√©es, outils, ressources et versions du protocole. Cela garantit que les deux parties comprennent les capacit√©s disponibles pour la session.

- **Requ√™te utilisateur**  
  L‚Äôutilisateur interagit avec le host (ex. saisit un prompt ou une commande). Le host collecte cette entr√©e et la transmet au client pour traitement.

- **Utilisation de ressources ou d‚Äôoutils**  
  - Le client peut demander un contexte ou des ressources suppl√©mentaires au serveur (fichiers, entr√©es en base, articles de base de connaissances) pour enrichir la compr√©hension du mod√®le.  
  - Si le mod√®le d√©termine qu‚Äôun outil est n√©cessaire (ex. pour r√©cup√©rer des donn√©es, effectuer un calcul, appeler une API), le client envoie une requ√™te d‚Äôinvocation d‚Äôoutil au serveur, pr√©cisant le nom de l‚Äôoutil et ses param√®tres.

- **Ex√©cution par le serveur**  
  Le serveur re√ßoit la requ√™te de ressource ou d‚Äôoutil, ex√©cute les op√©rations n√©cessaires (fonction, requ√™te en base, r√©cup√©ration de fichier) et renvoie les r√©sultats au client sous un format structur√©.

- **G√©n√©ration de la r√©ponse**  
  Le client int√®gre les r√©ponses du serveur (donn√©es, r√©sultats d‚Äôoutils, etc.) dans l‚Äôinteraction en cours avec le mod√®le. Le mod√®le utilise ces informations pour g√©n√©rer une r√©ponse compl√®te et contextuellement pertinente.

- **Pr√©sentation du r√©sultat**  
  Le host re√ßoit la sortie finale du client et la pr√©sente √† l‚Äôutilisateur, incluant souvent le texte g√©n√©r√© par le mod√®le ainsi que les r√©sultats des ex√©cutions d‚Äôoutils ou recherches de ressources.

Ce flux permet au MCP de supporter des applications IA avanc√©es, interactives et conscientes du contexte, en connectant de mani√®re fluide les mod√®les avec des outils et donn√©es externes.

## D√©tails du protocole

MCP (Model Context Protocol) est construit au-dessus de [JSON-RPC 2.0](https://www.jsonrpc.org/), fournissant un format de message standardis√© et ind√©pendant du langage pour la communication entre hosts, clients et serveurs. Cette base permet des interactions fiables, structur√©es et extensibles sur diverses plateformes et langages de programmation.

### Fonctionnalit√©s cl√©s du protocole

MCP √©tend JSON-RPC 2.0 avec des conventions suppl√©mentaires pour l‚Äôinvocation d‚Äôoutils, l‚Äôacc√®s aux ressources et la gestion des prompts. Il supporte plusieurs couches de transport (STDIO, WebSocket, SSE) et permet une communication s√©curis√©e, extensible et ind√©pendante du langage entre composants.

#### üß¢ Protocole de base

- **Format de message JSON-RPC** : Toutes les requ√™tes et r√©ponses utilisent la sp√©cification JSON-RPC 2.0, assurant une structure coh√©rente pour les appels de m√©thode, param√®tres, r√©sultats et gestion des erreurs.
- **Connexions avec √©tat** : Les sessions MCP maintiennent l‚Äô√©tat sur plusieurs requ√™tes, supportant les conversations en cours, l‚Äôaccumulation de contexte et la gestion des ressources.
- **N√©gociation des capacit√©s** : Lors de l‚Äô√©tablissement de la connexion, clients et serveurs √©changent des informations sur les fonctionnalit√©s support√©es, versions du protocole, outils et ressources disponibles. Cela garantit une compr√©hension mutuelle des capacit√©s et une adaptation en cons√©quence.

#### ‚ûï Utilitaires suppl√©mentaires

Voici quelques utilitaires et extensions de protocole que MCP propose pour am√©liorer l‚Äôexp√©rience d√©veloppeur et permettre des sc√©narios avanc√©s :

- **Options de configuration** : MCP permet la configuration dynamique des param√®tres de session, tels que les permissions d‚Äôoutils, l‚Äôacc√®s aux ressources et les r√©glages du mod√®le, adapt√©s √† chaque interaction.
- **Suivi de progression** : Les op√©rations longues peuvent rapporter des mises √† jour de progression, offrant des interfaces utilisateur r√©actives et une meilleure exp√©rience durant les t√¢ches complexes.
- **Annulation de requ√™tes** : Les clients peuvent annuler des requ√™tes en cours, permettant aux utilisateurs d‚Äôinterrompre des op√©rations devenues inutiles ou trop longues.
- **Rapport d‚Äôerreurs** : Messages et codes d‚Äôerreur standardis√©s facilitent le diagnostic, la gestion des √©checs et fournissent des retours exploitables aux utilisateurs et d√©veloppeurs.
- **Journalisation** : Clients et serveurs peuvent √©mettre des logs structur√©s pour audit, d√©bogage et surveillance des interactions du protocole.

En tirant parti de ces fonctionnalit√©s, MCP assure une communication robuste, s√©curis√©e et flexible entre mod√®les de langage et outils ou sources de donn√©es externes.

### üîê Consid√©rations de s√©curit√©

Les impl√©mentations MCP doivent respecter plusieurs principes cl√©s de s√©curit√© pour garantir des interactions s√ªres et fiables :

- **Consentement et contr√¥le utilisateur** : Les utilisateurs doivent donner un consentement explicite avant tout acc√®s aux donn√©es ou ex√©cution d‚Äôop√©rations. Ils doivent disposer d‚Äôun contr√¥le clair sur les donn√©es partag√©es et les actions autoris√©es, soutenu par des interfaces intuitives pour la revue et l‚Äôapprobation des activit√©s.

- **Confidentialit√© des donn√©es** : Les donn√©es utilisateur ne doivent √™tre expos√©es qu‚Äôavec consentement explicite et doivent √™tre prot√©g√©es par des contr√¥les d‚Äôacc√®s appropri√©s. Les impl√©mentations MCP doivent pr√©venir toute transmission non autoris√©e et garantir la confidentialit√© tout au long des interactions.

- **S√©curit√© des outils** : Avant d‚Äôinvoquer un outil, un consentement utilisateur explicite est requis. Les utilisateurs doivent comprendre clairement la fonctionnalit√© de chaque outil, et des barri√®res de s√©curit√© solides doivent √™tre appliqu√©es pour √©viter toute ex√©cution non intentionnelle ou dangereuse.

En suivant ces principes, MCP garantit la confiance, la confidentialit√© et la s√©curit√© des utilisateurs √† travers toutes les interactions du protocole.

## Exemples de code : composants cl√©s

Voici des exemples de code dans plusieurs langages populaires illustrant comment impl√©menter des composants cl√©s de serveurs MCP et des outils.

### Exemple .NET : cr√©er un serveur MCP simple avec outils

Voici un exemple concret en .NET montrant comment impl√©menter un serveur MCP simple avec des outils personnalis√©s. Cet exemple illustre la d√©finition et l‚Äôenregistrement d‚Äôoutils, la gestion des requ√™tes, et la connexion du serveur via le Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Exemple Java : composants serveur MCP

Cet exemple montre la m√™me impl√©mentation serveur MCP et l‚Äôenregistrement d‚Äôoutils que l‚Äôexemple .NET ci-dessus, mais en Java.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f¬∞F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Exemple Python : construire un serveur MCP

Dans cet exemple, nous montrons comment construire un serveur MCP en Python. Deux m√©thodes diff√©rentes pour cr√©er des outils sont √©galement pr√©sent√©es.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### Exemple JavaScript : cr√©er un serveur MCP

Cet exemple illustre la cr√©ation d‚Äôun serveur MCP en JavaScript et comment enregistrer deux outils li√©s √† la m√©t√©o.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}¬∞F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Cet exemple JavaScript montre comment cr√©er un client MCP qui se connecte √† un serveur, envoie un prompt et traite la r√©ponse, y compris les appels d‚Äôoutils effectu√©s.

## S√©curit√© et autorisation

MCP int√®gre plusieurs concepts et m√©canismes pour g√©rer la s√©curit√© et l‚Äôautorisation tout au long du protocole :

1. **Contr√¥le des permissions d‚Äôoutils** :  
  Les clients peuvent sp√©cifier quels outils un mod√®le est autoris√© √† utiliser durant une session. Cela garantit que seuls les outils explicitement autoris√©s sont accessibles, r√©duisant le risque d‚Äôop√©rations non intentionnelles ou dangereuses. Les permissions peuvent √™tre configur√©es dynamiquement selon les pr√©f√©rences utilisateur, les politiques organisationnelles ou le contexte de l‚Äôinteraction.

2. **Authentification** :  
  Les serveurs peuvent exiger une authentification avant d‚Äôaccorder l‚Äôacc√®s aux outils, ressources ou op√©rations sensibles. Cela peut impliquer des cl√©s API, tokens OAuth ou d‚Äôautres sch√©mas d‚Äôauthentification. Une authentification appropri√©e garantit que seuls les clients et utilisateurs de confiance peuvent invoquer les capacit√©s c√¥t√© serveur.

3. **Validation** :  
  La validation des param√®tres est appliqu√©e pour toutes les invocations d‚Äôoutils. Chaque outil d√©finit les types, formats et contraintes attendus pour ses param√®tres, et le serveur valide les requ√™tes entrantes en cons√©quence. Cela emp√™che les entr√©es malform√©es ou malveillantes d‚Äôatteindre les impl√©mentations d‚Äôoutils et maintient l‚Äôint√©grit√© des op√©rations.

4. **Limitation de d√©bit** :  
  Pour pr√©venir les abus et garantir une utilisation √©quitable des ressources serveur, les serveurs MCP peuvent appliquer des limites de fr√©quence pour les appels d‚Äôoutils et l‚Äôacc√®s aux ressources. Ces limites peuvent √™tre d√©finies par utilisateur, session ou globalement, et prot√®gent contre les attaques par d√©ni de service ou la consommation excessive.

En combinant ces m√©canismes, MCP offre une base s√©curis√©e pour int√©grer les mod√®les de langage avec des outils et donn√©es externes, tout en donnant aux utilisateurs et d√©veloppeurs un contr√¥le fin sur l‚Äôacc√®s et l‚Äôutilisation.

## Messages du protocole

La communication MCP utilise des messages JSON structur√©s pour faciliter des interactions claires et fiables entre clients, serveurs et mod√®les. Les types de messages principaux incluent :

- **Requ√™te client**  
  Envoy√©e du client au serveur, ce message inclut g√©n√©ralement :  
  - Le prompt ou la commande de l‚Äôutilisateur  
  - L‚Äôhistorique de conversation pour le contexte  
  - La configuration et permissions des outils  
  - Toute m√©tadonn√©e ou information de session suppl√©mentaire

- **R√©ponse du mod√®le**  
  Renvoy√©e par le mod√®le (via le client), ce message contient :  
  - Le texte g√©n√©r√© ou la compl√©tion bas√©e sur le prompt et le contexte  
  - Des instructions optionnelles d‚Äôappel d‚Äôoutil si le mod√®le juge n√©cessaire d‚Äôen invoquer un  
  - Des r√©f√©rences √† des ressources ou contexte additionnel selon besoin

- **Requ√™te d‚Äôoutil**  
  Envoy√©e du client au serveur lorsqu‚Äôun outil doit √™tre ex√©cut√©. Ce message inclut :  
  - Le nom de l‚Äôoutil √† invoquer  
  - Les param√®tres requis par l‚Äôoutil (valid√©s selon son sch√©ma)  
  - Des informations contextuelles ou identifiants pour le suivi de la requ√™te

- **R√©ponse d‚Äôoutil**  
  Renvoy√©e par le serveur apr√®s ex√©cution d‚Äôun outil. Ce message fournit :  
  - Les r√©sultats de l‚Äôex√©cution de l‚Äôoutil (donn√©es ou contenu structur√©)  
  - Les erreurs ou informations d‚Äô√©tat en cas d‚Äô√©chec  
  - Optionnellement, des m√©tadonn√©es ou logs li√©s √† l‚Äôex√©cution

Ces messages structur√©s garantissent que chaque √©tape du workflow MCP est explicite, tra√ßable et extensible, supportant des sc√©narios avanc√©s comme les conversations multi-tours, le cha√Ænage d‚Äôoutils et une gestion robuste des erreurs.

## Points cl√©s √† retenir

-

**Aviso Legal**:  
Este documento foi traduzido utilizando o servi√ßo de tradu√ß√£o por IA [Co-op Translator](https://github.com/Azure/co-op-translator). Embora nos esforcemos para garantir a precis√£o, por favor, esteja ciente de que tradu√ß√µes autom√°ticas podem conter erros ou imprecis√µes. O documento original em seu idioma nativo deve ser considerado a fonte autorizada. Para informa√ß√µes cr√≠ticas, recomenda-se a tradu√ß√£o profissional feita por humanos. N√£o nos responsabilizamos por quaisquer mal-entendidos ou interpreta√ß√µes equivocadas decorrentes do uso desta tradu√ß√£o.