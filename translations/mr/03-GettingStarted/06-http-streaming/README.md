<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-13T20:32:58+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "mr"
}
-->
# HTTPS स्ट्रीमिंग विथ Model Context Protocol (MCP)

हा अध्याय Model Context Protocol (MCP) वापरून HTTPS द्वारे सुरक्षित, स्केलेबल आणि रिअल-टाइम स्ट्रीमिंग कशी अंमलात आणायची याबाबत सविस्तर मार्गदर्शन करतो. यात स्ट्रीमिंगची गरज, उपलब्ध ट्रान्सपोर्ट मेकॅनिझम, MCP मध्ये स्ट्रीमेबल HTTP कसे अंमलात आणायचे, सुरक्षा सर्वोत्तम पद्धती, SSE कडून माइग्रेशन, आणि स्वतःचे स्ट्रीमिंग MCP अॅप्लिकेशन्स तयार करण्यासाठी व्यावहारिक मार्गदर्शन यांचा समावेश आहे.

## MCP मधील ट्रान्सपोर्ट मेकॅनिझम आणि स्ट्रीमिंग

हा विभाग MCP मध्ये उपलब्ध विविध ट्रान्सपोर्ट मेकॅनिझम आणि त्यांचा क्लायंट आणि सर्व्हरमधील रिअल-टाइम संवादासाठी स्ट्रीमिंग क्षमता सक्षम करण्यातील भूमिका याचा अभ्यास करतो.

### ट्रान्सपोर्ट मेकॅनिझम म्हणजे काय?

ट्रान्सपोर्ट मेकॅनिझम म्हणजे क्लायंट आणि सर्व्हर यांच्यात डेटा कसा देवाणघेवाण होतो हे ठरवणारा मार्ग. MCP वेगवेगळ्या वातावरण आणि गरजांसाठी अनेक ट्रान्सपोर्ट प्रकारांना समर्थन देते:

- **stdio**: स्टँडर्ड इनपुट/आउटपुट, स्थानिक आणि CLI-आधारित टूल्ससाठी योग्य. सोपे पण वेब किंवा क्लाउडसाठी योग्य नाही.
- **SSE (Server-Sent Events)**: सर्व्हर HTTP वरून क्लायंटला रिअल-टाइम अपडेट्स पाठवू शकतो. वेब UI साठी चांगले, पण स्केलेबिलिटी आणि लवचिकतेत मर्यादित.
- **Streamable HTTP**: आधुनिक HTTP-आधारित स्ट्रीमिंग ट्रान्सपोर्ट, नोटिफिकेशन्स आणि चांगली स्केलेबिलिटी समर्थित. बहुतेक उत्पादन आणि क्लाउड परिस्थितीसाठी शिफारस केलेले.

### तुलना तक्ता

खालील तक्त्यात या ट्रान्सपोर्ट मेकॅनिझममधील फरक समजून घ्या:

| ट्रान्सपोर्ट       | रिअल-टाइम अपडेट्स | स्ट्रीमिंग | स्केलेबिलिटी | वापर प्रकरण               |
|-------------------|--------------------|-----------|--------------|---------------------------|
| stdio             | नाही               | नाही      | कमी          | स्थानिक CLI टूल्स         |
| SSE               | होय                | होय       | मध्यम        | वेब, रिअल-टाइम अपडेट्स  |
| Streamable HTTP   | होय                | होय       | जास्त        | क्लाउड, मल्टी-क्लायंट     |

> **टिप:** योग्य ट्रान्सपोर्ट निवडल्याने कार्यक्षमता, स्केलेबिलिटी आणि वापरकर्ता अनुभव सुधारतो. **Streamable HTTP** आधुनिक, स्केलेबल आणि क्लाउड-तयार अॅप्लिकेशन्ससाठी शिफारस केले जाते.

पूर्वीच्या अध्यायांमध्ये तुम्हाला stdio आणि SSE ट्रान्सपोर्ट दाखवले होते, तर या अध्यायात Streamable HTTP ट्रान्सपोर्टवर लक्ष केंद्रित केले आहे.

## स्ट्रीमिंग: संकल्पना आणि प्रेरणा

स्ट्रीमिंगच्या मूलभूत संकल्पना आणि प्रेरणा समजून घेणे प्रभावी रिअल-टाइम संवाद प्रणाली अंमलात आणण्यासाठी आवश्यक आहे.

**स्ट्रीमिंग** ही नेटवर्क प्रोग्रामिंगमधील एक तंत्र आहे ज्यात संपूर्ण प्रतिसाद तयार होण्याची वाट न पाहता डेटा लहान, हाताळण्याजोग्या तुकड्यांमध्ये किंवा घटनांच्या मालिकेप्रमाणे पाठवला आणि प्राप्त केला जातो. हे विशेषतः उपयुक्त आहे:

- मोठ्या फाइल्स किंवा डेटासेटसाठी.
- रिअल-टाइम अपडेट्ससाठी (उदा. चॅट, प्रगती पट्ट्या).
- दीर्घकालीन गणनांसाठी जिथे वापरकर्त्याला सतत माहिती द्यायची असते.

स्ट्रीमिंगबद्दल उच्चस्तरीय माहिती:

- डेटा हळूहळू दिला जातो, एकाच वेळी नाही.
- क्लायंट येताच डेटा प्रक्रिया करू शकतो.
- विलंब कमी होतो आणि वापरकर्ता अनुभव सुधारतो.

### स्ट्रीमिंग का वापरावे?

स्ट्रीमिंग वापरण्याची कारणे:

- वापरकर्त्यांना लगेच प्रतिसाद मिळतो, फक्त शेवटी नाही.
- रिअल-टाइम अॅप्लिकेशन्स आणि प्रतिसादक्षम UI सक्षम करतो.
- नेटवर्क आणि संगणकीय संसाधनांचा अधिक कार्यक्षम वापर.

### सोपा उदाहरण: HTTP स्ट्रीमिंग सर्व्हर आणि क्लायंट

स्ट्रीमिंग कसे अंमलात आणता येते याचे सोपे उदाहरण:

<details>
<summary>Python</summary>

**सर्व्हर (Python, FastAPI आणि StreamingResponse वापरून):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**क्लायंट (Python, requests वापरून):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

हा उदाहरण सर्व्हर कसे संदेशांची मालिका क्लायंटला पाठवतो ते दाखवतो, सर्व संदेश तयार होण्याची वाट न पाहता.

**कसे कार्य करते:**
- सर्व्हर प्रत्येक संदेश तयार होताच तो पाठवतो.
- क्लायंट येताच प्रत्येक तुकडा प्राप्त करून प्रिंट करतो.

**आवश्यकता:**
- सर्व्हरला स्ट्रीमिंग प्रतिसाद वापरावा लागतो (उदा. FastAPI मधील `StreamingResponse`).
- क्लायंटला प्रतिसाद स्ट्रीम म्हणून प्रक्रिया करावा लागतो (`stream=True` requests मध्ये).
- Content-Type सहसा `text/event-stream` किंवा `application/octet-stream` असतो.

</details>

<details>
<summary>Java</summary>

**सर्व्हर (Java, Spring Boot आणि Server-Sent Events वापरून):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लायंट (Java, Spring WebFlux WebClient वापरून):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java अंमलबजावणी टिपा:**
- Spring Boot चा reactive stack `Flux` सह वापरतो
- `ServerSentEvent` इव्हेंट प्रकारांसह संरचित इव्हेंट स्ट्रीमिंग पुरवतो
- `WebClient` चा `bodyToFlux()` रिएक्टिव्ह स्ट्रीमिंगसाठी वापरतो
- `delayElements()` इव्हेंट्समधील प्रक्रिया वेळेचे अनुकरण करतो
- इव्हेंट्सना प्रकार (`info`, `result`) दिले जातात ज्यामुळे क्लायंटला हाताळणे सोपे होते

</details>

### तुलना: पारंपरिक स्ट्रीमिंग विरुद्ध MCP स्ट्रीमिंग

पारंपरिक आणि MCP स्ट्रीमिंग कसे वेगळे आहेत हे खालील तक्त्यात दाखवले आहे:

| वैशिष्ट्य               | पारंपरिक HTTP स्ट्रीमिंग       | MCP स्ट्रीमिंग (नोटिफिकेशन्स)    |
|------------------------|-------------------------------|----------------------------------|
| मुख्य प्रतिसाद          | तुकड्यांमध्ये पाठवला जातो     | एकदाच, शेवटी पाठवला जातो        |
| प्रगती अपडेट्स         | डेटा तुकड्यांप्रमाणे पाठवले जातात | नोटिफिकेशन्सद्वारे पाठवले जातात  |
| क्लायंटची गरज          | स्ट्रीम प्रक्रिया करणे आवश्यक  | मेसेज हँडलर अंमलात आणणे आवश्यक  |
| वापर प्रकरण            | मोठ्या फाइल्स, AI टोकन स्ट्रीम्स | प्रगती, लॉग्स, रिअल-टाइम फीडबॅक |

### महत्त्वाचे फरक

अधिक काही महत्त्वाचे फरक:

- **संवाद पद्धत:**
   - पारंपरिक HTTP स्ट्रीमिंग: साधा chunked ट्रान्सफर एन्कोडिंग वापरतो
   - MCP स्ट्रीमिंग: JSON-RPC प्रोटोकॉलसह संरचित नोटिफिकेशन सिस्टम वापरतो

- **मेसेज फॉरमॅट:**
   - पारंपरिक HTTP: साधे टेक्स्ट तुकडे, नवीन ओळींसह
   - MCP: मेटाडेटासह संरचित LoggingMessageNotification ऑब्जेक्ट्स

- **क्लायंट अंमलबजावणी:**
   - पारंपरिक HTTP: सोपा क्लायंट जो स्ट्रीमिंग प्रतिसाद प्रक्रिया करतो
   - MCP: अधिक प्रगत क्लायंट जो वेगवेगळ्या प्रकारच्या मेसेजेससाठी मेसेज हँडलर वापरतो

- **प्रगती अपडेट्स:**
   - पारंपरिक HTTP: प्रगती मुख्य प्रतिसाद स्ट्रीमचा भाग असते
   - MCP: प्रगती स्वतंत्र नोटिफिकेशन मेसेजेसद्वारे पाठवली जाते, मुख्य प्रतिसाद शेवटी येतो

### शिफारसी

पारंपरिक स्ट्रीमिंग (`/stream` एन्डपॉइंट वापरून) आणि MCP स्ट्रीमिंग यामध्ये निवड करताना काही शिफारसी:

- **सोप्या स्ट्रीमिंगसाठी:** पारंपरिक HTTP स्ट्रीमिंग सोपे आणि मूलभूत गरजांसाठी पुरेसे आहे.

- **जटिल, संवादात्मक अॅप्ससाठी:** MCP स्ट्रीमिंग अधिक संरचित, समृद्ध मेटाडेटा आणि नोटिफिकेशन्स व अंतिम निकाल यामध्ये वेगळेपणा पुरवते.

- **AI अॅप्लिकेशन्ससाठी:** MCP ची नोटिफिकेशन प्रणाली दीर्घकालीन AI टास्कसाठी उपयुक्त आहे जिथे वापरकर्त्यांना प्रगतीची माहिती द्यायची असते.

## MCP मध्ये स्ट्रीमिंग

आता तुम्हाला पारंपरिक आणि MCP स्ट्रीमिंगमधील फरक समजला आहे. चला पाहूया MCP मध्ये स्ट्रीमिंग कसे वापरायचे.

MCP फ्रेमवर्कमध्ये स्ट्रीमिंग कसे कार्य करते हे समजून घेणे आवश्यक आहे जेणेकरून तुम्ही रिअल-टाइम फीडबॅक देणारी प्रतिसादक्षम अॅप्लिकेशन्स तयार करू शकता.

MCP मध्ये स्ट्रीमिंग म्हणजे मुख्य प्रतिसाद तुकड्यांमध्ये पाठवणे नाही, तर टूल विनंती प्रक्रिया करत असताना क्लायंटला **नोटिफिकेशन्स** पाठवणे होय. या नोटिफिकेशन्समध्ये प्रगती अपडेट्स, लॉग्स किंवा इतर इव्हेंट्स असू शकतात.

### कसे कार्य करते

मुख्य निकाल अजूनही एकदाच पाठवला जातो. मात्र, प्रक्रिया दरम्यान नोटिफिकेशन्स स्वतंत्र मेसेजेस म्हणून पाठवता येतात ज्यामुळे क्लायंटला रिअल-टाइम अपडेट्स मिळतात. क्लायंटला या नोटिफिकेशन्स हाताळता आणि दाखवता यायला हवे.

## नोटिफिकेशन म्हणजे काय?

"नोटिफिकेशन" म्हटलं तर MCP संदर्भात काय अर्थ?

नोटिफिकेशन म्हणजे सर्व्हरकडून क्लायंटला पाठवलेला मेसेज जो दीर्घकालीन ऑपरेशन दरम्यान प्रगती, स्थिती किंवा इतर इव्हेंट्सची माहिती देतो. नोटिफिकेशन्स पारदर्शकता आणि वापरकर्ता अनुभव सुधारतात.

उदाहरणार्थ, क्लायंटने सर्व्हरशी प्रारंभिक हँडशेक पूर्ण केल्यानंतर एक नोटिफिकेशन पाठवायची अपेक्षा असते.

नोटिफिकेशन JSON मेसेजसारखे दिसते:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

नोटिफिकेशन्स MCP मधील ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) या टॉपिकशी संबंधित आहेत.

लॉगिंग कार्यान्वित करण्यासाठी सर्व्हरला हे फीचर/कॅपॅबिलिटी म्हणून सक्षम करावे लागते:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> वापरल्या जाणाऱ्या SDK नुसार, लॉगिंग डीफॉल्टने सक्षम असू शकते किंवा तुम्हाला ते सर्व्हर कॉन्फिगरेशनमध्ये स्पष्टपणे सक्षम करावे लागू शकते.

नोटिफिकेशन्सचे वेगवेगळे प्रकार:

| स्तर       | वर्णन                          | उदाहरण वापर प्रकरण             |
|------------|--------------------------------|-------------------------------|
| debug      | सविस्तर डीबगिंग माहिती         | फंक्शन प्रवेश/बाहेर पडणे      |
| info       | सामान्य माहितीपर मेसेजेस       | ऑपरेशन प्रगती अपडेट्स         |
| notice     | सामान्य पण महत्त्वाचे इव्हेंट्स | कॉन्फिगरेशन बदल               |
| warning    | इशारा स्थिती                  | जुनी वैशिष्ट्ये वापरणे         |
| error      | त्रुटी स्थिती                  | ऑपरेशन अपयश                  |
| critical   | गंभीर स्थिती                  | सिस्टम घटक अपयश               |
| alert      | त्वरित कृती आवश्यक            | डेटा भ्रष्टाचार आढळला         |
| emergency  | सिस्टम वापरासाठी अयोग्य        | पूर्ण सिस्टम अपयश             |

## MCP मध्ये नोटिफिकेशन्स अंमलात आणणे

नोटिफिकेशन्स अंमलात आणण्यासाठी, तुम्हाला सर्व्हर आणि क्लायंट दोन्ही बाजू सेटअप कराव्या लागतात जेणेकरून रिअल-टाइम अपडेट्स हाताळता येतील. यामुळे तुमचे अॅप्लिकेशन दीर्घकालीन ऑपरेशन्स दरम्यान वापरकर्त्यांना त्वरित फीडबॅक देऊ शकते.

### सर्व्हर-साइड: नोटिफिकेशन्स पाठवणे

सर्व्हर बाजूपासून सुरुवात करूया. MCP मध्ये तुम्ही असे टूल्स परिभाषित करता जे विनंती प्रक्रिया करताना नोटिफिकेशन्स पाठवू शकतात. सर्व्हर संदर्भ ऑब्जेक्ट (`ctx` सहसा) वापरून क्लायंटला मेसेजेस पाठवतो.

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

वरील उदाहरणात, `process_files` टूल प्रत्येक फाइल प्रक्रिया करताना क्लायंटला तीन नोटिफिकेशन्स पाठवते. `ctx.info()` मेथड माहितीपर मेसेजेस पाठवण्यासाठी वापरली जाते.

</details>

तसेच, नोटिफिकेशन्स सक्षम करण्यासाठी, तुमचा सर्व्हर स्ट्रीमिंग ट्रान्सपोर्ट (उदा. `streamable-http`) वापरतो याची खात्री करा आणि क्लायंट नोटिफिकेशन्स प्रक्रिया करण्यासाठी मेसेज हँडलर अंमलात आणतो. खाली सर्व्हर `streamable-http` ट्रान्सपोर्ट वापरण्यासाठी सेटअप कसा करायचा ते दाखवले आहे:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

या .NET उदाहरणात, `ProcessFiles` टूल `Tool` अ‍ॅट्रिब्यूटसह सजवलेले आहे आणि प्रत्येक फाइल प्रक्रिया करताना क्लायंटला तीन नोटिफिकेशन्स पाठवते. `ctx.Info()` मेथड माहितीपर मेसेजेस पाठवण्यासाठी वापरली जाते.

तुमच्या .NET MCP सर्व्हरमध्ये नोटिफिकेशन्स सक्षम करण्यासाठी, स्ट्रीमिंग ट्रान्सपोर्ट वापरल्याची खात्री करा:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### क्लायंट-साइड: नोटिफिकेशन्स प्राप्त करणे

क्लायंटला नोटिफिकेशन्स प्राप्त करून प्रक्रिया करण्यासाठी मेसेज हँडलर अंमलात आणावा लागतो.

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

वरील कोडमध्ये, `message_handler` फंक्शन तपासते की येणारा मेसेज नोटिफिकेशन आहे का. असल्यास, तो नोटिफिकेशन प्रिंट करते; अन्यथा, तो सामान्य सर्व्हर मेसेज म्हणून प्रक्रिया करते. तसेच, `ClientSession` `message_handler` सह इनिशियलाइझ केले आहे जेणेकरून नोटिफिकेशन्स हाताळता येतील.

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

या .NET उदाहरणात, `MessageHandler` फंक्शन तपासते की येणारा मेसेज नोटिफिकेशन आहे का. असल्यास, तो नोटिफिकेशन प्रिंट करते; अन्यथा, तो सामान्य सर्व्हर मेसेज म्हणून प्रक्रिया करते. `ClientSession` `ClientSessionOptions` मधील मेसेज हँडलर वापरून इनिशियलाइझ केले आहे.

</details>

नोटिफिकेशन्स सक्षम करण्यासाठी, तुमचा सर्व्हर स्ट्रीमिंग ट्रान्सपोर्ट (उदा. `streamable-http`) वापरतो याची खात्री करा आणि क्लायंट नोटिफिकेशन्स प्रक्रिया करण्यासाठी मेसेज हँडलर अंमलात आणतो.

## प्रगती नोटिफिकेशन्स आणि परिस्थिती

हा विभाग MCP मधील प्रगती नोटिफिकेशन्सची संकल्पना, त्यांचे महत्त्व, आणि Streamable HTTP वापरून त्यांची अंमलबजावणी कशी करायची हे स्पष्ट करतो. तसेच, तुमच्या समजुतीसाठी एक व्यावहारिक कार्य दिले आहे.

प्रगती नोटिफिकेशन्स म्हणजे दीर्घकालीन ऑपरेशन्स दरम्यान सर्व्हरकडून क्लायंटला पाठवले जाणारे रिअल-टाइम मेसेजेस. संपूर्ण प्रक्रिया पूर्ण होण्याची वाट न पाहता, सर्व्हर क्लायंटला चालू स्थितीची माहिती देतो. यामुळे पारदर्शकता, वापरकर्ता अनुभव सुधारतो आणि डीबगिंग सुलभ होते.

**उदाहरण:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### प्रगती नोटिफिकेशन्स का वापराव्यात?

प्रगती नोटिफिकेशन्स महत्त्वाचे आहेत कारण:

- **चांगला वापरकर्ता अनुभव:** वापरकर्त्यांना काम चालू असताना

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**क्लायंट उदाहरण:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## सुरक्षा विचार

HTTP-आधारित ट्रान्सपोर्टसह MCP सर्व्हर अंमलात आणताना, सुरक्षा हा एक अत्यंत महत्त्वाचा मुद्दा असतो ज्यासाठी विविध हल्ल्यांच्या मार्गांवर आणि संरक्षण यंत्रणांवर काळजीपूर्वक लक्ष देणे आवश्यक असते.

### आढावा

HTTP वर MCP सर्व्हर उघडताना सुरक्षा अत्यंत महत्त्वाची असते. Streamable HTTP नवीन हल्ल्यांचे मार्ग तयार करतो आणि काळजीपूर्वक कॉन्फिगरेशनची गरज असते.

### मुख्य मुद्दे
- **Origin हेडरची पडताळणी**: DNS रीबाइंडिंग हल्ल्यांपासून बचाव करण्यासाठी `Origin` हेडरची नेहमी पडताळणी करा.
- **Localhost बाइंडिंग**: स्थानिक विकासासाठी, सर्व्हर `localhost` वर बाइंड करा जेणेकरून ते सार्वजनिक इंटरनेटवर उघडले जाणार नाहीत.
- **प्रमाणीकरण**: उत्पादनासाठी तैनाती करताना प्रमाणीकरण (उदा. API कीज, OAuth) लागू करा.
- **CORS**: प्रवेश मर्यादित करण्यासाठी Cross-Origin Resource Sharing (CORS) धोरणे कॉन्फिगर करा.
- **HTTPS**: उत्पादनात ट्रॅफिक एन्क्रिप्ट करण्यासाठी HTTPS वापरा.

### सर्वोत्तम पद्धती
- पडताळणी न करता येणाऱ्या विनंत्यांवर कधीही विश्वास ठेवू नका.
- सर्व प्रवेश आणि त्रुटी लॉग करा आणि निरीक्षण करा.
- सुरक्षा त्रुटी दुरुस्त करण्यासाठी नियमितपणे अवलंबित्वे अपडेट करा.

### आव्हाने
- विकास सुलभतेसह सुरक्षेचा समतोल राखणे
- विविध क्लायंट वातावरणांसह सुसंगतता सुनिश्चित करणे


## SSE वरून Streamable HTTP कडे अपग्रेड करणे

सध्या Server-Sent Events (SSE) वापरणाऱ्या अनुप्रयोगांसाठी, Streamable HTTP कडे स्थलांतर केल्याने तुमच्या MCP अंमलबजावणीसाठी सुधारित क्षमता आणि दीर्घकालीन टिकाऊपणा मिळतो.

### का अपग्रेड करावे?

SSE वरून Streamable HTTP कडे अपग्रेड करण्यासाठी दोन महत्त्वाचे कारणे आहेत:

- Streamable HTTP SSE पेक्षा चांगली स्केलेबिलिटी, सुसंगतता आणि समृद्ध सूचना समर्थन देते.
- नवीन MCP अनुप्रयोगांसाठी हा शिफारस केलेला ट्रान्सपोर्ट आहे.

### स्थलांतर पावले

तुमच्या MCP अनुप्रयोगांमध्ये SSE वरून Streamable HTTP कडे स्थलांतर करण्यासाठी खालीलप्रमाणे करा:

- `mcp.run()` मध्ये `transport="streamable-http"` वापरण्यासाठी सर्व्हर कोड अपडेट करा.
- SSE क्लायंटऐवजी `streamablehttp_client` वापरण्यासाठी क्लायंट कोड अपडेट करा.
- क्लायंटमध्ये सूचना प्रक्रिया करण्यासाठी मेसेज हँडलर अंमलात आणा.
- विद्यमान साधने आणि कार्यप्रवाहांसह सुसंगतता तपासा.

### सुसंगतता राखणे

स्थलांतर प्रक्रियेदरम्यान विद्यमान SSE क्लायंटसह सुसंगतता राखणे शिफारसीय आहे. काही धोरणे:

- तुम्ही दोन्ही SSE आणि Streamable HTTP दोन्ही ट्रान्सपोर्ट वेगवेगळ्या एंडपॉइंटवर चालवून समर्थन करू शकता.
- हळूहळू क्लायंटना नवीन ट्रान्सपोर्टकडे स्थलांतर करा.

### आव्हाने

स्थलांतर करताना खालील आव्हाने लक्षात घ्या:

- सर्व क्लायंट अद्ययावत आहेत याची खात्री करणे
- सूचनांच्या वितरणातील फरक हाताळणे

## सुरक्षा विचार

HTTP-आधारित ट्रान्सपोर्टसारख्या Streamable HTTP वापरताना कोणत्याही सर्व्हरची अंमलबजावणी करताना सुरक्षा सर्वोच्च प्राधान्य असावी.

HTTP-आधारित ट्रान्सपोर्टसह MCP सर्व्हर अंमलात आणताना, सुरक्षा हा एक अत्यंत महत्त्वाचा मुद्दा असतो ज्यासाठी विविध हल्ल्यांच्या मार्गांवर आणि संरक्षण यंत्रणांवर काळजीपूर्वक लक्ष देणे आवश्यक असते.

### आढावा

HTTP वर MCP सर्व्हर उघडताना सुरक्षा अत्यंत महत्त्वाची असते. Streamable HTTP नवीन हल्ल्यांचे मार्ग तयार करतो आणि काळजीपूर्वक कॉन्फिगरेशनची गरज असते.

सुरक्षेसाठी काही महत्त्वाचे मुद्दे:

- **Origin हेडरची पडताळणी**: DNS रीबाइंडिंग हल्ल्यांपासून बचाव करण्यासाठी `Origin` हेडरची नेहमी पडताळणी करा.
- **Localhost बाइंडिंग**: स्थानिक विकासासाठी, सर्व्हर `localhost` वर बाइंड करा जेणेकरून ते सार्वजनिक इंटरनेटवर उघडले जाणार नाहीत.
- **प्रमाणीकरण**: उत्पादनासाठी तैनाती करताना प्रमाणीकरण (उदा. API कीज, OAuth) लागू करा.
- **CORS**: प्रवेश मर्यादित करण्यासाठी Cross-Origin Resource Sharing (CORS) धोरणे कॉन्फिगर करा.
- **HTTPS**: उत्पादनात ट्रॅफिक एन्क्रिप्ट करण्यासाठी HTTPS वापरा.

### सर्वोत्तम पद्धती

तुमच्या MCP स्ट्रीमिंग सर्व्हरमध्ये सुरक्षा अंमलात आणताना खालील सर्वोत्तम पद्धती पाळा:

- पडताळणी न करता येणाऱ्या विनंत्यांवर कधीही विश्वास ठेवू नका.
- सर्व प्रवेश आणि त्रुटी लॉग करा आणि निरीक्षण करा.
- सुरक्षा त्रुटी दुरुस्त करण्यासाठी नियमितपणे अवलंबित्वे अपडेट करा.

### आव्हाने

MCP स्ट्रीमिंग सर्व्हरमध्ये सुरक्षा अंमलात आणताना तुम्हाला काही आव्हानांना सामोरे जावे लागेल:

- विकास सुलभतेसह सुरक्षेचा समतोल राखणे
- विविध क्लायंट वातावरणांसह सुसंगतता सुनिश्चित करणे

### असाइनमेंट: तुमचा स्वतःचा स्ट्रीमिंग MCP अॅप तयार करा

**परिस्थिती:**
एक MCP सर्व्हर आणि क्लायंट तयार करा जिथे सर्व्हर आयटम्सची यादी (उदा. फाइल्स किंवा दस्तऐवज) प्रक्रिया करतो आणि प्रत्येक प्रक्रियेसाठी सूचना पाठवतो. क्लायंट प्रत्येक सूचना प्राप्त होताच ती दाखवेल.

**पावले:**

1. अशी सर्व्हर टूल तयार करा जी यादी प्रक्रिया करेल आणि प्रत्येक आयटमसाठी सूचना पाठवेल.
2. क्लायंटमध्ये मेसेज हँडलर तयार करा जो सूचना रिअल टाइममध्ये दाखवेल.
3. सर्व्हर आणि क्लायंट दोन्ही चालवून तुमची अंमलबजावणी तपासा आणि सूचना पाहा.

[Solution](./solution/README.md)

## पुढील वाचन आणि पुढे काय?

MCP स्ट्रीमिंगसह तुमचा प्रवास सुरू ठेवण्यासाठी आणि अधिक प्रगत अनुप्रयोग तयार करण्यासाठी ज्ञान वाढवण्यासाठी, हा विभाग अतिरिक्त संसाधने आणि पुढील पावले सुचवतो.

### पुढील वाचन

- [Microsoft: HTTP Streaming परिचय](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core मधील CORS](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### पुढे काय?

- रिअल-टाइम अॅनालिटिक्स, चॅट किंवा सहकार्यात्मक संपादनासाठी स्ट्रीमिंग वापरणारे अधिक प्रगत MCP टूल्स तयार करण्याचा प्रयत्न करा.
- फ्रंटएंड फ्रेमवर्क्स (React, Vue, इ.) सह MCP स्ट्रीमिंगचे एकत्रीकरण करून लाईव्ह UI अपडेट्स एक्सप्लोर करा.
- पुढे: [VSCode साठी AI Toolkit वापरणे](../07-aitk/README.md)

**अस्वीकरण**:  
हा दस्तऐवज AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून अनुवादित केला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी, कृपया लक्षात घ्या की स्वयंचलित अनुवादांमध्ये चुका किंवा अचूकतेची कमतरता असू शकते. मूळ दस्तऐवज त्याच्या स्थानिक भाषेत अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी अनुवाद करण्याची शिफारस केली जाते. या अनुवादाच्या वापरामुळे उद्भवणाऱ्या कोणत्याही गैरसमजुती किंवा चुकीच्या अर्थलागी आम्ही जबाबदार नाही.