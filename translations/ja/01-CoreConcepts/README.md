<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "056918462dca9b8f75901709fb8f470c",
  "translation_date": "2025-05-16T15:46:46+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "ja"
}
-->
# 📖 MCPコアコンセプト：AI統合のためのモデルコンテキストプロトコルの習得

Model Context Protocol（MCP）は、大規模言語モデル（LLM）と外部ツール、アプリケーション、データソース間の通信を最適化する強力で標準化されたフレームワークです。このSEO最適化ガイドでは、MCPのクライアント・サーバーアーキテクチャ、主要コンポーネント、通信メカニズム、実装のベストプラクティスを理解できるよう解説します。

## 概要

このレッスンでは、Model Context Protocol（MCP）エコシステムを構成する基本的なアーキテクチャとコンポーネントについて学びます。クライアント・サーバーアーキテクチャ、主要コンポーネント、MCPの通信メカニズムについて理解を深めましょう。

## 👩‍🎓 主な学習目標

このレッスンを終えると、以下が理解できるようになります：

- MCPのクライアント・サーバーアーキテクチャの理解
- Hosts、Clients、Serversの役割と責任の把握
- MCPが柔軟な統合レイヤーであるための主要機能の分析
- MCPエコシステム内の情報の流れの理解
- .NET、Java、Python、JavaScriptによるコード例を通じた実践的な知見の獲得

## 🔎 MCPアーキテクチャ：詳細解説

MCPエコシステムはクライアント・サーバーモデルに基づいて構築されています。このモジュラー構造により、AIアプリケーションはツール、データベース、API、コンテキストリソースと効率的に連携できます。アーキテクチャの主要コンポーネントを分解して見ていきましょう。

### 1. Hosts

Model Context Protocol（MCP）におけるHostsは、ユーザーがプロトコルとやり取りするための主要なインターフェースとして重要な役割を果たします。Hostsは、MCPサーバーへの接続を開始し、データやツール、プロンプトへアクセスするアプリケーションや環境です。例として、Visual Studio Codeのような統合開発環境（IDE）、Claude DesktopなどのAIツール、特定のタスク向けにカスタム構築されたエージェントが挙げられます。

**Hosts**はLLMアプリケーションで、接続を開始します。具体的には：

- AIモデルを実行または操作して応答を生成する
- MCPサーバーへの接続を開始する
- 会話の流れやユーザーインターフェースを管理する
- 権限やセキュリティ制約を制御する
- データ共有やツール実行に関するユーザー同意を管理する

### 2. Clients

ClientsはHostsとMCPサーバー間のやり取りを仲介する重要なコンポーネントです。HostsがMCPサーバーの機能を利用できるようにし、スムーズな通信と効率的なデータ交換を実現します。

**Clients**はホストアプリケーション内のコネクターで、以下を担当します：

- サーバーにプロンプトや指示を含むリクエストを送信する
- サーバーと機能の交渉を行う
- モデルからのツール実行リクエストを管理する
- ユーザーへの応答を処理し表示する

### 3. Servers

ServersはMCPクライアントからのリクエストを処理し、適切な応答を提供します。データ取得、ツール実行、プロンプト生成などの操作を管理し、クライアントとHosts間の通信を効率的かつ信頼性の高いものに保ちます。

**Servers**はコンテキストや機能を提供するサービスで、以下を行います：

- 利用可能な機能（リソース、プロンプト、ツール）を登録する
- クライアントからのツール呼び出しを受け取り実行する
- モデルの応答を強化するためのコンテキスト情報を提供する
- 結果をクライアントに返す
- 必要に応じて対話の状態を維持する

Serversは誰でも開発でき、専門的な機能でモデルの能力を拡張できます。

### 4. Server Features

Model Context Protocol（MCP）のServersは、クライアント、ホスト、言語モデル間の豊かな対話を可能にする基本的な構成要素を提供します。これらの機能は、構造化されたコンテキスト、ツール、プロンプトを通じてMCPの能力を高めるよう設計されています。

MCPサーバーは以下のような機能を提供できます：

#### 📑 Resources

MCPにおけるResourcesは、ユーザーやAIモデルが活用できるさまざまな種類のコンテキストやデータを含みます。具体的には：

- **コンテキストデータ**：ユーザーやAIモデルが意思決定やタスク実行に利用できる情報や文脈
- **ナレッジベースやドキュメントリポジトリ**：記事、マニュアル、研究論文などの構造化・非構造化データの集合体で、貴重な知見を提供
- **ローカルファイルやデータベース**：デバイス内やデータベースに保存されたデータで、処理や分析に利用可能
- **APIやウェブサービス**：外部インターフェースやサービスで、追加のデータや機能を提供し、さまざまなオンラインリソースやツールと統合可能

リソースの例としては、データベーススキーマや以下のようにアクセス可能なファイルがあります：

```text
file://log.txt
database://schema
```

### 🤖 Prompts

MCPのPromptsは、ユーザーの作業フローを効率化しコミュニケーションを向上させるための、さまざまな事前定義されたテンプレートや対話パターンを含みます。具体例は以下の通りです：

- **テンプレート化されたメッセージやワークフロー**：特定のタスクや対話を案内する事前構造化されたメッセージやプロセス
- **事前定義された対話パターン**：一貫性と効率性を促進する標準化された一連のアクションと応答
- **専門的な会話テンプレート**：特定の会話タイプ向けにカスタマイズ可能なテンプレートで、関連性が高く文脈に合った対話を実現

プロンプトテンプレートの例は以下の通りです：

```markdown
Generate a product slogan based on the following {{product}} with the following {{keywords}}
```

#### ⛏️ Tools

MCPにおけるToolsは、AIモデルが特定のタスクを実行するために呼び出せる関数です。これらのツールは、構造化され信頼性の高い操作を提供することで、AIモデルの能力を強化します。主な特徴は以下の通りです：

- **AIモデルが実行可能な関数**：モデルが呼び出してさまざまなタスクを行うための実行可能な関数
- **固有の名前と説明**：各ツールは独自の名前と、その目的や機能を説明する詳細な説明を持つ
- **パラメーターと出力**：特定のパラメーターを受け取り、構造化された出力を返すことで一貫性と予測可能性を確保
- **個別の機能**：ウェブ検索、計算、データベースクエリなどの個別機能を実行

ツールの例は以下のようになります：

```typescript
server.tool(
  "GetProducts"
  {
    pageSize: z.string().optional(),
    pageCount: z.string().optional()
  }, () => {
    // return results from API
  }
)
```

## Client Features

MCPにおけるクライアントは、プロトコル内の全体的な機能性と対話を強化するためにサーバーに対していくつかの重要な機能を提供します。その中でも注目すべき機能の一つがSamplingです。

### 👉 Sampling

- **サーバー主導のエージェント的動作**：クライアントはサーバーが自律的に特定のアクションや動作を開始できるようにし、システムの動的能力を高める
- **再帰的なLLMとの対話**：この機能により、大規模言語モデル（LLM）との複雑かつ反復的な処理が可能になる
- **追加のモデル補完要求**：サーバーはモデルに対して追加の補完を要求でき、応答がより包括的かつ文脈に即したものになる

## MCPにおける情報の流れ

Model Context Protocol（MCP）は、Hosts、Clients、Servers、モデル間の情報の流れを構造的に定義しています。この流れを理解することで、ユーザーリクエストがどのように処理され、外部ツールやデータがモデルの応答に統合されるかが明確になります。

- **Hostが接続を開始**  
  IDEやチャットインターフェースなどのホストアプリケーションが、通常はSTDIO、WebSocket、または他のサポートされるトランスポート経由でMCPサーバーへの接続を確立します。

- **機能の交渉**  
  ホストに組み込まれたクライアントとサーバーが、サポートされる機能、ツール、リソース、プロトコルバージョンに関する情報を交換し、双方が利用可能な機能を理解します。

- **ユーザーリクエスト**  
  ユーザーがホストとやり取り（例：プロンプトやコマンドの入力）を行い、ホストはこの入力をクライアントに渡して処理します。

- **リソースまたはツールの利用**  
  - クライアントはモデルの理解を深めるために、サーバーから追加のコンテキストやリソース（ファイル、データベースのエントリ、ナレッジベースの記事など）を要求する場合があります。  
  - モデルがツールの利用が必要と判断した場合（例：データ取得、計算、API呼び出し）、クライアントはツール呼び出しリクエストをサーバーに送信し、ツール名とパラメーターを指定します。

- **サーバー実行**  
  サーバーはリソースまたはツールリクエストを受け取り、必要な操作（関数の実行、データベースクエリ、ファイル取得など）を行い、その結果を構造化された形式でクライアントに返します。

- **応答生成**  
  クライアントはサーバーの応答（リソースデータ、ツール出力など）をモデルとの対話に統合し、モデルはこれを用いて包括的で文脈に即した応答を生成します。

- **結果提示**  
  ホストはクライアントから最終出力を受け取り、モデルが生成したテキストやツール実行・リソース参照の結果を含めてユーザーに提示します。

この流れにより、MCPはモデルと外部ツールやデータソースをシームレスに接続し、高度でインタラクティブ、かつコンテキスト対応のAIアプリケーションをサポートします。

## プロトコルの詳細

MCP（Model Context Protocol）は[JSON-RPC 2.0](https://www.jsonrpc.org/)をベースに構築されており、ホスト、クライアント、サーバー間の通信に標準化された言語非依存のメッセージフォーマットを提供します。この基盤により、多様なプラットフォームやプログラミング言語間で信頼性が高く構造化された拡張可能な対話が可能です。

### 主要なプロトコル機能

MCPはJSON-RPC 2.0を拡張し、ツール呼び出し、リソースアクセス、プロンプト管理のための追加規約を提供します。複数のトランスポート層（STDIO、WebSocket、SSE）をサポートし、コンポーネント間の安全で拡張可能、かつ言語非依存の通信を可能にします。

#### 🧢 基本プロトコル

- **JSON-RPCメッセージフォーマット**：すべてのリクエストとレスポンスはJSON-RPC 2.0仕様に準拠し、メソッド呼び出し、パラメーター、結果、エラー処理の一貫した構造を保証
- **ステートフル接続**：MCPセッションは複数のリクエストにわたって状態を維持し、継続的な会話、コンテキスト蓄積、リソース管理をサポート
- **機能交渉**：接続設定時にクライアントとサーバーがサポートされる機能、プロトコルバージョン、利用可能なツールやリソースについて情報交換し、双方が能力を理解して適応可能にする

#### ➕ 追加ユーティリティ

以下はMCPが提供する追加のユーティリティやプロトコル拡張で、開発者体験を向上させ、高度なシナリオを可能にします：

- **設定オプション**：ツールの権限、リソースアクセス、モデル設定などセッションパラメーターを動的に設定可能で、各対話に合わせて調整できる
- **進捗追跡**：長時間かかる操作は進捗更新を報告でき、複雑なタスク中の応答性とユーザー体験を向上
- **リクエストキャンセル**：クライアントは進行中のリクエストをキャンセル可能で、不要または遅延している操作を中断できる
- **エラー報告**：標準化されたエラーメッセージとコードにより問題診断、障害の優雅な処理、ユーザーや開発者への具体的なフィードバックを提供
- **ログ記録**：クライアントとサーバーは監査、デバッグ、プロトコル対話の監視のために構造化ログを出力可能

これらのプロトコル機能を活用することで、MCPは言語モデルと外部ツールやデータソース間の堅牢で安全かつ柔軟な通信を実現します。

### 🔐 セキュリティに関する考慮事項

MCPの実装は、安全で信頼できる対話を確保するために以下の主要なセキュリティ原則に従うべきです：

- **ユーザーの同意と制御**：データアクセスや操作実行の前にユーザーの明示的な同意が必要です。ユーザーはどのデータを共有し、どのアクションを許可するかを明確に制御でき、操作のレビューと承認を容易にする直感的なUIが提供されるべきです。

- **データプライバシー**：ユーザーデータは明示的な同意がある場合にのみ公開され、適切なアクセス制御で保護されなければなりません。MCP実装は不正なデータ送信を防ぎ、すべての対話でプライバシーを維持する必要があります。

- **ツールの安全性**：ツールを呼び出す前に明示的なユーザー同意が必須です。ユーザーは各ツールの機能を十分に理解し、意図しないまたは危険なツール実行を防ぐための堅牢なセキュリティ境界が設けられている必要があります。

これらの原則に従うことで、MCPはユーザーの信頼、プライバシー、安全性をすべてのプロトコル対話で維持します。

## コード例：主要コンポーネント

以下に、主要なMCPサーバーコンポーネントとツールの実装例をいくつかの人気プログラミング言語で示します。

### .NET例：ツール付きシンプルMCPサーバーの作成

以下は、カスタムツールを備えたシンプルなMCPサーバーを実装する実践的な.NETコード例です。ツールの定義と登録、リクエスト処理、Model Context Protocolを用いたサーバー接続の方法を紹介します。

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Java例

**免責事項**:  
本書類はAI翻訳サービス「Co-op Translator」（https://github.com/Azure/co-op-translator）を使用して翻訳されています。正確性には努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。原文の言語で記載されたオリジナルの文書が正式な情報源となります。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の利用により生じたいかなる誤解や誤訳についても、当方は責任を負いかねます。