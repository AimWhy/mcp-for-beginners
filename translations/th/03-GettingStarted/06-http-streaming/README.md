<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-13T20:41:33+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "th"
}
-->
# การสตรีม HTTPS ด้วยโปรโตคอล Model Context Protocol (MCP)

บทนี้เป็นคู่มือครบถ้วนสำหรับการใช้งานสตรีมมิ่งที่ปลอดภัย ขยายตัวได้ และเรียลไทม์ด้วย Model Context Protocol (MCP) ผ่าน HTTPS ครอบคลุมแรงจูงใจในการสตรีม กลไกการขนส่งที่มีให้ใช้งาน วิธีการใช้งาน HTTP แบบสตรีมใน MCP แนวทางปฏิบัติด้านความปลอดภัย การย้ายจาก SSE และคำแนะนำเชิงปฏิบัติสำหรับการสร้างแอปพลิเคชัน MCP ที่รองรับสตรีมมิ่งด้วยตัวเอง

## กลไกการขนส่งและการสตรีมใน MCP

ส่วนนี้จะอธิบายกลไกการขนส่งต่าง ๆ ที่มีใน MCP และบทบาทของพวกมันในการเปิดใช้งานความสามารถสตรีมมิ่งสำหรับการสื่อสารแบบเรียลไทม์ระหว่างไคลเอนต์และเซิร์ฟเวอร์

### กลไกการขนส่งคืออะไร?

กลไกการขนส่งหมายถึงวิธีการแลกเปลี่ยนข้อมูลระหว่างไคลเอนต์และเซิร์ฟเวอร์ MCP รองรับประเภทการขนส่งหลายแบบเพื่อให้เหมาะกับสภาพแวดล้อมและความต้องการที่แตกต่างกัน:

- **stdio**: การรับส่งข้อมูลมาตรฐาน เหมาะสำหรับเครื่องมือที่ทำงานในเครื่องและ CLI ง่ายแต่ไม่เหมาะกับเว็บหรือคลาวด์
- **SSE (Server-Sent Events)**: ให้เซิร์ฟเวอร์ส่งอัปเดตเรียลไทม์ไปยังไคลเอนต์ผ่าน HTTP เหมาะกับเว็บ UI แต่มีข้อจำกัดด้านการขยายตัวและความยืดหยุ่น
- **Streamable HTTP**: การขนส่งสตรีมมิ่งผ่าน HTTP แบบสมัยใหม่ รองรับการแจ้งเตือนและขยายตัวได้ดีกว่า แนะนำสำหรับการใช้งานในสภาพแวดล้อมการผลิตและคลาวด์ส่วนใหญ่

### ตารางเปรียบเทียบ

ดูตารางเปรียบเทียบด้านล่างเพื่อเข้าใจความแตกต่างระหว่างกลไกการขนส่งเหล่านี้:

| การขนส่ง         | อัปเดตเรียลไทม์ | สตรีมมิ่ง | การขยายตัว | กรณีการใช้งาน           |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | ไม่               | ไม่        | ต่ำ          | เครื่องมือ CLI ในเครื่อง |
| SSE               | ใช่              | ใช่       | ปานกลาง     | เว็บ, อัปเดตเรียลไทม์  |
| Streamable HTTP   | ใช่              | ใช่       | สูง          | คลาวด์, หลายไคลเอนต์   |

> **Tip:** การเลือกกลไกการขนส่งที่เหมาะสมส่งผลต่อประสิทธิภาพ การขยายตัว และประสบการณ์ผู้ใช้ **Streamable HTTP** เป็นตัวเลือกที่แนะนำสำหรับแอปพลิเคชันสมัยใหม่ที่ต้องการขยายตัวและพร้อมใช้งานบนคลาวด์

โปรดสังเกตกลไก stdio และ SSE ที่ได้แนะนำในบทก่อนหน้า และ Streamable HTTP คือกลไกที่ครอบคลุมในบทนี้

## การสตรีม: แนวคิดและแรงจูงใจ

การเข้าใจแนวคิดพื้นฐานและแรงจูงใจเบื้องหลังการสตรีมเป็นสิ่งสำคัญสำหรับการสร้างระบบสื่อสารเรียลไทม์ที่มีประสิทธิภาพ

**การสตรีม** คือเทคนิคในโปรแกรมเครือข่ายที่อนุญาตให้ส่งและรับข้อมูลเป็นส่วนเล็ก ๆ ที่จัดการได้ หรือเป็นลำดับของเหตุการณ์ แทนที่จะรอให้ข้อมูลทั้งหมดพร้อมก่อน เหมาะอย่างยิ่งสำหรับ:

- ไฟล์หรือชุดข้อมูลขนาดใหญ่
- อัปเดตเรียลไทม์ (เช่น แชท, แถบแสดงความคืบหน้า)
- การคำนวณที่ใช้เวลานานที่ต้องการแจ้งผู้ใช้ตลอดเวลา

นี่คือสิ่งที่ควรรู้เกี่ยวกับการสตรีมในภาพรวม:

- ข้อมูลถูกส่งอย่างต่อเนื่อง ไม่ใช่ทั้งหมดในครั้งเดียว
- ไคลเอนต์สามารถประมวลผลข้อมูลทันทีที่ได้รับ
- ลดความรู้สึกหน่วงเวลาและเพิ่มประสบการณ์ผู้ใช้

### ทำไมต้องใช้การสตรีม?

เหตุผลในการใช้การสตรีมมีดังนี้:

- ผู้ใช้ได้รับข้อมูลตอบกลับทันที ไม่ใช่แค่ตอนจบ
- เปิดโอกาสให้แอปเรียลไทม์และ UI ที่ตอบสนองได้ดี
- ใช้ทรัพยากรเครือข่ายและคอมพิวเตอร์ได้อย่างมีประสิทธิภาพมากขึ้น

### ตัวอย่างง่าย ๆ: เซิร์ฟเวอร์และไคลเอนต์ HTTP Streaming

นี่คือตัวอย่างง่าย ๆ ของการใช้งานสตรีมมิ่ง:

<details>
<summary>Python</summary>

**เซิร์ฟเวอร์ (Python, ใช้ FastAPI และ StreamingResponse):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**ไคลเอนต์ (Python, ใช้ requests):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

ตัวอย่างนี้แสดงให้เห็นเซิร์ฟเวอร์ส่งข้อความชุดหนึ่งไปยังไคลเอนต์ทันทีที่พร้อม แทนที่จะรอให้ข้อความทั้งหมดพร้อมก่อน

**วิธีการทำงาน:**
- เซิร์ฟเวอร์ส่งข้อความแต่ละข้อความทันทีที่พร้อม
- ไคลเอนต์รับและแสดงข้อความแต่ละส่วนทันทีที่มาถึง

**ข้อกำหนด:**
- เซิร์ฟเวอร์ต้องใช้การตอบสนองแบบสตรีม (เช่น `StreamingResponse` ใน FastAPI)
- ไคลเอนต์ต้องประมวลผลการตอบสนองเป็นสตรีม (`stream=True` ใน requests)
- Content-Type มักเป็น `text/event-stream` หรือ `application/octet-stream`

</details>

<details>
<summary>Java</summary>

**เซิร์ฟเวอร์ (Java, ใช้ Spring Boot และ Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ไคลเอนต์ (Java, ใช้ Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**หมายเหตุการใช้งาน Java:**
- ใช้สแตก reactive ของ Spring Boot กับ `Flux` สำหรับสตรีมมิ่ง
- `ServerSentEvent` ให้การสตรีมเหตุการณ์ที่มีโครงสร้างพร้อมประเภทเหตุการณ์
- `WebClient` กับ `bodyToFlux()` ช่วยให้รับสตรีมแบบ reactive
- `delayElements()` จำลองเวลาประมวลผลระหว่างเหตุการณ์
- เหตุการณ์สามารถมีประเภท (`info`, `result`) เพื่อการจัดการที่ดีขึ้นในไคลเอนต์

</details>

### การเปรียบเทียบ: การสตรีมแบบคลาสสิกกับ MCP Streaming

ความแตกต่างระหว่างการสตรีมแบบ "คลาสสิก" กับ MCP Streaming สามารถแสดงได้ดังนี้:

| คุณสมบัติ               | การสตรีม HTTP แบบคลาสสิก       | MCP Streaming (การแจ้งเตือน)       |
|------------------------|-------------------------------|-------------------------------------|
| การตอบสนองหลัก         | แบ่งเป็นชิ้น (Chunked)         | ตอบสนองครั้งเดียวตอนจบ             |
| การอัปเดตความคืบหน้า | ส่งเป็นชิ้นข้อมูล              | ส่งเป็นการแจ้งเตือน                |
| ความต้องการของไคลเอนต์ | ต้องประมวลผลสตรีม             | ต้องมีตัวจัดการข้อความ             |
| กรณีการใช้งาน          | ไฟล์ใหญ่, สตรีมโทเค็น AI      | ความคืบหน้า, บันทึก, ฟีดแบ็กเรียลไทม์ |

### ความแตกต่างที่สำคัญ

นอกจากนี้ยังมีความแตกต่างสำคัญอื่น ๆ ดังนี้:

- **รูปแบบการสื่อสาร:**
   - การสตรีม HTTP แบบคลาสสิก: ใช้การเข้ารหัสแบบ chunked เพื่อส่งข้อมูลเป็นชิ้น
   - MCP Streaming: ใช้ระบบแจ้งเตือนที่มีโครงสร้างด้วยโปรโตคอล JSON-RPC

- **รูปแบบข้อความ:**
   - HTTP แบบคลาสสิก: ข้อความธรรมดาเป็นชิ้น ๆ พร้อมขึ้นบรรทัดใหม่
   - MCP: วัตถุ LoggingMessageNotification ที่มีเมตาดาต้า

- **การใช้งานไคลเอนต์:**
   - HTTP แบบคลาสสิก: ไคลเอนต์ง่าย ๆ ที่ประมวลผลการตอบสนองแบบสตรีม
   - MCP: ไคลเอนต์ที่ซับซ้อนขึ้น มีตัวจัดการข้อความเพื่อประมวลผลข้อความประเภทต่าง ๆ

- **การอัปเดตความคืบหน้า:**
   - HTTP แบบคลาสสิก: ความคืบหน้าเป็นส่วนหนึ่งของสตรีมการตอบสนองหลัก
   - MCP: ความคืบหน้าส่งผ่านข้อความแจ้งเตือนแยกต่างหาก ขณะที่การตอบสนองหลักส่งตอนจบ

### คำแนะนำ

เราขอแนะนำสิ่งต่อไปนี้เมื่อต้องเลือกใช้งานระหว่างการสตรีมแบบคลาสสิก (เช่น จุดเชื่อมต่อ `/stream` ที่แสดงไว้ข้างต้น) กับการสตรีมผ่าน MCP

- **สำหรับความต้องการสตรีมง่าย ๆ:** การสตรีม HTTP แบบคลาสสิกง่ายต่อการใช้งานและเพียงพอสำหรับความต้องการพื้นฐาน

- **สำหรับแอปพลิเคชันที่ซับซ้อนและโต้ตอบได้:** MCP Streaming ให้แนวทางที่มีโครงสร้างมากขึ้น พร้อมเมตาดาต้าที่สมบูรณ์และแยกการแจ้งเตือนกับผลลัพธ์สุดท้ายออกจากกัน

- **สำหรับแอป AI:** ระบบแจ้งเตือนของ MCP มีประโยชน์มากสำหรับงาน AI ที่ใช้เวลานานซึ่งต้องการแจ้งความคืบหน้าให้ผู้ใช้ทราบ

## การสตรีมใน MCP

ตอนนี้คุณได้เห็นคำแนะนำและการเปรียบเทียบระหว่างการสตรีมแบบคลาสสิกกับ MCP แล้ว เรามาดูรายละเอียดว่าคุณจะใช้การสตรีมใน MCP ได้อย่างไร

การเข้าใจวิธีการทำงานของการสตรีมในกรอบ MCP เป็นสิ่งจำเป็นสำหรับการสร้างแอปที่ตอบสนองและให้ข้อมูลย้อนกลับแบบเรียลไทม์แก่ผู้ใช้ในระหว่างการทำงานที่ใช้เวลานาน

ใน MCP การสตรีมไม่ได้หมายถึงการส่งการตอบสนองหลักเป็นชิ้น ๆ แต่เป็นการส่ง **การแจ้งเตือน (notifications)** ไปยังไคลเอนต์ในขณะที่เครื่องมือกำลังประมวลผลคำขอ การแจ้งเตือนเหล่านี้อาจรวมถึงการอัปเดตความคืบหน้า บันทึก หรือเหตุการณ์อื่น ๆ

### วิธีการทำงาน

ผลลัพธ์หลักยังคงส่งเป็นการตอบสนองครั้งเดียว แต่การแจ้งเตือนสามารถส่งเป็นข้อความแยกต่างหากในระหว่างการประมวลผลเพื่ออัปเดตไคลเอนต์แบบเรียลไทม์ ไคลเอนต์ต้องสามารถจัดการและแสดงการแจ้งเตือนเหล่านี้ได้

## การแจ้งเตือนคืออะไร?

เราใช้คำว่า "การแจ้งเตือน" หมายถึงอะไรในบริบทของ MCP?

การแจ้งเตือนคือข้อความที่ส่งจากเซิร์ฟเวอร์ไปยังไคลเอนต์เพื่อแจ้งความคืบหน้า สถานะ หรือเหตุการณ์อื่น ๆ ในระหว่างการทำงานที่ใช้เวลานาน การแจ้งเตือนช่วยเพิ่มความโปร่งใสและประสบการณ์ผู้ใช้

ตัวอย่างเช่น ไคลเอนต์ควรส่งการแจ้งเตือนเมื่อการจับมือเริ่มต้นกับเซิร์ฟเวอร์เสร็จสิ้น

การแจ้งเตือนมีลักษณะเป็นข้อความ JSON ดังนี้:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

การแจ้งเตือนอยู่ภายใต้หัวข้อใน MCP ที่เรียกว่า ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging)

เพื่อให้ระบบ logging ทำงาน เซิร์ฟเวอร์ต้องเปิดใช้งานฟีเจอร์/ความสามารถนี้ดังนี้:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ขึ้นอยู่กับ SDK ที่ใช้ การเปิดใช้งาน logging อาจเปิดโดยอัตโนมัติ หรือคุณอาจต้องเปิดใช้งานในคอนฟิกเซิร์ฟเวอร์ด้วยตัวเอง

มีประเภทการแจ้งเตือนต่าง ๆ ดังนี้:

| ระดับ       | คำอธิบาย                      | ตัวอย่างการใช้งาน              |
|-------------|-------------------------------|-------------------------------|
| debug       | ข้อมูลสำหรับดีบักละเอียด      | จุดเข้า/ออกฟังก์ชัน           |
| info        | ข้อความข้อมูลทั่วไป           | อัปเดตความคืบหน้าการทำงาน    |
| notice      | เหตุการณ์ปกติแต่สำคัญ         | การเปลี่ยนแปลงการตั้งค่า      |
| warning     | สถานะเตือน                   | การใช้ฟีเจอร์ที่เลิกใช้แล้ว    |
| error       | สถานะข้อผิดพลาด              | การทำงานล้มเหลว               |
| critical    | สถานะวิกฤต                   | ความล้มเหลวของส่วนประกอบระบบ |
| alert       | ต้องดำเนินการทันที           | ตรวจพบข้อมูลเสียหาย          |
| emergency   | ระบบไม่สามารถใช้งานได้        | ระบบล่มทั้งหมด                |

## การใช้งานการแจ้งเตือนใน MCP

เพื่อใช้งานการแจ้งเตือนใน MCP คุณต้องตั้งค่าทั้งฝั่งเซิร์ฟเวอร์และไคลเอนต์ให้รองรับการอัปเดตแบบเรียลไทม์ ซึ่งช่วยให้แอปของคุณสามารถให้ข้อมูลตอบกลับทันทีแก่ผู้ใช้ในระหว่างการทำงานที่ใช้เวลานาน

### ฝั่งเซิร์ฟเวอร์: การส่งการแจ้งเตือน

เริ่มจากฝั่งเซิร์ฟเวอร์ ใน MCP คุณกำหนดเครื่องมือที่สามารถส่งการแจ้งเตือนในขณะประมวลผลคำขอ เซิร์ฟเวอร์ใช้วัตถุ context (โดยปกติคือ `ctx`) เพื่อส่งข้อความไปยังไคลเอนต์

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

ในตัวอย่างข้างต้น เครื่องมือ `process_files` ส่งการแจ้งเตือนสามครั้งไปยังไคลเอนต์ในขณะที่ประมวลผลแต่ละไฟล์ เมธอด `ctx.info()` ใช้ส่งข้อความข้อมูล

</details>

นอกจากนี้ เพื่อเปิดใช้งานการแจ้งเตือน ให้แน่ใจว่าเซิร์ฟเวอร์ของคุณใช้การขนส่งแบบสตรีม (เช่น `streamable-http`) และไคลเอนต์ของคุณมีตัวจัดการข้อความเพื่อประมวลผลการแจ้งเตือน นี่คือตัวอย่างการตั้งค่าเซิร์ฟเวอร์ให้ใช้การขนส่ง `streamable-http`:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

ในตัวอย่าง .NET นี้ เครื่องมือ `ProcessFiles` ถูกตกแต่งด้วยแอตทริบิวต์ `Tool` และส่งการแจ้งเตือนสามครั้งไปยังไคลเอนต์ในขณะที่ประมวลผลแต่ละไฟล์ เมธอด `ctx.Info()` ใช้ส่งข้อความข้อมูล

เพื่อเปิดใช้งานการแจ้งเตือนในเซิร์ฟเวอร์ MCP ของคุณ ให้แน่ใจว่าใช้การขนส่งแบบสตรีม:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### ฝั่งไคลเอนต์: การรับการแจ้งเตือน

ไคลเอนต์ต้องมีตัวจัดการข้อความเพื่อประมวลผลและแสดงการแจ้งเตือนทันทีที่ได้รับ

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

ในโค้ดข้างต้น ฟังก์ชัน `message_handler` ตรวจสอบว่าข้อความที่เข้ามาเป็นการแจ้งเตือนหรือไม่ หากใช่จะแสดงข้อความแจ้งเตือน มิฉะนั้นจะประมวลผลเป็นข้อความเซิร์ฟเวอร์ปกติ นอกจากนี้สังเกตว่า `ClientSession` ถูกสร้างขึ้นพร้อมกับ `message_handler` เพื่อจัดการการแจ้งเตือนที่เข้ามา

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

ในตัวอย่าง .NET นี้ ฟังก์ชัน `MessageHandler` ตรวจสอบว่าข้อความที่เข้ามาเป็นการแจ้งเตือนหรือไม่ หากใช่จะแสดงข้อความแจ้งเตือน มิฉะนั้นจะประมวลผลเป็นข้อความเซิร์ฟเวอร์ปกติ `ClientSession` ถูกสร้างขึ้นพร้อมตัวจัดการข้อความผ่าน `ClientSessionOptions`

</details>

เพื่อเปิดใช้งานการแจ้งเตือน ให้แน่ใจว่าเซิร์ฟเวอร์ของคุณใช้การขนส่งแบบสตรีม (เช่น `streamable-http`) และไคลเอนต์มีตัวจัดการข้อความเพื่อประมวลผลการแจ้งเตือน

## การแจ้งเตือนความคืบหน้าและสถานการณ์ใช้งาน

ส่วนนี้อธิบายแนวคิดของการแจ้งเตือนความคืบหน้าใน MCP ว่าทำไมจึงสำคัญ และวิธีการใช้งานผ่าน Streamable HTTP พร้อมแบบฝึกหัดเชิงปฏิบัติเพื่อเสริมความเข้าใจ

การแจ้งเตือนความคืบหน้าเป็นข้อความเรียลไทม์ที่ส่งจากเซิร์ฟเวอร์ไปยังไคลเอนต์ในระหว่างการทำงานที่ใช้เวลานาน แทนที่จะรอจนกระบวนการทั้งหมดเสร็จสิ้น เซิร์ฟเวอร์จะอัปเดตสถานะปัจจุบันให้ไคลเอนต์ทราบอย่างต่อเนื่อง ช่วยเพิ่มความโปร่งใส ประ

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**ตัวอย่างฝั่ง Client:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## ข้อควรพิจารณาด้านความปลอดภัย

เมื่อพัฒนาเซิร์ฟเวอร์ MCP ที่ใช้การสื่อสารผ่าน HTTP ความปลอดภัยจะเป็นเรื่องสำคัญที่ต้องให้ความใส่ใจอย่างรอบคอบในหลายช่องทางการโจมตีและกลไกการป้องกันต่างๆ

### ภาพรวม

ความปลอดภัยเป็นสิ่งจำเป็นเมื่อเปิดเผยเซิร์ฟเวอร์ MCP ผ่าน HTTP การใช้ Streamable HTTP จะเพิ่มช่องทางการโจมตีใหม่ๆ และต้องตั้งค่าการใช้งานอย่างระมัดระวัง

### ประเด็นสำคัญ
- **การตรวจสอบ Origin Header**: ควรตรวจสอบค่า `Origin` เสมอเพื่อป้องกันการโจมตีแบบ DNS rebinding
- **การผูกกับ localhost**: สำหรับการพัฒนาในเครื่อง ควรผูกเซิร์ฟเวอร์กับ `localhost` เพื่อไม่ให้เปิดเผยสู่เครือข่ายสาธารณะ
- **การยืนยันตัวตน**: ควรใช้ระบบยืนยันตัวตน (เช่น API keys, OAuth) ในการใช้งานจริง
- **CORS**: ตั้งค่านโยบาย Cross-Origin Resource Sharing (CORS) เพื่อจำกัดการเข้าถึง
- **HTTPS**: ใช้ HTTPS ในสภาพแวดล้อมจริงเพื่อเข้ารหัสข้อมูลที่ส่งผ่าน

### แนวทางปฏิบัติที่ดีที่สุด
- อย่าเชื่อถือคำขอที่เข้ามาโดยไม่ตรวจสอบ
- บันทึกและตรวจสอบการเข้าถึงและข้อผิดพลาดทั้งหมด
- อัปเดตไลบรารีและส่วนประกอบอย่างสม่ำเสมอเพื่อแก้ไขช่องโหว่ด้านความปลอดภัย

### ความท้าทาย
- การหาจุดสมดุลระหว่างความปลอดภัยกับความสะดวกในการพัฒนา
- การรับรองความเข้ากันได้กับสภาพแวดล้อมของลูกค้าหลากหลายรูปแบบ


## การอัปเกรดจาก SSE เป็น Streamable HTTP

สำหรับแอปพลิเคชันที่ใช้งาน Server-Sent Events (SSE) อยู่ในปัจจุบัน การย้ายไปใช้ Streamable HTTP จะช่วยเพิ่มความสามารถและความยั่งยืนในระยะยาวสำหรับการใช้งาน MCP ของคุณ

### ทำไมต้องอัปเกรด?

มีเหตุผลสำคัญสองประการที่ควรอัปเกรดจาก SSE เป็น Streamable HTTP:

- Streamable HTTP มีความสามารถในการขยายตัวที่ดีกว่า รองรับความเข้ากันได้มากขึ้น และรองรับการแจ้งเตือนที่หลากหลายกว่าการใช้ SSE
- เป็นวิธีการสื่อสารที่แนะนำสำหรับแอป MCP ใหม่ๆ

### ขั้นตอนการย้าย

นี่คือวิธีการย้ายจาก SSE ไปยัง Streamable HTTP ในแอป MCP ของคุณ:

- **อัปเดตโค้ดฝั่งเซิร์ฟเวอร์** ให้ใช้ `transport="streamable-http"` ใน `mcp.run()`
- **อัปเดตโค้ดฝั่งลูกค้า** ให้ใช้ `streamablehttp_client` แทน SSE client
- **เพิ่มตัวจัดการข้อความ** ในฝั่งลูกค้าเพื่อประมวลผลการแจ้งเตือน
- **ทดสอบความเข้ากันได้** กับเครื่องมือและเวิร์กโฟลว์ที่มีอยู่

### การรักษาความเข้ากันได้

แนะนำให้รักษาความเข้ากันได้กับลูกค้า SSE เดิมในระหว่างการย้าย โดยมีแนวทางดังนี้:

- สามารถรองรับทั้ง SSE และ Streamable HTTP โดยเปิดให้บริการทั้งสองแบบบน endpoint ที่ต่างกัน
- ค่อยๆ ย้ายลูกค้าไปยังวิธีการสื่อสารแบบใหม่

### ความท้าทาย

ควรแก้ไขปัญหาต่อไปนี้ในระหว่างการย้าย:

- การอัปเดตลูกค้าทุกตัวให้รองรับวิธีการใหม่
- การจัดการความแตกต่างในการส่งมอบการแจ้งเตือน


## ข้อควรพิจารณาด้านความปลอดภัย

ความปลอดภัยควรเป็นสิ่งที่ให้ความสำคัญสูงสุดเมื่อพัฒนาเซิร์ฟเวอร์ใดๆ โดยเฉพาะอย่างยิ่งเมื่อใช้การสื่อสารผ่าน HTTP เช่น Streamable HTTP ใน MCP

เมื่อพัฒนาเซิร์ฟเวอร์ MCP ที่ใช้การสื่อสารผ่าน HTTP ความปลอดภัยจะเป็นเรื่องสำคัญที่ต้องให้ความใส่ใจอย่างรอบคอบในหลายช่องทางการโจมตีและกลไกการป้องกันต่างๆ

### ภาพรวม

ความปลอดภัยเป็นสิ่งจำเป็นเมื่อเปิดเผยเซิร์ฟเวอร์ MCP ผ่าน HTTP การใช้ Streamable HTTP จะเพิ่มช่องทางการโจมตีใหม่ๆ และต้องตั้งค่าการใช้งานอย่างระมัดระวัง

นี่คือข้อควรพิจารณาด้านความปลอดภัยที่สำคัญ:

- **การตรวจสอบ Origin Header**: ควรตรวจสอบค่า `Origin` เสมอเพื่อป้องกันการโจมตีแบบ DNS rebinding
- **การผูกกับ localhost**: สำหรับการพัฒนาในเครื่อง ควรผูกเซิร์ฟเวอร์กับ `localhost` เพื่อไม่ให้เปิดเผยสู่เครือข่ายสาธารณะ
- **การยืนยันตัวตน**: ควรใช้ระบบยืนยันตัวตน (เช่น API keys, OAuth) ในการใช้งานจริง
- **CORS**: ตั้งค่านโยบาย Cross-Origin Resource Sharing (CORS) เพื่อจำกัดการเข้าถึง
- **HTTPS**: ใช้ HTTPS ในสภาพแวดล้อมจริงเพื่อเข้ารหัสข้อมูลที่ส่งผ่าน

### แนวทางปฏิบัติที่ดีที่สุด

นอกจากนี้ นี่คือแนวทางปฏิบัติที่ดีที่สุดเมื่อพัฒนาด้านความปลอดภัยในเซิร์ฟเวอร์ MCP แบบสตรีมมิ่ง:

- อย่าเชื่อถือคำขอที่เข้ามาโดยไม่ตรวจสอบ
- บันทึกและตรวจสอบการเข้าถึงและข้อผิดพลาดทั้งหมด
- อัปเดตไลบรารีและส่วนประกอบอย่างสม่ำเสมอเพื่อแก้ไขช่องโหว่ด้านความปลอดภัย

### ความท้าทาย

คุณจะพบกับความท้าทายบางประการเมื่อพัฒนาด้านความปลอดภัยในเซิร์ฟเวอร์ MCP แบบสตรีมมิ่ง:

- การหาจุดสมดุลระหว่างความปลอดภัยกับความสะดวกในการพัฒนา
- การรับรองความเข้ากันได้กับสภาพแวดล้อมของลูกค้าหลากหลายรูปแบบ

### แบบฝึกหัด: สร้างแอป MCP แบบสตรีมมิ่งของคุณเอง

**สถานการณ์:**
สร้างเซิร์ฟเวอร์และลูกค้า MCP ที่เซิร์ฟเวอร์จะประมวลผลรายการของไอเท็ม (เช่น ไฟล์หรือเอกสาร) และส่งการแจ้งเตือนสำหรับแต่ละไอเท็มที่ประมวลผล ลูกค้าควรแสดงการแจ้งเตือนแต่ละรายการทันทีที่ได้รับ

**ขั้นตอน:**

1. สร้างเครื่องมือเซิร์ฟเวอร์ที่ประมวลผลรายการและส่งการแจ้งเตือนสำหรับแต่ละไอเท็ม
2. สร้างลูกค้าที่มีตัวจัดการข้อความเพื่อแสดงการแจ้งเตือนแบบเรียลไทม์
3. ทดสอบการทำงานโดยรันทั้งเซิร์ฟเวอร์และลูกค้า และสังเกตการแจ้งเตือน

[Solution](./solution/README.md)

## อ่านเพิ่มเติม & ก้าวต่อไป

เพื่อเดินหน้าต่อกับ MCP แบบสตรีมมิ่งและขยายความรู้ของคุณ ส่วนนี้จะรวบรวมแหล่งข้อมูลเพิ่มเติมและแนะนำขั้นตอนถัดไปสำหรับการสร้างแอปพลิเคชันที่ซับซ้อนขึ้น

### อ่านเพิ่มเติม

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### ก้าวต่อไป

- ลองสร้างเครื่องมือ MCP ที่ซับซ้อนขึ้นโดยใช้การสตรีมมิ่งสำหรับการวิเคราะห์แบบเรียลไทม์ แชท หรือการแก้ไขร่วมกัน
- สำรวจการผสาน MCP สตรีมมิ่งกับเฟรมเวิร์ก frontend (React, Vue, ฯลฯ) เพื่ออัปเดต UI แบบสด
- ถัดไป: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษาอัตโนมัติ [Co-op Translator](https://github.com/Azure/co-op-translator) แม้เราจะพยายามให้ความถูกต้องสูงสุด แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่ถูกต้อง เอกสารต้นฉบับในภาษาต้นทางถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ ขอแนะนำให้ใช้บริการแปลโดยผู้เชี่ยวชาญมนุษย์ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความผิดใด ๆ ที่เกิดจากการใช้การแปลนี้