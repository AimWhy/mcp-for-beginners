<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T17:41:00+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "ur"
}
-->
# HTTPS اسٹریمنگ ماڈل کانٹیکسٹ پروٹوکول (MCP) کے ساتھ

یہ باب HTTPS کے ذریعے ماڈل کانٹیکسٹ پروٹوکول (MCP) کے ساتھ محفوظ، قابل توسیع، اور حقیقی وقت کی اسٹریمنگ کو نافذ کرنے کے لیے جامع رہنمائی فراہم کرتا ہے۔ اس میں اسٹریمنگ کی ضرورت، دستیاب ٹرانسپورٹ میکانزم، MCP میں اسٹریمنگ HTTP کو کیسے نافذ کیا جائے، سیکیورٹی کی بہترین مشقیں، SSE سے مائیگریشن، اور اپنے MCP اسٹریمنگ ایپلیکیشنز بنانے کے عملی مشورے شامل ہیں۔

## MCP میں ٹرانسپورٹ میکانزم اور اسٹریمنگ

یہ سیکشن MCP میں دستیاب مختلف ٹرانسپورٹ میکانزم اور ان کے کلائنٹس اور سرورز کے درمیان حقیقی وقت کی مواصلات کے لیے اسٹریمنگ کی صلاحیتوں کو فعال کرنے میں ان کے کردار کا جائزہ لیتا ہے۔

### ٹرانسپورٹ میکانزم کیا ہے؟

ٹرانسپورٹ میکانزم یہ طے کرتا ہے کہ کلائنٹ اور سرور کے درمیان ڈیٹا کیسے تبادلہ کیا جاتا ہے۔ MCP مختلف ماحول اور ضروریات کے مطابق متعدد ٹرانسپورٹ اقسام کی حمایت کرتا ہے:

- **stdio**: معیاری ان پٹ/آؤٹ پٹ، مقامی اور CLI پر مبنی ٹولز کے لیے موزوں۔ سادہ لیکن ویب یا کلاؤڈ کے لیے مناسب نہیں۔
- **SSE (Server-Sent Events)**: سرورز کو HTTP کے ذریعے کلائنٹس کو حقیقی وقت کی اپ ڈیٹس بھیجنے کی اجازت دیتا ہے۔ ویب یوزر انٹرفیس کے لیے اچھا، لیکن توسیع پذیری اور لچک میں محدود۔
- **Streamable HTTP**: جدید HTTP پر مبنی اسٹریمنگ ٹرانسپورٹ، نوٹیفیکیشنز اور بہتر توسیع پذیری کی حمایت کرتا ہے۔ زیادہ تر پروڈکشن اور کلاؤڈ کے منظرناموں کے لیے تجویز کردہ۔

### موازنہ جدول

نیچے دیے گئے موازنہ جدول کو دیکھیں تاکہ ان ٹرانسپورٹ میکانزم کے درمیان فرق کو سمجھ سکیں:

| ٹرانسپورٹ         | حقیقی وقت کی اپ ڈیٹس | اسٹریمنگ | توسیع پذیری | استعمال کا کیس           |
|-------------------|---------------------|----------|-------------|-------------------------|
| stdio             | نہیں                | نہیں     | کم          | مقامی CLI ٹولز          |
| SSE               | ہاں                 | ہاں      | درمیانہ     | ویب، حقیقی وقت کی اپ ڈیٹس|
| Streamable HTTP   | ہاں                 | ہاں      | زیادہ       | کلاؤڈ، کثیر کلائنٹ     |

> **[!TIP]:** درست ٹرانسپورٹ کا انتخاب کارکردگی، توسیع پذیری، اور صارف کے تجربے پر اثر انداز ہوتا ہے۔ **Streamable HTTP** جدید، قابل توسیع، اور کلاؤڈ کے لیے تیار ایپلیکیشنز کے لیے تجویز کیا جاتا ہے۔

نوٹ کریں کہ stdio اور SSE ٹرانسپورٹس آپ کو پچھلے ابواب میں دکھائے گئے تھے اور اس باب میں Streamable HTTP کو کور کیا گیا ہے۔

## اسٹریمنگ: تصورات اور محرکات

اسٹریمنگ کے بنیادی تصورات اور محرکات کو سمجھنا مؤثر حقیقی وقت کی مواصلات کے نظام کو نافذ کرنے کے لیے ضروری ہے۔

**اسٹریمنگ** نیٹ ورک پروگرامنگ کی ایک تکنیک ہے جو ڈیٹا کو چھوٹے، قابل انتظام حصوں یا واقعات کی ترتیب کے طور پر بھیجنے اور وصول کرنے کی اجازت دیتی ہے، بجائے اس کے کہ پورا جواب تیار ہونے کا انتظار کیا جائے۔ یہ خاص طور پر مفید ہے:

- بڑے فائلز یا ڈیٹا سیٹس کے لیے۔
- حقیقی وقت کی اپ ڈیٹس (مثلاً چیٹ، پروگریس بار) کے لیے۔
- طویل مدتی حساب کتاب جہاں آپ صارف کو معلومات دیتے رہنا چاہتے ہیں۔

یہاں اسٹریمنگ کے بارے میں اعلی سطح پر جاننے والی باتیں ہیں:

- ڈیٹا بتدریج فراہم کیا جاتا ہے، ایک ساتھ نہیں۔
- کلائنٹ ڈیٹا کو جیسے ہی پہنچے پراسیس کر سکتا ہے۔
- محسوس شدہ تاخیر کو کم کرتا ہے اور صارف کے تجربے کو بہتر بناتا ہے۔

### اسٹریمنگ کیوں استعمال کریں؟

اسٹریمنگ استعمال کرنے کی وجوہات درج ذیل ہیں:

- صارفین کو فوری فیڈبیک ملتا ہے، صرف آخر میں نہیں۔
- حقیقی وقت کی ایپلیکیشنز اور جوابدہ یوزر انٹرفیسز کو فعال کرتا ہے۔
- نیٹ ورک اور کمپیوٹ وسائل کا زیادہ مؤثر استعمال۔

### سادہ مثال: HTTP اسٹریمنگ سرور اور کلائنٹ

یہاں ایک سادہ مثال ہے کہ اسٹریمنگ کو کیسے نافذ کیا جا سکتا ہے:

## Python

**سرور (Python، FastAPI اور StreamingResponse استعمال کرتے ہوئے):**

### Python

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**کلائنٹ (Python، requests استعمال کرتے ہوئے):**

### Python

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

یہ مثال دکھاتی ہے کہ سرور کلائنٹ کو پیغامات کی ایک سیریز بھیج رہا ہے جیسے ہی وہ دستیاب ہوتے ہیں، بجائے اس کے کہ تمام پیغامات تیار ہونے کا انتظار کرے۔

**یہ کیسے کام کرتا ہے:**
- سرور ہر پیغام کو جیسے ہی تیار ہو، بھیجتا ہے۔
- کلائنٹ ہر حصہ کو وصول کر کے پرنٹ کرتا ہے۔

**ضروریات:**
- سرور کو اسٹریمنگ ریسپانس استعمال کرنا چاہیے (مثلاً FastAPI میں `StreamingResponse`)۔
- کلائنٹ کو ریسپانس کو اسٹریمنگ کے طور پر پراسیس کرنا چاہیے (`stream=True` requests میں)۔
- Content-Type عام طور پر `text/event-stream` یا `application/octet-stream` ہوتا ہے۔

## Java

**سرور (Java، Spring Boot اور Server-Sent Events استعمال کرتے ہوئے):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**کلائنٹ (Java، Spring WebFlux WebClient استعمال کرتے ہوئے):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java نفاذ کے نوٹس:**
- Spring Boot کے reactive stack کے ساتھ `Flux` استعمال کرتا ہے اسٹریمنگ کے لیے
- `ServerSentEvent` ساختہ ایونٹ اسٹریمنگ فراہم کرتا ہے جس میں ایونٹ کی اقسام شامل ہیں
- `WebClient` کے ساتھ `bodyToFlux()` ریئیکٹو اسٹریمنگ کنزمپشن کو فعال کرتا ہے
- `delayElements()` ایونٹس کے درمیان پراسیسنگ وقت کی نقل کرتا ہے
- ایونٹس کی اقسام ہو سکتی ہیں (`info`, `result`) تاکہ کلائنٹ بہتر طریقے سے ہینڈل کر سکے

### موازنہ: کلاسیکی اسٹریمنگ بمقابلہ MCP اسٹریمنگ

کلاسیکی اسٹریمنگ اور MCP اسٹریمنگ کے درمیان فرق کو یوں دکھایا جا سکتا ہے:

| خصوصیت                | کلاسیکی HTTP اسٹریمنگ          | MCP اسٹریمنگ (نوٹیفیکیشنز)       |
|------------------------|-------------------------------|----------------------------------|
| مرکزی جواب             | چنکس میں                     | ایک بار، آخر میں                 |
| پروگریس اپ ڈیٹس       | ڈیٹا چنکس کے طور پر بھیجے جاتے ہیں | نوٹیفیکیشنز کے طور پر بھیجے جاتے ہیں |
| کلائنٹ کی ضروریات     | اسٹریمنگ کو پراسیس کرنا ضروری ہے | میسج ہینڈلر نافذ کرنا ضروری ہے    |
| استعمال کا کیس        | بڑی فائلز، AI ٹوکن اسٹریمز    | پروگریس، لاگز، حقیقی وقت کا فیڈبیک |

### کلیدی فرق

مزید برآں، یہاں کچھ کلیدی فرق ہیں:

- **مواصلاتی پیٹرن:**
   - کلاسیکی HTTP اسٹریمنگ: سادہ چنکڈ ٹرانسفر انکوڈنگ استعمال کرتا ہے ڈیٹا بھیجنے کے لیے
   - MCP اسٹریمنگ: JSON-RPC پروٹوکول کے ساتھ ساختہ نوٹیفیکیشن سسٹم استعمال کرتا ہے

- **میسج فارمیٹ:**
   - کلاسیکی HTTP: سادہ ٹیکسٹ چنکس نئی لائنز کے ساتھ
   - MCP: ساختہ LoggingMessageNotification آبجیکٹس میٹا ڈیٹا کے ساتھ

- **کلائنٹ نفاذ:**
   - کلاسیکی HTTP: سادہ کلائنٹ جو اسٹریمنگ ریسپانسز پراسیس کرتا ہے
   - MCP: زیادہ پیچیدہ کلائنٹ جس میں مختلف اقسام کے پیغامات پراسیس کرنے کے لیے میسج ہینڈلر ہوتا ہے

- **پروگریس اپ ڈیٹس:**
   - کلاسیکی HTTP: پروگریس مرکزی ریسپانس اسٹریم کا حصہ ہوتا ہے
   - MCP: پروگریس علیحدہ نوٹیفیکیشن میسجز کے ذریعے بھیجا جاتا ہے جبکہ مرکزی جواب آخر میں آتا ہے

### سفارشات

کچھ چیزیں ہم سفارش کرتے ہیں جب کلاسیکی اسٹریمنگ (جیسا کہ اوپر `/stream` اینڈپوائنٹ کے ذریعے دکھایا گیا) اور MCP اسٹریمنگ کے درمیان انتخاب کی بات آتی ہے:

- **سادہ اسٹریمنگ کی ضروریات کے لیے:** کلاسیکی HTTP اسٹریمنگ نافذ کرنا آسان ہے اور بنیادی اسٹریمنگ کی ضروریات کے لیے کافی ہے۔

- **پیچیدہ، انٹرایکٹو ایپلیکیشنز کے لیے:** MCP اسٹریمنگ ایک زیادہ ساختہ طریقہ فراہم کرتا ہے جس میں زیادہ میٹا ڈیٹا اور نوٹیفیکیشنز اور حتمی نتائج کے درمیان تفریق ہوتی ہے۔

- **AI ایپلیکیشنز کے لیے:** MCP کا نوٹیفیکیشن سسٹم طویل مدتی AI کاموں کے لیے خاص طور پر مفید ہے جہاں آپ صارفین کو پروگریس سے آگاہ رکھنا چاہتے ہیں۔

## MCP میں اسٹریمنگ

تو، آپ نے اب تک کلاسیکی اسٹریمنگ اور MCP اسٹریمنگ کے درمیان کچھ سفارشات اور موازنہ دیکھ لیے ہیں۔ آئیے تفصیل میں جانتے ہیں کہ آپ MCP میں اسٹریمنگ کو کیسے استعمال کر سکتے ہیں۔

MCP فریم ورک کے اندر اسٹریمنگ کیسے کام کرتی ہے یہ سمجھنا ضروری ہے تاکہ آپ ایسے جوابدہ ایپلیکیشنز بنا سکیں جو طویل مدتی آپریشنز کے دوران صارفین کو حقیقی وقت میں فیڈبیک فراہم کریں۔

MCP میں، اسٹریمنگ کا مطلب مرکزی جواب کو چنکس میں بھیجنا نہیں بلکہ درخواست کی پراسیسنگ کے دوران کلائنٹ کو **نوٹیفیکیشنز** بھیجنا ہے۔ یہ نوٹیفیکیشنز پروگریس اپ ڈیٹس، لاگز، یا دیگر ایونٹس شامل ہو سکتے ہیں۔

### یہ کیسے کام کرتا ہے

مرکزی نتیجہ اب بھی ایک واحد جواب کے طور پر بھیجا جاتا ہے۔ تاہم، پراسیسنگ کے دوران نوٹیفیکیشنز علیحدہ پیغامات کے طور پر بھیجے جا سکتے ہیں اور اس طرح کلائنٹ کو حقیقی وقت میں اپ ڈیٹ کیا جاتا ہے۔ کلائنٹ کو ان نوٹیفیکیشنز کو ہینڈل اور دکھانے کے قابل ہونا چاہیے۔

## نوٹیفیکیشن کیا ہے؟

ہم نے "نوٹیفیکیشن" کا ذکر کیا، MCP کے سیاق و سباق میں اس کا کیا مطلب ہے؟

نوٹیفیکیشن ایک پیغام ہے جو سرور سے کلائنٹ کو بھیجا جاتا ہے تاکہ طویل مدتی آپریشن کے دوران پروگریس، اسٹیٹس، یا دیگر ایونٹس کے بارے میں آگاہ کیا جا سکے۔ نوٹیفیکیشنز شفافیت اور صارف کے تجربے کو بہتر بناتی ہیں۔

مثال کے طور پر، کلائنٹ کو ایک نوٹیفیکیشن بھیجنی چاہیے جب سرور کے ساتھ ابتدائی ہینڈشیک مکمل ہو جائے۔

نوٹیفیکیشن ایک JSON پیغام کی شکل میں کچھ یوں دکھائی دیتی ہے:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

نوٹیفیکیشنز MCP میں ایک موضوع سے تعلق رکھتی ہیں جسے ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) کہا جاتا ہے۔

لاگنگ کو فعال کرنے کے لیے، سرور کو اسے فیچر/صلاحیت کے طور پر فعال کرنا پڑتا ہے، جیسا کہ نیچے دکھایا گیا ہے:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> استعمال شدہ SDK پر منحصر ہے، لاگنگ ڈیفالٹ میں فعال ہو سکتی ہے، یا آپ کو اسے اپنے سرور کی کنفیگریشن میں واضح طور پر فعال کرنا پڑ سکتا ہے۔

نوٹیفیکیشنز کی مختلف اقسام ہیں:

| سطح       | وضاحت                         | مثال کا استعمال               |
|-----------|-------------------------------|------------------------------|
| debug     | تفصیلی ڈیبگنگ معلومات         | فنکشن کے داخلے/خروج کے پوائنٹس |
| info      | عمومی معلوماتی پیغامات        | آپریشن کی پروگریس اپ ڈیٹس     |
| notice    | معمول کے لیکن اہم واقعات       | کنفیگریشن میں تبدیلیاں         |
| warning   | وارننگ کی حالتیں              | پرانی خصوصیات کا استعمال      |
| error     | خرابی کی حالتیں               | آپریشن کی ناکامیاں            |
| critical  | سنگین حالتیں                 | سسٹم کے اجزاء کی ناکامیاں      |
| alert     | فوری کارروائی ضروری ہے        | ڈیٹا کی کرپشن کا پتہ چلنا      |
| emergency | سسٹم ناقابل استعمال ہے        | مکمل سسٹم کی ناکامی           |

## MCP میں نوٹیفیکیشنز کا نفاذ

MCP میں نوٹیفیکیشنز کو نافذ کرنے کے لیے، آپ کو سرور اور کلائنٹ دونوں طرف حقیقی وقت کی اپ ڈیٹس کو ہینڈل کرنے کے لیے سیٹ اپ کرنا ہوگا۔ اس سے آپ کی ایپلیکیشن طویل مدتی آپریشنز کے دوران صارفین کو فوری فیڈبیک فراہم کر سکتی ہے۔

### سرور سائڈ: نوٹیفیکیشنز بھیجنا

آئیے سرور سائڈ سے شروع کرتے ہیں۔ MCP میں، آپ ایسے ٹولز ڈیفائن کرتے ہیں جو درخواست کی پراسیسنگ کے دوران نوٹیفیکیشنز بھیج سکتے ہیں۔ سرور کلائنٹ کو پیغامات بھیجنے کے لیے عام طور پر `ctx` کانٹیکسٹ آبجیکٹ استعمال کرتا ہے۔

### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

پچھلی مثال میں، `process_files` ٹول ہر فائل کی پراسیسنگ کے دوران کلائنٹ کو تین نوٹیفیکیشنز بھیجتا ہے۔ `ctx.info()` طریقہ معلوماتی پیغامات بھیجنے کے لیے استعمال ہوتا ہے۔

مزید برآں، نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ کا سرور اسٹریمنگ ٹرانسپورٹ (جیسے `streamable-http`) استعمال کر رہا ہے اور آپ کا کلائنٹ نوٹیفیکیشنز پراسیس کرنے کے لیے میسج ہینڈلر نافذ کرتا ہے۔ یہاں دکھایا گیا ہے کہ سرور کو `streamable-http` ٹرانسپورٹ استعمال کرنے کے لیے کیسے سیٹ اپ کیا جائے:

```python
mcp.run(transport="streamable-http")
```

### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

اس .NET مثال میں، `ProcessFiles` ٹول `Tool` ایٹریبیوٹ کے ساتھ سجا ہوا ہے اور ہر فائل کی پراسیسنگ کے دوران کلائنٹ کو تین نوٹیفیکیشنز بھیجتا ہے۔ `ctx.Info()` طریقہ معلوماتی پیغامات بھیجنے کے لیے استعمال ہوتا ہے۔

اپنے .NET MCP سرور میں نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ اسٹریمنگ ٹرانسپورٹ استعمال کر رہے ہیں:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### کلائنٹ سائڈ: نوٹیفیکیشنز وصول کرنا

کلائنٹ کو ایک میسج ہینڈلر نافذ کرنا چاہیے جو نوٹیفیکیشنز کو وصول کر کے پراسیس اور دکھائے۔

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

پچھلے کوڈ میں، `message_handler` فنکشن چیک کرتا ہے کہ آیا آنے والا پیغام نوٹیفیکیشن ہے۔ اگر ہے تو وہ نوٹیفیکیشن پرنٹ کرتا ہے؛ ورنہ اسے عام سرور پیغام کے طور پر پراسیس کرتا ہے۔ یہ بھی نوٹ کریں کہ `ClientSession` کو `message_handler` کے ساتھ انیشیئلائز کیا گیا ہے تاکہ آنے والی نوٹیفیکیشنز کو ہینڈل کیا جا سکے۔

### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

اس .NET مثال میں، `MessageHandler` فنکشن چیک کرتا ہے کہ آیا آنے والا پیغام نوٹیفیکیشن ہے۔ اگر ہے تو وہ نوٹیفیکیشن پرنٹ کرتا ہے؛ ورنہ اسے عام سرور پیغام کے طور پر پراسیس کرتا ہے۔ `ClientSession` کو `ClientSessionOptions` کے ذریعے میسج ہینڈلر کے ساتھ انیشیئلائز کیا گیا ہے۔

نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ کا سرور اسٹریمنگ ٹرانسپورٹ (جیسے `streamable-http`) استعمال کر رہا ہے اور آپ کا کلائنٹ نوٹیفیکیشنز پراسیس کرنے کے لیے میسج ہینڈلر نافذ کرتا ہے۔

## پروگریس نوٹیفیکیشنز اور منظرنامے

یہ سیکشن MCP میں پروگریس نوٹیفیکیشنز کے تصور، ان کی اہمیت، اور Streamable HTTP استعمال کرتے ہوئے انہیں کیسے نافذ کیا جائے، کی وضاحت کرتا ہے۔ آپ کو اپنی سمجھ کو مضبوط کرنے کے لیے ایک عملی مشق بھی ملے گی۔

پروگریس نوٹیفیکیشنز وہ حقیقی وقت کے پیغامات ہیں جو سرور طویل مدتی آپریشنز کے دوران کلائنٹ کو بھیجتا ہے۔ پورے عمل کے ختم ہونے کا انتظار کرنے کے بجائے، سرور کلائنٹ کو موجودہ اسٹیٹس کے بارے میں اپ ڈیٹ رکھتا ہے۔ اس سے شفافیت، صارف کے تجربے میں بہتری، اور ڈیبگنگ آسان ہوتی ہے۔

**مثال:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### پروگریس نوٹیفیکیشنز کیوں استعمال کریں؟

پروگریس نوٹیفیکیشنز کئی وجوہات کی بنا پر ضروری ہیں:

- **بہتر صارف تجربہ:** صارفین کام کی پیش رفت کو دیکھتے ہیں، صرف آخر میں نہیں۔
- **حقیقی وقت کا فیڈبیک:** کلائنٹس پروگری
### کیوں اپ گریڈ کریں؟

SSE سے Streamable HTTP پر اپ گریڈ کرنے کی دو اہم وجوہات ہیں:

- Streamable HTTP، SSE کے مقابلے میں بہتر اسکیل ایبلٹی، مطابقت، اور زیادہ جامع نوٹیفیکیشن سپورٹ فراہم کرتا ہے۔
- یہ نئے MCP ایپلیکیشنز کے لیے تجویز کردہ ٹرانسپورٹ ہے۔

### مائیگریشن کے مراحل

اپنی MCP ایپلیکیشنز میں SSE سے Streamable HTTP پر مائیگریٹ کرنے کا طریقہ درج ذیل ہے:

- **سرور کوڈ کو اپ ڈیٹ کریں** تاکہ `mcp.run()` میں `transport="streamable-http"` استعمال ہو۔
- **کلائنٹ کوڈ کو اپ ڈیٹ کریں** تاکہ SSE کلائنٹ کی جگہ `streamablehttp_client` استعمال ہو۔
- **کلائنٹ میں ایک میسج ہینڈلر نافذ کریں** جو نوٹیفیکیشنز کو پروسیس کرے۔
- **موجودہ ٹولز اور ورک فلو کے ساتھ مطابقت کی جانچ کریں**۔

### مطابقت کو برقرار رکھنا

مائیگریشن کے دوران موجودہ SSE کلائنٹس کے ساتھ مطابقت برقرار رکھنا تجویز کیا جاتا ہے۔ کچھ حکمت عملیاں یہ ہیں:

- آپ دونوں SSE اور Streamable HTTP کو مختلف اینڈ پوائنٹس پر چلا کر سپورٹ کر سکتے ہیں۔
- کلائنٹس کو آہستہ آہستہ نئے ٹرانسپورٹ کی طرف منتقل کریں۔

### چیلنجز

مائیگریشن کے دوران درج ذیل چیلنجز کا خیال رکھیں:

- تمام کلائنٹس کو اپ ڈیٹ کرنا یقینی بنائیں
- نوٹیفیکیشن کی ترسیل میں فرق کو سنبھالنا

## سیکیورٹی کے پہلو

کسی بھی سرور کو نافذ کرتے وقت، خاص طور پر MCP میں HTTP پر مبنی ٹرانسپورٹس جیسے Streamable HTTP استعمال کرتے ہوئے، سیکیورٹی کو اولین ترجیح دینی چاہیے۔

MCP سرورز کو HTTP پر مبنی ٹرانسپورٹس کے ساتھ نافذ کرتے وقت، سیکیورٹی ایک اہم مسئلہ بن جاتی ہے جس کے لیے مختلف حملوں کے طریقوں اور حفاظتی اقدامات پر غور کرنا ضروری ہے۔

### جائزہ

MCP سرورز کو HTTP کے ذریعے ایکسپوز کرتے وقت سیکیورٹی انتہائی اہم ہوتی ہے۔ Streamable HTTP نئے حملوں کے امکانات پیدا کرتا ہے اور محتاط کنفیگریشن کا تقاضا کرتا ہے۔

یہاں کچھ اہم سیکیورٹی نکات دیے گئے ہیں:

- **Origin Header کی تصدیق**: DNS rebinding حملوں سے بچنے کے لیے ہمیشہ `Origin` ہیڈر کی تصدیق کریں۔
- **Localhost بائنڈنگ**: مقامی ترقی کے لیے سرورز کو `localhost` پر بائنڈ کریں تاکہ انہیں عوامی انٹرنیٹ سے محفوظ رکھا جا سکے۔
- **تصدیق (Authentication)**: پروڈکشن میں تعیناتی کے لیے تصدیق (جیسے API keys، OAuth) نافذ کریں۔
- **CORS**: رسائی کو محدود کرنے کے لیے Cross-Origin Resource Sharing (CORS) پالیسیز ترتیب دیں۔
- **HTTPS**: پروڈکشن میں ٹریفک کو انکرپٹ کرنے کے لیے HTTPS استعمال کریں۔

### بہترین طریقے

اپنے MCP اسٹریمنگ سرور میں سیکیورٹی نافذ کرتے وقت درج ذیل بہترین طریقے اپنائیں:

- بغیر تصدیق کے آنے والی درخواستوں پر کبھی اعتماد نہ کریں۔
- تمام رسائی اور غلطیوں کا لاگ بنائیں اور نگرانی کریں۔
- سیکیورٹی کی کمزوریوں کو دور کرنے کے لیے باقاعدگی سے dependencies کو اپ ڈیٹ کریں۔

### چیلنجز

MCP اسٹریمنگ سرورز میں سیکیورٹی نافذ کرتے وقت آپ کو درج ذیل چیلنجز کا سامنا ہو گا:

- سیکیورٹی اور ترقی کی آسانی کے درمیان توازن قائم کرنا
- مختلف کلائنٹ ماحول کے ساتھ مطابقت کو یقینی بنانا

### اسائنمنٹ: اپنی خود کی اسٹریمنگ MCP ایپ بنائیں

**منظر نامہ:**
ایک MCP سرور اور کلائنٹ بنائیں جہاں سرور اشیاء کی فہرست (مثلاً فائلز یا دستاویزات) کو پروسیس کرے اور ہر پروسیس کی گئی آئٹم کے لیے نوٹیفیکیشن بھیجے۔ کلائنٹ کو چاہیے کہ وہ ہر نوٹیفیکیشن کو جیسے ہی موصول ہو دکھائے۔

**مراحل:**

1. ایک سرور ٹول نافذ کریں جو فہرست کو پروسیس کرے اور ہر آئٹم کے لیے نوٹیفیکیشن بھیجے۔
2. ایک کلائنٹ نافذ کریں جس میں میسج ہینڈلر ہو جو نوٹیفیکیشنز کو حقیقی وقت میں دکھائے۔
3. اپنے نفاذ کی جانچ کریں، سرور اور کلائنٹ دونوں کو چلائیں، اور نوٹیفیکیشنز کا مشاہدہ کریں۔

[Solution](./solution/README.md)

## مزید مطالعہ اور آگے کیا؟

MCP اسٹریمنگ کے ساتھ اپنی سفر جاری رکھنے اور اپنے علم کو بڑھانے کے لیے، یہ سیکشن اضافی وسائل اور مزید ترقی یافتہ ایپلیکیشنز بنانے کے لیے تجویز کردہ اگلے اقدامات فراہم کرتا ہے۔

### مزید مطالعہ

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### آگے کیا؟

- مزید ترقی یافتہ MCP ٹولز بنانے کی کوشش کریں جو حقیقی وقت کی تجزیات، چیٹ، یا مشترکہ تدوین کے لیے اسٹریمنگ استعمال کرتے ہوں۔
- MCP اسٹریمنگ کو فرنٹ اینڈ فریم ورکس (React, Vue, وغیرہ) کے ساتھ مربوط کرنے کا تجربہ کریں تاکہ لائیو UI اپ ڈیٹس حاصل ہوں۔
- اگلا: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**دستخطی نوٹ**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کے ذریعے ترجمہ کی گئی ہے۔ اگرچہ ہم درستگی کے لیے کوشاں ہیں، براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا عدم درستیاں ہو سکتی ہیں۔ اصل دستاویز اپنی مادری زبان میں ہی معتبر ماخذ سمجھی جانی چاہیے۔ اہم معلومات کے لیے پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کی ذمہ داری ہم پر عائد نہیں ہوتی۔