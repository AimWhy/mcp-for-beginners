<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-13T20:27:05+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "ur"
}
-->
# HTTPS اسٹریمنگ ماڈل کانٹیکسٹ پروٹوکول (MCP) کے ساتھ

یہ باب HTTPS کے ذریعے ماڈل کانٹیکسٹ پروٹوکول (MCP) کے ساتھ محفوظ، قابل توسیع، اور حقیقی وقت کی اسٹریمنگ کو نافذ کرنے کے لیے جامع رہنمائی فراہم کرتا ہے۔ اس میں اسٹریمنگ کی ضرورت، دستیاب ٹرانسپورٹ میکانزم، MCP میں اسٹریمنگ HTTP کو کیسے نافذ کیا جائے، سیکیورٹی کی بہترین مشقیں، SSE سے مائیگریشن، اور اپنے اسٹریمنگ MCP ایپلیکیشنز بنانے کے لیے عملی رہنمائی شامل ہے۔

## MCP میں ٹرانسپورٹ میکانزم اور اسٹریمنگ

یہ سیکشن MCP میں دستیاب مختلف ٹرانسپورٹ میکانزم اور ان کے کردار کو دریافت کرتا ہے جو کلائنٹس اور سرورز کے درمیان حقیقی وقت کی مواصلات کے لیے اسٹریمنگ کی صلاحیتیں فراہم کرتے ہیں۔

### ٹرانسپورٹ میکانزم کیا ہے؟

ٹرانسپورٹ میکانزم یہ تعین کرتا ہے کہ کلائنٹ اور سرور کے درمیان ڈیٹا کیسے تبادلہ کیا جاتا ہے۔ MCP مختلف ماحول اور ضروریات کے مطابق متعدد ٹرانسپورٹ اقسام کی حمایت کرتا ہے:

- **stdio**: معیاری ان پٹ/آؤٹ پٹ، مقامی اور CLI پر مبنی ٹولز کے لیے موزوں۔ سادہ لیکن ویب یا کلاؤڈ کے لیے مناسب نہیں۔
- **SSE (سرور-سینٹ ایونٹس)**: سرورز کو HTTP کے ذریعے کلائنٹس کو حقیقی وقت کی اپ ڈیٹس بھیجنے کی اجازت دیتا ہے۔ ویب یوزر انٹرفیس کے لیے اچھا، لیکن توسیع پذیری اور لچک میں محدود۔
- **Streamable HTTP**: جدید HTTP پر مبنی اسٹریمنگ ٹرانسپورٹ، نوٹیفیکیشنز اور بہتر توسیع پذیری کی حمایت کرتا ہے۔ زیادہ تر پروڈکشن اور کلاؤڈ کے منظرناموں کے لیے تجویز کردہ۔

### موازنہ جدول

نیچے دیے گئے موازنہ جدول کو دیکھیں تاکہ ان ٹرانسپورٹ میکانزم کے درمیان فرق کو سمجھ سکیں:

| ٹرانسپورٹ         | حقیقی وقت کی اپ ڈیٹس | اسٹریمنگ | توسیع پذیری | استعمال کا کیس           |
|-------------------|---------------------|----------|-------------|-------------------------|
| stdio             | نہیں                | نہیں     | کم          | مقامی CLI ٹولز          |
| SSE               | ہاں                 | ہاں      | درمیانہ     | ویب، حقیقی وقت کی اپ ڈیٹس|
| Streamable HTTP   | ہاں                 | ہاں      | زیادہ       | کلاؤڈ، کثیر کلائنٹ     |

> **Tip:** درست ٹرانسپورٹ کا انتخاب کارکردگی، توسیع پذیری، اور صارف کے تجربے پر اثر انداز ہوتا ہے۔ **Streamable HTTP** جدید، قابل توسیع، اور کلاؤڈ کے لیے تیار ایپلیکیشنز کے لیے تجویز کیا جاتا ہے۔

نوٹ کریں کہ stdio اور SSE ٹرانسپورٹس جو آپ کو پچھلے ابواب میں دکھائے گئے تھے اور اس باب میں جو Streamable HTTP ٹرانسپورٹ شامل ہے۔

## اسٹریمنگ: تصورات اور محرکات

اسٹریمنگ کے بنیادی تصورات اور محرکات کو سمجھنا مؤثر حقیقی وقت کی مواصلات کے نظام کو نافذ کرنے کے لیے ضروری ہے۔

**اسٹریمنگ** نیٹ ورک پروگرامنگ کی ایک تکنیک ہے جو ڈیٹا کو چھوٹے، قابل انتظام حصوں یا ایونٹس کی ترتیب کے طور پر بھیجنے اور وصول کرنے کی اجازت دیتی ہے، بجائے اس کے کہ پورا جواب تیار ہونے کا انتظار کیا جائے۔ یہ خاص طور پر مفید ہے:

- بڑے فائلز یا ڈیٹا سیٹس کے لیے۔
- حقیقی وقت کی اپ ڈیٹس (مثلاً چیٹ، پروگریس بارز)۔
- طویل مدتی کمپیوٹیشنز جہاں آپ صارف کو معلومات دیتے رہنا چاہتے ہیں۔

یہاں اسٹریمنگ کے بارے میں اعلی سطح پر جاننے والی باتیں ہیں:

- ڈیٹا بتدریج فراہم کیا جاتا ہے، ایک ساتھ نہیں۔
- کلائنٹ ڈیٹا کو جیسے ہی وصول کرے پراسیس کر سکتا ہے۔
- محسوس شدہ تاخیر کو کم کرتا ہے اور صارف کے تجربے کو بہتر بناتا ہے۔

### اسٹریمنگ کیوں استعمال کریں؟

اسٹریمنگ استعمال کرنے کی وجوہات درج ذیل ہیں:

- صارفین کو فوری فیڈبیک ملتا ہے، صرف آخر میں نہیں۔
- حقیقی وقت کی ایپلیکیشنز اور جوابدہ یوزر انٹرفیسز کو فعال کرتا ہے۔
- نیٹ ورک اور کمپیوٹ وسائل کا زیادہ مؤثر استعمال۔

### سادہ مثال: HTTP اسٹریمنگ سرور اور کلائنٹ

یہاں ایک سادہ مثال ہے کہ اسٹریمنگ کو کیسے نافذ کیا جا سکتا ہے:

<details>
<summary>Python</summary>

**سرور (Python، FastAPI اور StreamingResponse استعمال کرتے ہوئے):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**کلائنٹ (Python، requests استعمال کرتے ہوئے):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

یہ مثال دکھاتی ہے کہ سرور کلائنٹ کو پیغامات کی ایک سیریز بھیج رہا ہے جیسے ہی وہ دستیاب ہوتے ہیں، بجائے اس کے کہ تمام پیغامات تیار ہونے کا انتظار کرے۔

**یہ کیسے کام کرتا ہے:**
- سرور ہر پیغام کو جیسے ہی تیار ہو جاری کرتا ہے۔
- کلائنٹ ہر حصہ کو وصول کر کے پرنٹ کرتا ہے۔

**ضروریات:**
- سرور کو اسٹریمنگ ریسپانس استعمال کرنا چاہیے (مثلاً FastAPI میں `StreamingResponse`)۔
- کلائنٹ کو ریسپانس کو اسٹریمنگ کے طور پر پراسیس کرنا چاہیے (`stream=True` requests میں)۔
- Content-Type عام طور پر `text/event-stream` یا `application/octet-stream` ہوتا ہے۔

</details>

<details>
<summary>Java</summary>

**سرور (Java، Spring Boot اور Server-Sent Events استعمال کرتے ہوئے):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**کلائنٹ (Java، Spring WebFlux WebClient استعمال کرتے ہوئے):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java نفاذ کے نوٹس:**
- Spring Boot کے reactive stack کے ساتھ `Flux` استعمال کرتا ہے اسٹریمنگ کے لیے
- `ServerSentEvent` ایونٹ کی اقسام کے ساتھ ساختہ ایونٹ اسٹریمنگ فراہم کرتا ہے
- `WebClient` کے ساتھ `bodyToFlux()` ریئیکٹو اسٹریمنگ کنزمپشن کو فعال کرتا ہے
- `delayElements()` ایونٹس کے درمیان پروسیسنگ وقت کی نقل کرتا ہے
- ایونٹس کے پاس اقسام ہو سکتی ہیں (`info`, `result`) بہتر کلائنٹ ہینڈلنگ کے لیے

</details>

### موازنہ: کلاسیکی اسٹریمنگ بمقابلہ MCP اسٹریمنگ

کلاسیکی اسٹریمنگ اور MCP اسٹریمنگ کے درمیان فرق کو یوں ظاہر کیا جا سکتا ہے:

| خصوصیت                | کلاسیکی HTTP اسٹریمنگ          | MCP اسٹریمنگ (نوٹیفیکیشنز)       |
|------------------------|-------------------------------|-----------------------------------|
| مرکزی جواب             | چنکس میں                     | ایک بار، آخر میں                  |
| پروگریس اپ ڈیٹس       | ڈیٹا چنکس کے طور پر بھیجے جاتے ہیں | نوٹیفیکیشنز کے طور پر بھیجے جاتے ہیں |
| کلائنٹ کی ضروریات     | اسٹریمنگ کو پراسیس کرنا ضروری ہے | میسج ہینڈلر نافذ کرنا ضروری ہے    |
| استعمال کا کیس        | بڑی فائلز، AI ٹوکن اسٹریمز    | پروگریس، لاگز، حقیقی وقت کا فیڈبیک |

### کلیدی فرق

مزید برآں، یہاں کچھ کلیدی فرق ہیں:

- **مواصلاتی پیٹرن:**
   - کلاسیکی HTTP اسٹریمنگ: سادہ چنکڈ ٹرانسفر انکوڈنگ استعمال کرتا ہے
   - MCP اسٹریمنگ: JSON-RPC پروٹوکول کے ساتھ ساختہ نوٹیفیکیشن سسٹم استعمال کرتا ہے

- **میسج فارمیٹ:**
   - کلاسیکی HTTP: سادہ ٹیکسٹ چنکس نئی لائنز کے ساتھ
   - MCP: ساختہ LoggingMessageNotification آبجیکٹس میٹا ڈیٹا کے ساتھ

- **کلائنٹ نفاذ:**
   - کلاسیکی HTTP: سادہ کلائنٹ جو اسٹریمنگ ریسپانسز پراسیس کرتا ہے
   - MCP: زیادہ پیچیدہ کلائنٹ جس میں مختلف اقسام کے پیغامات پراسیس کرنے کے لیے میسج ہینڈلر ہوتا ہے

- **پروگریس اپ ڈیٹس:**
   - کلاسیکی HTTP: پروگریس مرکزی ریسپانس اسٹریم کا حصہ ہوتا ہے
   - MCP: پروگریس علیحدہ نوٹیفیکیشن میسجز کے ذریعے بھیجا جاتا ہے جبکہ مرکزی جواب آخر میں آتا ہے

### سفارشات

کلاسیکی اسٹریمنگ (جیسا کہ ہم نے آپ کو `/stream` اینڈپوائنٹ کے ذریعے دکھایا) اور MCP اسٹریمنگ کے درمیان انتخاب کے حوالے سے کچھ سفارشات ہیں:

- **سادہ اسٹریمنگ کی ضرورت کے لیے:** کلاسیکی HTTP اسٹریمنگ نافذ کرنا آسان ہے اور بنیادی اسٹریمنگ ضروریات کے لیے کافی ہے۔

- **پیچیدہ، انٹرایکٹو ایپلیکیشنز کے لیے:** MCP اسٹریمنگ ایک زیادہ ساختہ طریقہ فراہم کرتا ہے جس میں زیادہ میٹا ڈیٹا اور نوٹیفیکیشنز اور حتمی نتائج کے درمیان تفریق ہوتی ہے۔

- **AI ایپلیکیشنز کے لیے:** MCP کا نوٹیفیکیشن سسٹم طویل مدتی AI ٹاسکس کے لیے خاص طور پر مفید ہے جہاں آپ صارفین کو پروگریس سے آگاہ رکھنا چاہتے ہیں۔

## MCP میں اسٹریمنگ

اب تک آپ نے کلاسیکی اسٹریمنگ اور MCP اسٹریمنگ کے درمیان کچھ سفارشات اور موازنہ دیکھا ہے۔ آئیے تفصیل سے جانتے ہیں کہ آپ MCP میں اسٹریمنگ کو کیسے استعمال کر سکتے ہیں۔

MCP فریم ورک کے اندر اسٹریمنگ کیسے کام کرتی ہے یہ سمجھنا ضروری ہے تاکہ آپ ایسے جوابدہ ایپلیکیشنز بنا سکیں جو طویل مدتی آپریشنز کے دوران صارفین کو حقیقی وقت میں فیڈبیک فراہم کریں۔

MCP میں، اسٹریمنگ کا مطلب مرکزی جواب کو چنکس میں بھیجنا نہیں بلکہ درخواست کی پروسیسنگ کے دوران کلائنٹ کو **نوٹیفیکیشنز** بھیجنا ہے۔ یہ نوٹیفیکیشنز پروگریس اپ ڈیٹس، لاگز، یا دیگر ایونٹس شامل ہو سکتے ہیں۔

### یہ کیسے کام کرتا ہے

مرکزی نتیجہ اب بھی ایک واحد جواب کے طور پر بھیجا جاتا ہے۔ تاہم، نوٹیفیکیشنز پروسیسنگ کے دوران علیحدہ پیغامات کے طور پر بھیجی جا سکتی ہیں اور اس طرح کلائنٹ کو حقیقی وقت میں اپ ڈیٹ کرتی ہیں۔ کلائنٹ کو ان نوٹیفیکیشنز کو ہینڈل اور دکھانے کے قابل ہونا چاہیے۔

## نوٹیفیکیشن کیا ہے؟

ہم نے "نوٹیفیکیشن" کا ذکر کیا، MCP کے سیاق و سباق میں اس کا کیا مطلب ہے؟

نوٹیفیکیشن ایک پیغام ہے جو سرور سے کلائنٹ کو بھیجا جاتا ہے تاکہ طویل مدتی آپریشن کے دوران پروگریس، اسٹیٹس، یا دیگر ایونٹس کے بارے میں آگاہ کیا جا سکے۔ نوٹیفیکیشنز شفافیت اور صارف کے تجربے کو بہتر بناتی ہیں۔

مثال کے طور پر، کلائنٹ کو ایک نوٹیفیکیشن بھیجنی چاہیے جب سرور کے ساتھ ابتدائی ہینڈشیک مکمل ہو جائے۔

نوٹیفیکیشن JSON پیغام کی شکل میں کچھ یوں دکھائی دیتی ہے:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

نوٹیفیکیشنز MCP میں ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) کے موضوع سے تعلق رکھتی ہیں۔

لاگنگ کو فعال کرنے کے لیے، سرور کو اسے فیچر/صلاحیت کے طور پر فعال کرنا پڑتا ہے، جیسا کہ درج ذیل ہے:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> استعمال شدہ SDK پر منحصر ہے، لاگنگ پہلے سے فعال ہو سکتی ہے، یا آپ کو اسے اپنے سرور کی کنفیگریشن میں واضح طور پر فعال کرنا پڑ سکتا ہے۔

نوٹیفیکیشنز کی مختلف اقسام ہیں:

| سطح       | وضاحت                         | استعمال کی مثال                |
|-----------|-------------------------------|-------------------------------|
| debug     | تفصیلی ڈیبگنگ معلومات         | فنکشن کے داخلے/خروج کے پوائنٹس |
| info      | عمومی معلوماتی پیغامات        | آپریشن کی پروگریس اپ ڈیٹس     |
| notice    | معمول کے لیکن اہم ایونٹس       | کنفیگریشن میں تبدیلیاں         |
| warning   | وارننگ کی حالتیں              | پرانی خصوصیات کا استعمال      |
| error     | خرابی کی حالتیں               | آپریشن کی ناکامیاں            |
| critical  | سنگین حالتیں                 | سسٹم کے اجزاء کی ناکامیاں      |
| alert     | فوری کارروائی ضروری ہے         | ڈیٹا کی خرابی کا پتہ چلنا      |
| emergency | سسٹم ناقابل استعمال ہے         | مکمل سسٹم کی ناکامی           |

## MCP میں نوٹیفیکیشنز کا نفاذ

MCP میں نوٹیفیکیشنز کو نافذ کرنے کے لیے، آپ کو سرور اور کلائنٹ دونوں طرف حقیقی وقت کی اپ ڈیٹس کو ہینڈل کرنے کے لیے سیٹ اپ کرنا ہوگا۔ اس سے آپ کی ایپلیکیشن طویل مدتی آپریشنز کے دوران صارفین کو فوری فیڈبیک فراہم کر سکتی ہے۔

### سرور سائڈ: نوٹیفیکیشنز بھیجنا

آئیے سرور سائڈ سے شروع کرتے ہیں۔ MCP میں، آپ ایسے ٹولز ڈیفائن کرتے ہیں جو درخواستوں کی پروسیسنگ کے دوران نوٹیفیکیشنز بھیج سکتے ہیں۔ سرور کلائنٹ کو پیغامات بھیجنے کے لیے عام طور پر `ctx` کانٹیکسٹ آبجیکٹ استعمال کرتا ہے۔

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

پچھلی مثال میں، `process_files` ٹول ہر فائل کی پروسیسنگ کے دوران کلائنٹ کو تین نوٹیفیکیشنز بھیجتا ہے۔ `ctx.info()` طریقہ معلوماتی پیغامات بھیجنے کے لیے استعمال ہوتا ہے۔

</details>

مزید برآں، نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ کا سرور اسٹریمنگ ٹرانسپورٹ (جیسے `streamable-http`) استعمال کر رہا ہے اور آپ کا کلائنٹ نوٹیفیکیشنز پراسیس کرنے کے لیے میسج ہینڈلر نافذ کرتا ہے۔ یہاں دکھایا گیا ہے کہ سرور کو `streamable-http` ٹرانسپورٹ استعمال کرنے کے لیے کیسے سیٹ اپ کیا جائے:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

اس .NET مثال میں، `ProcessFiles` ٹول `Tool` ایٹریبیوٹ کے ساتھ سجا ہوا ہے اور ہر فائل کی پروسیسنگ کے دوران کلائنٹ کو تین نوٹیفیکیشنز بھیجتا ہے۔ `ctx.Info()` طریقہ معلوماتی پیغامات بھیجنے کے لیے استعمال ہوتا ہے۔

اپنے .NET MCP سرور میں نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ اسٹریمنگ ٹرانسپورٹ استعمال کر رہے ہیں:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### کلائنٹ سائڈ: نوٹیفیکیشنز وصول کرنا

کلائنٹ کو ایک میسج ہینڈلر نافذ کرنا چاہیے جو نوٹیفیکیشنز کو وصول کرے اور دکھائے۔

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

پچھلے کوڈ میں، `message_handler` فنکشن چیک کرتا ہے کہ آیا آنے والا پیغام نوٹیفیکیشن ہے۔ اگر ہے تو یہ نوٹیفیکیشن پرنٹ کرتا ہے؛ ورنہ اسے عام سرور پیغام کے طور پر پراسیس کرتا ہے۔ یہ بھی نوٹ کریں کہ `ClientSession` کو `message_handler` کے ساتھ انیشیئلائز کیا گیا ہے تاکہ آنے والی نوٹیفیکیشنز کو ہینڈل کیا جا سکے۔

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

اس .NET مثال میں، `MessageHandler` فنکشن چیک کرتا ہے کہ آیا آنے والا پیغام نوٹیفیکیشن ہے۔ اگر ہے تو یہ نوٹیفیکیشن پرنٹ کرتا ہے؛ ورنہ اسے عام سرور پیغام کے طور پر پراسیس کرتا ہے۔ `ClientSession` کو `ClientSessionOptions` کے ذریعے میسج ہینڈلر کے ساتھ انیشیئلائز کیا گیا ہے۔

</details>

نوٹیفیکیشنز کو فعال کرنے کے لیے، یقینی بنائیں کہ آپ کا سرور اسٹریمنگ ٹرانسپورٹ (جیسے `streamable-http`) استعمال کر رہا ہے اور آپ کا کلائنٹ نوٹیفیکیشنز پراسیس کرنے کے لیے میسج ہینڈلر نافذ کرتا ہے۔

## پروگریس نوٹیفیکیشنز اور منظرنامے

یہ سیکشن MCP میں پروگریس نوٹیفیکیشنز کے تصور، ان کی اہمیت، اور Streamable HTTP استعمال کرتے ہوئے انہیں کیسے نافذ کیا جائے، کی وضاحت کرتا ہے۔ آپ کو اپنی سمجھ کو مضبوط کرنے کے لیے ایک عملی مشق بھی ملے گی۔

پروگریس نوٹیفیکیشنز وہ حقیقی وقت کے پیغامات ہیں جو سرور سے کلائنٹ کو طویل مدتی آپریشنز کے دوران بھیجے جاتے ہیں۔ پورے عمل کے ختم ہونے کا انتظار کرنے کے بجائے، سرور کلائنٹ کو موجودہ اسٹیٹس کے بارے میں اپ ڈیٹ رکھتا ہے۔ یہ شفافیت، صارف کے تجربے کو بہتر بناتا ہے، اور ڈیبگنگ کو آسان بناتا ہے۔

**مثال:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### پروگریس نوٹیفیکیشنز کیوں

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**کلائنٹ کی مثال:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## سیکیورٹی کے پہلو

جب MCP سرورز کو HTTP پر مبنی ٹرانسپورٹس کے ساتھ نافذ کیا جاتا ہے، تو سیکیورٹی ایک نہایت اہم مسئلہ بن جاتی ہے جس کے لیے مختلف حملوں کے طریقوں اور حفاظتی اقدامات پر خاص توجہ دینا ضروری ہے۔

### جائزہ

HTTP کے ذریعے MCP سرورز کو ظاہر کرتے وقت سیکیورٹی انتہائی اہم ہوتی ہے۔ Streamable HTTP نئے حملوں کے امکانات پیدا کرتا ہے اور اس کی ترتیب میں احتیاط کی ضرورت ہوتی ہے۔

### اہم نکات
- **Origin ہیڈر کی تصدیق**: DNS rebinding حملوں سے بچنے کے لیے ہمیشہ `Origin` ہیڈر کی تصدیق کریں۔
- **Localhost پر بائنڈنگ**: مقامی ترقی کے لیے سرورز کو `localhost` پر بائنڈ کریں تاکہ انہیں عوامی انٹرنیٹ پر ظاہر نہ کیا جائے۔
- **تصدیق (Authentication)**: پروڈکشن میں تعیناتی کے لیے تصدیق (مثلاً API keys، OAuth) نافذ کریں۔
- **CORS**: رسائی کو محدود کرنے کے لیے Cross-Origin Resource Sharing (CORS) کی پالیسیز ترتیب دیں۔
- **HTTPS**: پروڈکشن میں ٹریفک کو انکرپٹ کرنے کے لیے HTTPS استعمال کریں۔

### بہترین طریقے
- بغیر تصدیق کے آنے والی درخواستوں پر کبھی بھروسہ نہ کریں۔
- تمام رسائی اور غلطیوں کا لاگ بنائیں اور نگرانی کریں۔
- سیکیورٹی کی خامیوں کو دور کرنے کے لیے باقاعدگی سے dependencies کو اپ ڈیٹ کریں۔

### چیلنجز
- سیکیورٹی اور ترقی کی آسانی کے درمیان توازن قائم کرنا
- مختلف کلائنٹ ماحول کے ساتھ مطابقت کو یقینی بنانا


## SSE سے Streamable HTTP میں اپ گریڈ کرنا

جو ایپلیکیشنز فی الحال Server-Sent Events (SSE) استعمال کر رہی ہیں، ان کے لیے Streamable HTTP پر منتقلی بہتر صلاحیتیں اور MCP کے نفاذ کے لیے طویل مدتی استحکام فراہم کرتی ہے۔

### اپ گریڈ کیوں کریں؟

SSE سے Streamable HTTP پر اپ گریڈ کرنے کی دو اہم وجوہات ہیں:

- Streamable HTTP بہتر اسکیل ایبلٹی، مطابقت، اور زیادہ جامع نوٹیفیکیشن سپورٹ فراہم کرتا ہے۔
- یہ نئے MCP ایپلیکیشنز کے لیے تجویز کردہ ٹرانسپورٹ ہے۔

### منتقلی کے مراحل

اپنے MCP ایپلیکیشنز میں SSE سے Streamable HTTP پر منتقلی کے لیے یہ اقدامات کریں:

- سرور کوڈ کو اپ ڈیٹ کریں تاکہ `mcp.run()` میں `transport="streamable-http"` استعمال ہو۔
- کلائنٹ کوڈ کو اپ ڈیٹ کریں تاکہ SSE کلائنٹ کی جگہ `streamablehttp_client` استعمال ہو۔
- کلائنٹ میں نوٹیفیکیشنز کو پروسیس کرنے کے لیے ایک میسج ہینڈلر نافذ کریں۔
- موجودہ ٹولز اور ورک فلو کے ساتھ مطابقت کے لیے ٹیسٹ کریں۔

### مطابقت برقرار رکھنا

منتقلی کے دوران موجودہ SSE کلائنٹس کے ساتھ مطابقت برقرار رکھنا بہتر ہے۔ کچھ حکمت عملیاں یہ ہیں:

- آپ دونوں SSE اور Streamable HTTP کو مختلف اینڈ پوائنٹس پر چلا کر سپورٹ کر سکتے ہیں۔
- کلائنٹس کو آہستہ آہستہ نئے ٹرانسپورٹ کی طرف منتقل کریں۔

### چیلنجز

منتقلی کے دوران درج ذیل چیلنجز کا حل یقینی بنائیں:

- تمام کلائنٹس کو اپ ڈیٹ کرنا
- نوٹیفیکیشن کی ترسیل میں فرق کو سنبھالنا

## سیکیورٹی کے پہلو

کسی بھی سرور کو نافذ کرتے وقت، خاص طور پر MCP میں Streamable HTTP جیسے HTTP پر مبنی ٹرانسپورٹس کے استعمال کے دوران، سیکیورٹی کو اولین ترجیح دینی چاہیے۔

جب MCP سرورز کو HTTP پر مبنی ٹرانسپورٹس کے ساتھ نافذ کیا جاتا ہے، تو سیکیورٹی ایک نہایت اہم مسئلہ بن جاتی ہے جس کے لیے مختلف حملوں کے طریقوں اور حفاظتی اقدامات پر خاص توجہ دینا ضروری ہے۔

### جائزہ

HTTP کے ذریعے MCP سرورز کو ظاہر کرتے وقت سیکیورٹی انتہائی اہم ہوتی ہے۔ Streamable HTTP نئے حملوں کے امکانات پیدا کرتا ہے اور اس کی ترتیب میں احتیاط کی ضرورت ہوتی ہے۔

یہاں کچھ اہم سیکیورٹی کے پہلو ہیں:

- **Origin ہیڈر کی تصدیق**: DNS rebinding حملوں سے بچنے کے لیے ہمیشہ `Origin` ہیڈر کی تصدیق کریں۔
- **Localhost پر بائنڈنگ**: مقامی ترقی کے لیے سرورز کو `localhost` پر بائنڈ کریں تاکہ انہیں عوامی انٹرنیٹ پر ظاہر نہ کیا جائے۔
- **تصدیق (Authentication)**: پروڈکشن میں تعیناتی کے لیے تصدیق (مثلاً API keys، OAuth) نافذ کریں۔
- **CORS**: رسائی کو محدود کرنے کے لیے Cross-Origin Resource Sharing (CORS) کی پالیسیز ترتیب دیں۔
- **HTTPS**: پروڈکشن میں ٹریفک کو انکرپٹ کرنے کے لیے HTTPS استعمال کریں۔

### بہترین طریقے

مزید برآں، MCP اسٹریمنگ سرور میں سیکیورٹی نافذ کرتے وقت درج ذیل بہترین طریقے اپنائیں:

- بغیر تصدیق کے آنے والی درخواستوں پر کبھی بھروسہ نہ کریں۔
- تمام رسائی اور غلطیوں کا لاگ بنائیں اور نگرانی کریں۔
- سیکیورٹی کی خامیوں کو دور کرنے کے لیے باقاعدگی سے dependencies کو اپ ڈیٹ کریں۔

### چیلنجز

MCP اسٹریمنگ سرورز میں سیکیورٹی نافذ کرتے وقت آپ کو کچھ چیلنجز کا سامنا ہوگا:

- سیکیورٹی اور ترقی کی آسانی کے درمیان توازن قائم کرنا
- مختلف کلائنٹ ماحول کے ساتھ مطابقت کو یقینی بنانا

### اسائنمنٹ: اپنی خود کی اسٹریمنگ MCP ایپ بنائیں

**منظرنامہ:**
ایک MCP سرور اور کلائنٹ بنائیں جہاں سرور اشیاء کی فہرست (مثلاً فائلز یا دستاویزات) کو پروسیس کرے اور ہر پروسیس کی گئی آئٹم کے لیے نوٹیفیکیشن بھیجے۔ کلائنٹ کو چاہیے کہ وہ ہر نوٹیفیکیشن کو جیسے ہی موصول ہو دکھائے۔

**مراحل:**

1. ایک سرور ٹول نافذ کریں جو فہرست کو پروسیس کرے اور ہر آئٹم کے لیے نوٹیفیکیشن بھیجے۔
2. ایک کلائنٹ نافذ کریں جس میں نوٹیفیکیشنز کو حقیقی وقت میں دکھانے کے لیے میسج ہینڈلر ہو۔
3. اپنے نفاذ کو سرور اور کلائنٹ دونوں چلانے کے ذریعے ٹیسٹ کریں اور نوٹیفیکیشنز کا مشاہدہ کریں۔

[Solution](./solution/README.md)

## مزید مطالعہ اور آگے کیا کریں؟

اپنے MCP اسٹریمنگ کے سفر کو جاری رکھنے اور اپنی معلومات کو بڑھانے کے لیے، یہ سیکشن اضافی وسائل اور مزید ترقی یافتہ ایپلیکیشنز بنانے کے لیے تجویز کردہ اگلے اقدامات فراہم کرتا ہے۔

### مزید مطالعہ

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### آگے کیا کریں؟

- مزید ترقی یافتہ MCP ٹولز بنانے کی کوشش کریں جو حقیقی وقت کی تجزیات، چیٹ، یا مشترکہ تدوین کے لیے اسٹریمنگ استعمال کرتے ہوں۔
- MCP اسٹریمنگ کو فرنٹ اینڈ فریم ورکس (React، Vue، وغیرہ) کے ساتھ مربوط کرنے کا تجربہ کریں تاکہ لائیو UI اپ ڈیٹس حاصل ہوں۔
- اگلا: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**دستخطی نوٹ**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کے ذریعے ترجمہ کی گئی ہے۔ اگرچہ ہم درستگی کے لیے کوشاں ہیں، براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا عدم درستیاں ہو سکتی ہیں۔ اصل دستاویز اپنی مادری زبان میں معتبر ماخذ سمجھی جانی چاہیے۔ اہم معلومات کے لیے پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کی ذمہ داری ہم پر عائد نہیں ہوتی۔