<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-10T16:06:31+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "pa"
}
-->
# HTTPS ਸਟ੍ਰੀਮਿੰਗ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ

ਇਸ ਅਧਿਆਇ ਵਿੱਚ HTTPS ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ ਸੁਰੱਖਿਅਤ, ਸਕੇਲ ਕਰਨ ਯੋਗ ਅਤੇ ਰੀਅਲ-ਟਾਈਮ ਸਟ੍ਰੀਮਿੰਗ ਲਾਗੂ ਕਰਨ ਲਈ ਵਿਸਤ੍ਰਿਤ ਮਾਰਗਦਰਸ਼ਨ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਇਹ ਸਟ੍ਰੀਮਿੰਗ ਦੀ ਪ੍ਰੇਰਣਾ, ਉਪਲਬਧ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ, MCP ਵਿੱਚ ਸਟ੍ਰੀਮ ਕਰਨ ਯੋਗ HTTP ਨੂੰ ਕਿਵੇਂ ਲਾਗੂ ਕਰਨਾ ਹੈ, ਸੁਰੱਖਿਆ ਦੀਆਂ ਵਧੀਆ ਪ੍ਰਥਾਵਾਂ, SSE ਤੋਂ ਮਾਈਗ੍ਰੇਸ਼ਨ ਅਤੇ ਆਪਣੇ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਬਣਾਉਣ ਲਈ ਪ੍ਰਯੋਗਿਕ ਮਾਰਗਦਰਸ਼ਨ ਨੂੰ ਕਵਰ ਕਰਦਾ ਹੈ।

## MCP ਵਿੱਚ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ ਸਟ੍ਰੀਮਿੰਗ

ਇਸ ਭਾਗ ਵਿੱਚ MCP ਵਿੱਚ ਉਪਲਬਧ ਵੱਖ-ਵੱਖ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰ ਵਿਚਕਾਰ ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਸਮਰੱਥਾਵਾਂ ਨੂੰ ਯੋਗ ਬਣਾਉਣ ਵਿੱਚ ਉਹਨਾਂ ਦੀ ਭੂਮਿਕਾ ਦੀ ਜਾਂਚ ਕੀਤੀ ਗਈ ਹੈ।

### ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਕੀ ਹੈ?

ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਦਾ ਹੈ ਕਿ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰ ਵਿਚਕਾਰ ਡਾਟਾ ਕਿਵੇਂ ਅਦਲਾ-ਬਦਲੀ ਹੁੰਦਾ ਹੈ। MCP ਵੱਖ-ਵੱਖ ਵਾਤਾਵਰਣਾਂ ਅਤੇ ਲੋੜਾਂ ਲਈ ਕਈ ਟ੍ਰਾਂਸਪੋਰਟ ਕਿਸਮਾਂ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ:

- **stdio**: ਸਟੈਂਡਰਡ ਇਨਪੁੱਟ/ਆਉਟਪੁੱਟ, ਸਥਾਨਕ ਅਤੇ CLI-ਆਧਾਰਿਤ ਟੂਲਾਂ ਲਈ ਉਚਿਤ। ਸਧਾਰਣ ਪਰ ਵੈੱਬ ਜਾਂ ਕਲਾਉਡ ਲਈ ਉਚਿਤ ਨਹੀਂ।
- **SSE (Server-Sent Events)**: ਸਰਵਰ HTTP ਰਾਹੀਂ ਕਲਾਇੰਟਾਂ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ ਭੇਜਣ ਦੀ ਆਗਿਆ ਦਿੰਦਾ ਹੈ। ਵੈੱਬ UI ਲਈ ਚੰਗਾ, ਪਰ ਸਕੇਲਬਿਲਟੀ ਅਤੇ ਲਚਕੀਲਾਪਣ ਵਿੱਚ ਸੀਮਿਤ।
- **Streamable HTTP**: ਆਧੁਨਿਕ HTTP-ਆਧਾਰਿਤ ਸਟ੍ਰੀਮਿੰਗ ਟ੍ਰਾਂਸਪੋਰਟ, ਸੂਚਨਾਵਾਂ ਅਤੇ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ। ਜ਼ਿਆਦਾਤਰ ਉਤਪਾਦਨ ਅਤੇ ਕਲਾਉਡ ਸਥਿਤੀਆਂ ਲਈ ਸਿਫਾਰਸ਼ੀ।

### ਤੁਲਨਾਤਮਕ ਟੇਬਲ

ਹੇਠਾਂ ਦਿੱਤੇ ਤੁਲਨਾਤਮਕ ਟੇਬਲ ਨੂੰ ਦੇਖੋ ਤਾਂ ਜੋ ਇਹ ਸਮਝ ਸਕੋ ਕਿ ਇਹਨਾਂ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮਾਂ ਵਿੱਚ ਕੀ ਫਰਕ ਹੈ:

| ਟ੍ਰਾਂਸਪੋਰਟ       | ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ | ਸਟ੍ਰੀਮਿੰਗ | ਸਕੇਲਬਿਲਟੀ | ਵਰਤੋਂ ਦਾ ਕੇਸ           |
|-------------------|--------------------|-----------|-------------|-------------------------|
| stdio             | ਨਹੀਂ               | ਨਹੀਂ      | ਘੱਟ        | ਸਥਾਨਕ CLI ਟੂਲ          |
| SSE               | ਹਾਂ                | ਹਾਂ       | ਦਰਮਿਆਨਾ   | ਵੈੱਬ, ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ |
| Streamable HTTP   | ਹਾਂ                | ਹਾਂ       | ਉੱਚ        | ਕਲਾਉਡ, ਬਹੁ-ਕਲਾਇੰਟ      |

> **Tip:** ਸਹੀ ਟ੍ਰਾਂਸਪੋਰਟ ਚੁਣਨਾ ਪ੍ਰਦਰਸ਼ਨ, ਸਕੇਲਬਿਲਟੀ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ 'ਤੇ ਪ੍ਰਭਾਵ ਪਾਂਦਾ ਹੈ। ਆਧੁਨਿਕ, ਸਕੇਲ ਕਰਨ ਯੋਗ ਅਤੇ ਕਲਾਉਡ-ਤਿਆਰ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ **Streamable HTTP** ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ।

ਪਿਛਲੇ ਅਧਿਆਇਆਂ ਵਿੱਚ ਤੁਸੀਂ stdio ਅਤੇ SSE ਟ੍ਰਾਂਸਪੋਰਟ ਦੇਖੇ ਹਨ ਅਤੇ ਇਸ ਅਧਿਆਇ ਵਿੱਚ ਕਵਰ ਕੀਤਾ ਗਿਆ ਟ੍ਰਾਂਸਪੋਰਟ Streamable HTTP ਹੈ।

## ਸਟ੍ਰੀਮਿੰਗ: ਧਾਰਣਾਵਾਂ ਅਤੇ ਪ੍ਰੇਰਣਾ

ਸਟ੍ਰੀਮਿੰਗ ਦੇ ਮੂਲ ਧਾਰਣਾਵਾਂ ਅਤੇ ਪ੍ਰੇਰਣਾਵਾਂ ਨੂੰ ਸਮਝਣਾ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਪ੍ਰਣਾਲੀਆਂ ਲਾਗੂ ਕਰਨ ਲਈ ਜ਼ਰੂਰੀ ਹੈ।

**ਸਟ੍ਰੀਮਿੰਗ** ਨੈੱਟਵਰਕ ਪ੍ਰੋਗ੍ਰਾਮਿੰਗ ਵਿੱਚ ਇੱਕ ਤਕਨੀਕ ਹੈ ਜੋ ਡਾਟਾ ਨੂੰ ਛੋਟੇ, ਸੰਭਾਲਣ ਯੋਗ ਹਿੱਸਿਆਂ ਵਿੱਚ ਜਾਂ ਘਟਨਾਵਾਂ ਦੀ ਲੜੀ ਵਜੋਂ ਭੇਜਣ ਅਤੇ ਪ੍ਰਾਪਤ ਕਰਨ ਦੀ ਆਗਿਆ ਦਿੰਦੀ ਹੈ, ਨਾ ਕਿ ਪੂਰੇ ਜਵਾਬ ਦੇ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰਨ ਲਈ। ਇਹ ਖਾਸ ਕਰਕੇ ਲਾਭਦਾਇਕ ਹੈ:

- ਵੱਡੀਆਂ ਫਾਈਲਾਂ ਜਾਂ ਡਾਟਾਸੈੱਟ ਲਈ।
- ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ (ਜਿਵੇਂ ਕਿ ਚੈਟ, ਪ੍ਰਗਤੀ ਬਾਰ)।
- ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੀਆਂ ਗਣਨਾਵਾਂ ਜਿੱਥੇ ਤੁਸੀਂ ਉਪਭੋਗਤਾ ਨੂੰ ਜਾਣੂ ਰੱਖਣਾ ਚਾਹੁੰਦੇ ਹੋ।

ਇੱਥੇ ਸਟ੍ਰੀਮਿੰਗ ਬਾਰੇ ਉੱਚ-ਸਤਰ 'ਤੇ ਜਾਣਕਾਰੀ ਹੈ:

- ਡਾਟਾ ਕ੍ਰਮਵੱਧ ਤੌਰ 'ਤੇ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ, ਸਾਰਾ ਇਕੱਠਾ ਨਹੀਂ।
- ਕਲਾਇੰਟ ਆਉਂਦੇ ਹੀ ਡਾਟਾ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰ ਸਕਦਾ ਹੈ।
- ਮਹਿਸੂਸ ਕੀਤੀ ਗਈ ਲੇਟੈਂਸੀ ਘਟਾਉਂਦਾ ਹੈ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ ਨੂੰ ਸੁਧਾਰਦਾ ਹੈ।

### ਸਟ੍ਰੀਮਿੰਗ ਕਿਉਂ ਵਰਤੋਂ?

ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਣ ਦੇ ਕਾਰਨ ਇਹ ਹਨ:

- ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਤੁਰੰਤ ਫੀਡਬੈਕ ਮਿਲਦਾ ਹੈ, ਸਿਰਫ ਅੰਤ ਵਿੱਚ ਨਹੀਂ।
- ਰੀਅਲ-ਟਾਈਮ ਐਪਲੀਕੇਸ਼ਨਾਂ ਅਤੇ ਪ੍ਰਤੀਕਿਰਿਆਸ਼ੀਲ UI ਨੂੰ ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ।
- ਨੈੱਟਵਰਕ ਅਤੇ ਕੰਪਿਊਟ ਸਰੋਤਾਂ ਦੀ ਵੱਧ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਵਰਤੋਂ।

### ਸਧਾਰਣ ਉਦਾਹਰਨ: HTTP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ

ਇੱਥੇ ਇੱਕ ਸਧਾਰਣ ਉਦਾਹਰਨ ਹੈ ਕਿ ਸਟ੍ਰੀਮਿੰਗ ਕਿਵੇਂ ਲਾਗੂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ:

<details>
<summary>Python</summary>

**ਸਰਵਰ (Python, FastAPI ਅਤੇ StreamingResponse ਦੀ ਵਰਤੋਂ ਨਾਲ):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**ਕਲਾਇੰਟ (Python, requests ਦੀ ਵਰਤੋਂ ਨਾਲ):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

ਇਹ ਉਦਾਹਰਨ ਦਿਖਾਉਂਦੀ ਹੈ ਕਿ ਸਰਵਰ ਕਿਵੇਂ ਕਲਾਇੰਟ ਨੂੰ ਸੁਨੇਹਿਆਂ ਦੀ ਲੜੀ ਭੇਜਦਾ ਹੈ ਜਿਵੇਂ ਜਿਵੇਂ ਉਹ ਉਪਲਬਧ ਹੁੰਦੇ ਹਨ, ਨਾ ਕਿ ਸਾਰੇ ਸੁਨੇਹੇ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰਦਾ ਹੈ।

**ਕਿਵੇਂ ਕੰਮ ਕਰਦਾ ਹੈ:**
- ਸਰਵਰ ਹਰ ਸੁਨੇਹਾ ਤਿਆਰ ਹੋਣ 'ਤੇ ਭੇਜਦਾ ਹੈ।
- ਕਲਾਇੰਟ ਹਰ ਹਿੱਸਾ ਪ੍ਰਾਪਤ ਕਰਕੇ ਪ੍ਰਿੰਟ ਕਰਦਾ ਹੈ।

**ਲੋੜੀਂਦੇ:**
- ਸਰਵਰ ਨੂੰ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਵਰਤਣਾ ਚਾਹੀਦਾ ਹੈ (ਜਿਵੇਂ FastAPI ਵਿੱਚ `StreamingResponse`)।
- ਕਲਾਇੰਟ ਨੂੰ ਜਵਾਬ ਨੂੰ ਸਟ੍ਰੀਮ ਵਜੋਂ ਪ੍ਰਕਿਰਿਆ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ (`stream=True` requests ਵਿੱਚ)।
- Content-Type ਆਮ ਤੌਰ 'ਤੇ `text/event-stream` ਜਾਂ `application/octet-stream` ਹੁੰਦਾ ਹੈ।

</details>

<details>
<summary>Java</summary>

**ਸਰਵਰ (Java, Spring Boot ਅਤੇ Server-Sent Events ਦੀ ਵਰਤੋਂ ਨਾਲ):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ਕਲਾਇੰਟ (Java, Spring WebFlux WebClient ਦੀ ਵਰਤੋਂ ਨਾਲ):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java ਲਾਗੂ ਕਰਨ ਦੇ ਨੋਟਸ:**
- Spring Boot ਦੇ reactive stack ਨਾਲ `Flux` ਸਟ੍ਰੀਮਿੰਗ ਲਈ ਵਰਤਦਾ ਹੈ
- `ServerSentEvent` ਘਟਨਾ ਪ੍ਰਕਾਰਾਂ ਨਾਲ ਸੰਰਚਿਤ ਇਵੈਂਟ ਸਟ੍ਰੀਮਿੰਗ ਦਿੰਦਾ ਹੈ
- `WebClient` `bodyToFlux()` ਨਾਲ reactive ਸਟ੍ਰੀਮਿੰਗ ਖਪਤ ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ
- `delayElements()` ਇਵੈਂਟਾਂ ਵਿਚਕਾਰ ਪ੍ਰਕਿਰਿਆ ਸਮਾਂ ਨਕਲ ਕਰਦਾ ਹੈ
- ਇਵੈਂਟਾਂ ਦੇ ਪ੍ਰਕਾਰ (`info`, `result`) ਹੋ ਸਕਦੇ ਹਨ ਜੋ ਕਲਾਇੰਟ ਲਈ ਬਿਹਤਰ ਸੰਭਾਲ ਮੁਹੱਈਆ ਕਰਦੇ ਹਨ

</details>

### ਤੁਲਨਾ: ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਵਿਰੁੱਧ MCP ਸਟ੍ਰੀਮਿੰਗ

ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਅਤੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਵਿੱਚ ਕੰਮ ਕਰਨ ਦੇ ਤਰੀਕਿਆਂ ਵਿੱਚ ਇਹ ਫਰਕ ਹੈ:

| ਵਿਸ਼ੇਸ਼ਤਾ              | ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ          | MCP ਸਟ੍ਰੀਮਿੰਗ (ਸੂਚਨਾਵਾਂ)          |
|------------------------|-------------------------------|-------------------------------------|
| ਮੁੱਖ ਜਵਾਬ             | ਚੰਕਡ                         | ਇਕੱਲਾ, ਅੰਤ ਵਿੱਚ                    |
| ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ          | ਡਾਟਾ ਚੰਕ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ  | ਸੂਚਨਾਵਾਂ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ        |
| ਕਲਾਇੰਟ ਦੀ ਲੋੜ          | ਸਟ੍ਰੀਮ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ | ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਲਾਗੂ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ |
| ਵਰਤੋਂ ਦਾ ਕੇਸ           | ਵੱਡੀਆਂ ਫਾਈਲਾਂ, AI ਟੋਕਨ ਸਟ੍ਰੀਮ | ਪ੍ਰਗਤੀ, ਲੌਗ, ਰੀਅਲ-ਟਾਈਮ ਫੀਡਬੈਕ     |

### ਮੁੱਖ ਫਰਕ

ਹੋਰ ਕੁਝ ਮੁੱਖ ਫਰਕ ਇਹ ਹਨ:

- **ਸੰਚਾਰ ਪੈਟਰਨ:**
   - ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ: ਸਧਾਰਣ ਚੰਕਡ ਟ੍ਰਾਂਸਫਰ ਕੋਡਿੰਗ ਨਾਲ ਡਾਟਾ ਭੇਜਦਾ ਹੈ
   - MCP ਸਟ੍ਰੀਮਿੰਗ: JSON-RPC ਪ੍ਰੋਟੋਕੋਲ ਨਾਲ ਸੰਰਚਿਤ ਸੂਚਨਾ ਪ੍ਰਣਾਲੀ ਵਰਤਦਾ ਹੈ

- **ਸੁਨੇਹਾ ਫਾਰਮੈਟ:**
   - ਕਲਾਸਿਕ HTTP: ਨਿਊਲਾਈਨ ਸਮੇਤ ਸਧਾਰਣ ਟੈਕਸਟ ਚੰਕ
   - MCP: ਮੈਟਾਡੇਟਾ ਸਮੇਤ ਸੰਰਚਿਤ LoggingMessageNotification ਆਬਜੈਕਟ

- **ਕਲਾਇੰਟ ਲਾਗੂ ਕਰਨ:**
   - ਕਲਾਸਿਕ HTTP: ਸਧਾਰਣ ਕਲਾਇੰਟ ਜੋ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਪ੍ਰਕਿਰਿਆ ਕਰਦਾ ਹੈ
   - MCP: ਵਧੀਆ ਕਲਾਇੰਟ ਜਿਸ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਕਿਸਮਾਂ ਦੇ ਸੁਨੇਹਿਆਂ ਨੂੰ ਸੰਭਾਲਣ ਲਈ ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਹੁੰਦਾ ਹੈ

- **ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ:**
   - ਕਲਾਸਿਕ HTTP: ਪ੍ਰਗਤੀ ਮੁੱਖ ਜਵਾਬ ਸਟ੍ਰੀਮ ਦਾ ਹਿੱਸਾ ਹੁੰਦੀ ਹੈ
   - MCP: ਪ੍ਰਗਤੀ ਵੱਖ-ਵੱਖ ਸੂਚਨਾ ਸੁਨੇਹਿਆਂ ਰਾਹੀਂ ਭੇਜੀ ਜਾਂਦੀ ਹੈ ਜਦਕਿ ਮੁੱਖ ਜਵਾਬ ਅੰਤ ਵਿੱਚ ਆਉਂਦਾ ਹੈ

### ਸਿਫਾਰਸ਼ਾਂ

ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ (ਜਿਵੇਂ `/stream` ਐਂਡਪੌਇੰਟ ਨਾਲ) ਅਤੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਵਿਚੋਂ ਚੁਣਦੇ ਸਮੇਂ ਕੁਝ ਸਿਫਾਰਸ਼ਾਂ ਹਨ:

- **ਸਧਾਰਣ ਸਟ੍ਰੀਮਿੰਗ ਲੋੜਾਂ ਲਈ:** ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ ਲਾਗੂ ਕਰਨ ਵਿੱਚ ਸੌਖਾ ਅਤੇ ਬੁਨਿਆਦੀ ਲੋੜਾਂ ਲਈ ਕਾਫ਼ੀ ਹੈ।

- **ਜਟਿਲ, ਇੰਟਰਐਕਟਿਵ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** MCP ਸਟ੍ਰੀਮਿੰਗ ਵਧੀਆ ਸੰਰਚਿਤ ਪਹੁੰਚ ਦਿੰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਧਨਾਢ ਮੈਟਾਡੇਟਾ ਅਤੇ ਸੂਚਨਾਵਾਂ ਅਤੇ ਅੰਤਿਮ ਨਤੀਜਿਆਂ ਵਿਚਕਾਰ ਵੱਖਰਾ ਹੁੰਦਾ ਹੈ।

- **AI ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** MCP ਦੀ ਸੂਚਨਾ ਪ੍ਰਣਾਲੀ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ AI ਕੰਮਾਂ ਲਈ ਖਾਸ ਤੌਰ 'ਤੇ ਲਾਭਦਾਇਕ ਹੈ ਜਿੱਥੇ ਤੁਸੀਂ ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਪ੍ਰਗਤੀ ਬਾਰੇ ਜਾਣੂ ਰੱਖਣਾ ਚਾਹੁੰਦੇ ਹੋ।

## MCP ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ

ਠੀਕ ਹੈ, ਹੁਣ ਤੱਕ ਤੁਸੀਂ ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਅਤੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਵਿਚਕਾਰ ਕੁਝ ਸਿਫਾਰਸ਼ਾਂ ਅਤੇ ਤੁਲਨਾਵਾਂ ਦੇਖੀਆਂ ਹਨ। ਆਓ ਵੇਖੀਏ ਕਿ MCP ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਕਿਵੇਂ ਵਰਤਿਆ ਜਾ ਸਕਦਾ ਹੈ।

MCP ਫਰੇਮਵਰਕ ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ ਕਿਵੇਂ ਕੰਮ ਕਰਦੀ ਹੈ ਇਹ ਸਮਝਣਾ ਜ਼ਰੂਰੀ ਹੈ ਤਾਂ ਜੋ ਤੁਸੀਂ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ ਓਪਰੇਸ਼ਨਾਂ ਦੌਰਾਨ ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਫੀਡਬੈਕ ਦੇਣ ਵਾਲੀਆਂ ਪ੍ਰਤੀਕਿਰਿਆਸ਼ੀਲ ਐਪਲੀਕੇਸ਼ਨਾਂ ਬਣਾ ਸਕੋ।

MCP ਵਿੱਚ, ਸਟ੍ਰੀਮਿੰਗ ਦਾ ਮਤਲਬ ਮੁੱਖ ਜਵਾਬ ਨੂੰ ਚੰਕਾਂ ਵਿੱਚ ਭੇਜਣਾ ਨਹੀਂ, ਸਗੋਂ ਟੂਲ ਦੇ ਪ੍ਰਕਿਰਿਆ ਕਰਦੇ ਸਮੇਂ ਕਲਾਇੰਟ ਨੂੰ **ਸੂਚਨਾਵਾਂ** ਭੇਜਣਾ ਹੈ। ਇਹ ਸੂਚਨਾਵਾਂ ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ, ਲੌਗ ਜਾਂ ਹੋਰ ਘਟਨਾਵਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ।

### ਇਹ ਕਿਵੇਂ ਕੰਮ ਕਰਦਾ ਹੈ

ਮੁੱਖ ਨਤੀਜਾ ਅਜੇ ਵੀ ਇੱਕ ਇਕੱਲੇ ਜਵਾਬ ਵਜੋਂ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ। ਪਰ ਪ੍ਰਕਿਰਿਆ ਦੌਰਾਨ ਵੱਖ-ਵੱਖ ਸੁਨੇਹੇ ਵਜੋਂ ਸੂਚਨਾਵਾਂ ਭੇਜੀਆਂ ਜਾ ਸਕਦੀਆਂ ਹਨ ਜੋ ਕਲਾਇੰਟ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ ਦਿੰਦੀਆਂ ਹਨ। ਕਲਾਇੰਟ ਨੂੰ ਇਹ ਸੂਚਨਾਵਾਂ ਸੰਭਾਲਣ ਅਤੇ ਦਿਖਾਉਣ ਯੋਗ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।

## ਸੂਚਨਾ ਕੀ ਹੈ?

ਅਸੀਂ "ਸੂਚਨਾ" ਬਾਰੇ ਗੱਲ ਕੀਤੀ, MCP ਦੇ ਸੰਦਰਭ ਵਿੱਚ ਇਸਦਾ ਕੀ ਮਤਲਬ ਹੈ?

ਸੂਚਨਾ ਇੱਕ ਸੁਨੇਹਾ ਹੈ ਜੋ ਸਰਵਰ ਵੱਲੋਂ ਕਲਾਇੰਟ ਨੂੰ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ ਤਾਂ ਜੋ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ ਓਪਰੇਸ਼ਨ ਦੌਰਾਨ ਪ੍ਰਗਤੀ, ਸਥਿਤੀ ਜਾਂ ਹੋਰ ਘਟਨਾਵਾਂ ਬਾਰੇ ਜਾਣੂ ਕਰਵਾਇਆ ਜਾ ਸਕੇ। ਸੂਚਨਾਵਾਂ ਪਾਰਦਰਸ਼ਤਾ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ ਨੂੰ ਸੁਧਾਰਦੀਆਂ ਹਨ।

ਉਦਾਹਰਨ ਵਜੋਂ, ਜਦੋਂ ਕਲਾਇੰਟ ਸਰਵਰ ਨਾਲ ਸ਼ੁਰੂਆਤੀ ਹੈਂਡਸ਼ੇਕ ਕਰ ਲੈਂਦਾ ਹੈ, ਤਾਂ ਇੱਕ ਸੂਚਨਾ ਭੇਜਣੀ ਚਾਹੀਦੀ ਹੈ।

ਇੱਕ ਸੂਚਨਾ JSON ਸੁਨੇਹੇ ਵਜੋਂ ਇਸ ਤਰ੍ਹਾਂ ਦਿਖਦੀ ਹੈ:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

ਸੂਚਨਾਵਾਂ MCP ਵਿੱਚ ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) ਨਾਮਕ ਵਿਸ਼ੇ ਨਾਲ ਸੰਬੰਧਿਤ ਹੁੰਦੀਆਂ ਹਨ।

ਲੌਗਿੰਗ ਨੂੰ ਕੰਮ ਕਰਨ ਲਈ, ਸਰਵਰ ਨੂੰ ਇਸਨੂੰ ਫੀਚਰ/ਸਮਰੱਥਾ ਵਜੋਂ ਯੋਗ ਕਰਨਾ ਪੈਂਦਾ ਹੈ:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ਵਰਤੇ ਗਏ SDK ਦੇ ਅਨੁਸਾਰ, ਲੌਗਿੰਗ ਡਿਫਾਲਟ ਰੂਪ ਵਿੱਚ ਯੋਗ ਹੋ ਸਕਦੀ ਹੈ, ਜਾਂ ਤੁਹਾਨੂੰ ਆਪਣੇ ਸਰਵਰ ਸੰਰਚਨਾ ਵਿੱਚ ਇਸਨੂੰ ਖੁਦ ਯੋਗ ਕਰਨਾ ਪੈ ਸਕਦਾ ਹੈ।

ਸੂਚਨਾਵਾਂ ਦੇ ਵੱਖ-ਵੱਖ ਕਿਸਮਾਂ ਹਨ:

| ਪੱਧਰ       | ਵਰਣਨ                         | ਉਦਾਹਰਨ ਵਰਤੋਂ ਦਾ ਕੇਸ           |
|-------------|------------------------------|-------------------------------|
| debug       | ਵਿਸਥਾਰਪੂਰਕ ਡੀਬੱਗਿੰਗ ਜਾਣਕਾਰੀ | ਫੰਕਸ਼ਨ ਐਂਟਰੀ/ਐਗਜ਼ਿਟ ਪੁਆਇੰਟ  |
| info        | ਆਮ ਜਾਣਕਾਰੀ ਸੁਨੇਹੇ           | ਓਪਰੇਸ਼ਨ ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ          |
| notice      | ਆਮ ਪਰ ਮਹੱਤਵਪੂਰਨ ਘਟਨਾਵਾਂ   | ਸੰਰਚਨਾ ਬਦਲਾਅ                  |
| warning     | ਚੇਤਾਵਨੀ ਸਥਿਤੀਆਂ            | ਡੀਪ੍ਰੀਕੇ

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**Client Example:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## ਸੁਰੱਖਿਆ ਸੰਬੰਧੀ ਵਿਚਾਰ

ਜਦੋਂ MCP ਸਰਵਰਾਂ ਨੂੰ HTTP-ਆਧਾਰਿਤ ਟ੍ਰਾਂਸਪੋਰਟ ਨਾਲ ਲਾਗੂ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਸੁਰੱਖਿਆ ਸਭ ਤੋਂ ਵੱਡੀ ਚਿੰਤਾ ਬਣ ਜਾਂਦੀ ਹੈ ਜਿਸ ਲਈ ਕਈ ਤਰ੍ਹਾਂ ਦੇ ਹਮਲਿਆਂ ਅਤੇ ਸੁਰੱਖਿਆ ਮਕੈਨਿਜ਼ਮਾਂ 'ਤੇ ਧਿਆਨ ਦੇਣਾ ਜਰੂਰੀ ਹੁੰਦਾ ਹੈ।

### ਝਲਕ

HTTP 'ਤੇ MCP ਸਰਵਰਾਂ ਨੂੰ ਖੋਲ੍ਹਣ ਸਮੇਂ ਸੁਰੱਖਿਆ ਬਹੁਤ ਜਰੂਰੀ ਹੁੰਦੀ ਹੈ। Streamable HTTP ਨਵੇਂ ਹਮਲੇ ਦੇ ਮੌਕੇ ਲਿਆਉਂਦਾ ਹੈ ਅਤੇ ਇਸ ਲਈ ਸਾਵਧਾਨੀ ਨਾਲ ਸੰਰਚਨਾ ਕਰਨ ਦੀ ਲੋੜ ਹੁੰਦੀ ਹੈ।

### ਮੁੱਖ ਗੱਲਾਂ
- **Origin Header ਦੀ ਜਾਂਚ**: DNS rebinding ਹਮਲਿਆਂ ਤੋਂ ਬਚਣ ਲਈ ਹਮੇਸ਼ਾ `Origin` ਹੈਡਰ ਦੀ ਜਾਂਚ ਕਰੋ।
- **Localhost ਬਾਈਂਡਿੰਗ**: ਸਥਾਨਕ ਵਿਕਾਸ ਲਈ ਸਰਵਰਾਂ ਨੂੰ `localhost` ਨਾਲ ਬਾਈਂਡ ਕਰੋ ਤਾਂ ਜੋ ਉਹ ਪਬਲਿਕ ਇੰਟਰਨੈੱਟ 'ਤੇ ਨਾ ਖੁਲ੍ਹਣ।
- **ਪ੍ਰਮਾਣਿਕਤਾ**: ਪ੍ਰੋਡਕਸ਼ਨ ਡਿਪਲੋਇਮੈਂਟ ਲਈ ਪ੍ਰਮਾਣਿਕਤਾ (ਜਿਵੇਂ API keys, OAuth) ਲਾਗੂ ਕਰੋ।
- **CORS**: Cross-Origin Resource Sharing (CORS) ਨੀਤੀਆਂ ਨੂੰ ਸੰਰਚਿਤ ਕਰੋ ਤਾਂ ਜੋ ਪਹੁੰਚ ਸੀਮਿਤ ਰਹੇ।
- **HTTPS**: ਟ੍ਰੈਫਿਕ ਨੂੰ ਇਨਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਪ੍ਰੋਡਕਸ਼ਨ ਵਿੱਚ HTTPS ਵਰਤੋਂ।

### ਵਧੀਆ ਅਭਿਆਸ
- ਬਿਨਾਂ ਜਾਂਚ ਕੀਤੇ ਆਉਣ ਵਾਲੇ ਰਿਕਵੇਸਟਾਂ 'ਤੇ ਕਦੇ ਭਰੋਸਾ ਨਾ ਕਰੋ।
- ਸਾਰੇ ਐਕਸੈਸ ਅਤੇ ਗਲਤੀਆਂ ਨੂੰ ਲੌਗ ਅਤੇ ਮਾਨੀਟਰ ਕਰੋ।
- ਸੁਰੱਖਿਆ ਖਾਮੀਆਂ ਨੂੰ ਠੀਕ ਕਰਨ ਲਈ ਨਿਯਮਤ ਤੌਰ 'ਤੇ ਡਿਪੈਂਡੈਂਸੀਜ਼ ਨੂੰ ਅੱਪਡੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ
- ਵਿਕਾਸ ਦੀ ਸੌਖਿਆ ਅਤੇ ਸੁਰੱਖਿਆ ਵਿਚ ਸੰਤੁਲਨ ਬਣਾਈ ਰੱਖਣਾ
- ਵੱਖ-ਵੱਖ ਕਲਾਇੰਟ ਵਾਤਾਵਰਣਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਯਕੀਨੀ ਬਣਾਉਣਾ


## SSE ਤੋਂ Streamable HTTP ਵੱਲ ਅਪਗ੍ਰੇਡ ਕਰਨਾ

ਜਿਹੜੀਆਂ ਐਪਲੀਕੇਸ਼ਨਾਂ ਵਿੱਚ ਹਾਲੇ Server-Sent Events (SSE) ਵਰਤੇ ਜਾ ਰਹੇ ਹਨ, ਉਨ੍ਹਾਂ ਲਈ Streamable HTTP ਵੱਲ ਮਾਈਗ੍ਰੇਟ ਕਰਨਾ ਵਧੀਆ ਸਮਰੱਥਾ ਅਤੇ ਲੰਬੇ ਸਮੇਂ ਲਈ MCP ਲਾਗੂ ਕਰਨ ਦੀ ਸਥਿਰਤਾ ਦਿੰਦਾ ਹੈ।

### ਅਪਗ੍ਰੇਡ ਕਰਨ ਦੇ ਕਾਰਨ

SSE ਤੋਂ Streamable HTTP ਵੱਲ ਅਪਗ੍ਰੇਡ ਕਰਨ ਲਈ ਦੋ ਮੁੱਖ ਕਾਰਨ ਹਨ:

- Streamable HTTP SSE ਨਾਲੋਂ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ, ਅਨੁਕੂਲਤਾ ਅਤੇ ਧਨਾਢਯ ਸੂਚਨਾ ਸਹਾਇਤਾ ਦਿੰਦਾ ਹੈ।
- ਇਹ ਨਵੀਆਂ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ ਸਿਫਾਰਸ਼ੀ ਟ੍ਰਾਂਸਪੋਰਟ ਹੈ।

### ਮਾਈਗ੍ਰੇਸ਼ਨ ਕਦਮ

ਆਪਣੀਆਂ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਵਿੱਚ SSE ਤੋਂ Streamable HTTP ਵੱਲ ਮਾਈਗ੍ਰੇਟ ਕਰਨ ਲਈ ਇਹ ਕਦਮ ਲਓ:

- ਸਰਵਰ ਕੋਡ ਨੂੰ `mcp.run()` ਵਿੱਚ `transport="streamable-http"` ਵਰਤਣ ਲਈ ਅੱਪਡੇਟ ਕਰੋ।
- ਕਲਾਇੰਟ ਕੋਡ ਨੂੰ SSE ਕਲਾਇੰਟ ਦੀ ਥਾਂ `streamablehttp_client` ਵਰਤਣ ਲਈ ਅੱਪਡੇਟ ਕਰੋ।
- ਕਲਾਇੰਟ ਵਿੱਚ ਸੂਚਨਾਵਾਂ ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰਨ ਲਈ ਇੱਕ ਮੈਸੇਜ ਹੈਂਡਲਰ ਲਾਗੂ ਕਰੋ।
- ਮੌਜੂਦਾ ਟੂਲਾਂ ਅਤੇ ਵਰਕਫਲੋਜ਼ ਨਾਲ ਅਨੁਕੂਲਤਾ ਦੀ ਜਾਂਚ ਕਰੋ।

### ਅਨੁਕੂਲਤਾ ਬਣਾਈ ਰੱਖਣਾ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੌਰਾਨ ਮੌਜੂਦਾ SSE ਕਲਾਇੰਟਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਬਣਾਈ ਰੱਖਣ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਕੁਝ ਤਰੀਕੇ ਇਹ ਹਨ:

- ਤੁਸੀਂ ਦੋਹਾਂ SSE ਅਤੇ Streamable HTTP ਨੂੰ ਵੱਖ-ਵੱਖ ਐਂਡਪੌਇੰਟਾਂ 'ਤੇ ਚਲਾ ਕੇ ਸਹਾਇਤਾ ਕਰ ਸਕਦੇ ਹੋ।
- ਕਲਾਇੰਟਾਂ ਨੂੰ ਧੀਰੇ-ਧੀਰੇ ਨਵੇਂ ਟ੍ਰਾਂਸਪੋਰਟ ਵੱਲ ਮਾਈਗ੍ਰੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੌਰਾਨ ਇਹ ਚੁਣੌਤੀਆਂ ਸਾਹਮਣੇ ਆ ਸਕਦੀਆਂ ਹਨ:

- ਸਾਰੇ ਕਲਾਇੰਟਾਂ ਨੂੰ ਅੱਪਡੇਟ ਕਰਨਾ ਯਕੀਨੀ ਬਣਾਉਣਾ
- ਸੂਚਨਾ ਦੇਣ ਵਿੱਚ ਫਰਕਾਂ ਨੂੰ ਸੰਭਾਲਣਾ

## ਸੁਰੱਖਿਆ ਸੰਬੰਧੀ ਵਿਚਾਰ

ਕਿਸੇ ਵੀ ਸਰਵਰ ਨੂੰ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ, ਖਾਸ ਕਰਕੇ MCP ਵਿੱਚ Streamable HTTP ਵਰਗੇ HTTP-ਆਧਾਰਿਤ ਟ੍ਰਾਂਸਪੋਰਟਾਂ ਦੀ ਵਰਤੋਂ ਕਰਦੇ ਸਮੇਂ, ਸੁਰੱਖਿਆ ਸਭ ਤੋਂ ਵੱਡੀ ਪ੍ਰਾਥਮਿਕਤਾ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।

ਜਦੋਂ MCP ਸਰਵਰਾਂ ਨੂੰ HTTP-ਆਧਾਰਿਤ ਟ੍ਰਾਂਸਪੋਰਟ ਨਾਲ ਲਾਗੂ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਸੁਰੱਖਿਆ ਸਭ ਤੋਂ ਵੱਡੀ ਚਿੰਤਾ ਬਣ ਜਾਂਦੀ ਹੈ ਜਿਸ ਲਈ ਕਈ ਤਰ੍ਹਾਂ ਦੇ ਹਮਲਿਆਂ ਅਤੇ ਸੁਰੱਖਿਆ ਮਕੈਨਿਜ਼ਮਾਂ 'ਤੇ ਧਿਆਨ ਦੇਣਾ ਜਰੂਰੀ ਹੁੰਦਾ ਹੈ।

### ਝਲਕ

HTTP 'ਤੇ MCP ਸਰਵਰਾਂ ਨੂੰ ਖੋਲ੍ਹਣ ਸਮੇਂ ਸੁਰੱਖਿਆ ਬਹੁਤ ਜਰੂਰੀ ਹੁੰਦੀ ਹੈ। Streamable HTTP ਨਵੇਂ ਹਮਲੇ ਦੇ ਮੌਕੇ ਲਿਆਉਂਦਾ ਹੈ ਅਤੇ ਇਸ ਲਈ ਸਾਵਧਾਨੀ ਨਾਲ ਸੰਰਚਨਾ ਕਰਨ ਦੀ ਲੋੜ ਹੁੰਦੀ ਹੈ।

ਇੱਥੇ ਕੁਝ ਮੁੱਖ ਸੁਰੱਖਿਆ ਵਿਚਾਰ ਹਨ:

- **Origin Header ਦੀ ਜਾਂਚ**: DNS rebinding ਹਮਲਿਆਂ ਤੋਂ ਬਚਣ ਲਈ ਹਮੇਸ਼ਾ `Origin` ਹੈਡਰ ਦੀ ਜਾਂਚ ਕਰੋ।
- **Localhost ਬਾਈਂਡਿੰਗ**: ਸਥਾਨਕ ਵਿਕਾਸ ਲਈ ਸਰਵਰਾਂ ਨੂੰ `localhost` ਨਾਲ ਬਾਈਂਡ ਕਰੋ ਤਾਂ ਜੋ ਉਹ ਪਬਲਿਕ ਇੰਟਰਨੈੱਟ 'ਤੇ ਨਾ ਖੁਲ੍ਹਣ।
- **ਪ੍ਰਮਾਣਿਕਤਾ**: ਪ੍ਰੋਡਕਸ਼ਨ ਡਿਪਲੋਇਮੈਂਟ ਲਈ ਪ੍ਰਮਾਣਿਕਤਾ (ਜਿਵੇਂ API keys, OAuth) ਲਾਗੂ ਕਰੋ।
- **CORS**: Cross-Origin Resource Sharing (CORS) ਨੀਤੀਆਂ ਨੂੰ ਸੰਰਚਿਤ ਕਰੋ ਤਾਂ ਜੋ ਪਹੁੰਚ ਸੀਮਿਤ ਰਹੇ।
- **HTTPS**: ਟ੍ਰੈਫਿਕ ਨੂੰ ਇਨਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਪ੍ਰੋਡਕਸ਼ਨ ਵਿੱਚ HTTPS ਵਰਤੋਂ।

### ਵਧੀਆ ਅਭਿਆਸ

ਇਸ ਤੋਂ ਇਲਾਵਾ, ਆਪਣੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ ਇਹ ਵਧੀਆ ਅਭਿਆਸ ਮੰਨੋ:

- ਬਿਨਾਂ ਜਾਂਚ ਕੀਤੇ ਆਉਣ ਵਾਲੇ ਰਿਕਵੇਸਟਾਂ 'ਤੇ ਕਦੇ ਭਰੋਸਾ ਨਾ ਕਰੋ।
- ਸਾਰੇ ਐਕਸੈਸ ਅਤੇ ਗਲਤੀਆਂ ਨੂੰ ਲੌਗ ਅਤੇ ਮਾਨੀਟਰ ਕਰੋ।
- ਸੁਰੱਖਿਆ ਖਾਮੀਆਂ ਨੂੰ ਠੀਕ ਕਰਨ ਲਈ ਨਿਯਮਤ ਤੌਰ 'ਤੇ ਡਿਪੈਂਡੈਂਸੀਜ਼ ਨੂੰ ਅੱਪਡੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰਾਂ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ ਤੁਹਾਨੂੰ ਕੁਝ ਚੁਣੌਤੀਆਂ ਦਾ ਸਾਹਮਣਾ ਕਰਨਾ ਪਵੇਗਾ:

- ਵਿਕਾਸ ਦੀ ਸੌਖਿਆ ਅਤੇ ਸੁਰੱਖਿਆ ਵਿਚ ਸੰਤੁਲਨ ਬਣਾਈ ਰੱਖਣਾ
- ਵੱਖ-ਵੱਖ ਕਲਾਇੰਟ ਵਾਤਾਵਰਣਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਯਕੀਨੀ ਬਣਾਉਣਾ

### ਅਸਾਈਨਮੈਂਟ: ਆਪਣੀ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪ ਬਣਾਓ

**ਦ੍ਰਿਸ਼ਟੀਕੋਣ:**
ਇੱਕ MCP ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਬਣਾਓ ਜਿੱਥੇ ਸਰਵਰ ਆਈਟਮਾਂ ਦੀ ਸੂਚੀ (ਜਿਵੇਂ ਫਾਈਲਾਂ ਜਾਂ ਦਸਤਾਵੇਜ਼) ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰਦਾ ਹੈ ਅਤੇ ਹਰ ਪ੍ਰੋਸੈਸ ਕੀਤੇ ਆਈਟਮ ਲਈ ਸੂਚਨਾ ਭੇਜਦਾ ਹੈ। ਕਲਾਇੰਟ ਹਰ ਸੂਚਨਾ ਨੂੰ ਜਿਵੇਂ ਹੀ ਮਿਲੇ, ਦਿਖਾਏ।

**ਕਦਮ:**

1. ਇੱਕ ਸਰਵਰ ਟੂਲ ਲਾਗੂ ਕਰੋ ਜੋ ਸੂਚੀ ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰੇ ਅਤੇ ਹਰ ਆਈਟਮ ਲਈ ਸੂਚਨਾ ਭੇਜੇ।
2. ਇੱਕ ਕਲਾਇੰਟ ਲਾਗੂ ਕਰੋ ਜਿਸ ਵਿੱਚ ਮੈਸੇਜ ਹੈਂਡਲਰ ਹੋਵੇ ਜੋ ਸੂਚਨਾਵਾਂ ਨੂੰ ਰੀਅਲ ਟਾਈਮ ਵਿੱਚ ਦਿਖਾਏ।
3. ਆਪਣੇ ਲਾਗੂ ਕਰਨ ਦੀ ਜਾਂਚ ਕਰਨ ਲਈ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਦੋਹਾਂ ਚਲਾਓ ਅਤੇ ਸੂਚਨਾਵਾਂ ਨੂੰ ਦੇਖੋ।

[Solution](./solution/README.md)

## ਹੋਰ ਪੜ੍ਹਾਈ ਅਤੇ ਅਗਲਾ ਕਦਮ?

MCP ਸਟ੍ਰੀਮਿੰਗ ਨਾਲ ਆਪਣਾ ਸਫਰ ਜਾਰੀ ਰੱਖਣ ਅਤੇ ਆਪਣਾ ਗਿਆਨ ਵਧਾਉਣ ਲਈ, ਇਹ ਹਿੱਸਾ ਵਧੇਰੇ ਸਰੋਤ ਅਤੇ ਅਗਲੇ ਕਦਮਾਂ ਦੀ ਸਿਫਾਰਸ਼ ਕਰਦਾ ਹੈ ਜੋ ਤੁਹਾਨੂੰ ਹੋਰ ਅਡਵਾਂਸ ਐਪਲੀਕੇਸ਼ਨਾਂ ਬਣਾਉਣ ਵਿੱਚ ਮਦਦ ਕਰਨਗੇ।

### ਹੋਰ ਪੜ੍ਹਾਈ

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### ਅਗਲਾ ਕਦਮ?

- ਅਜਿਹੇ MCP ਟੂਲ ਬਣਾਉ ਜੋ ਰੀਅਲ-ਟਾਈਮ ਵਿਸ਼ਲੇਸ਼ਣ, ਚੈਟ ਜਾਂ ਸਹਿਯੋਗੀ ਸੰਪਾਦਨ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਦੇ ਹੋਣ।
- MCP ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਫਰੰਟਐਂਡ ਫਰੇਮਵਰਕਾਂ (React, Vue ਆਦਿ) ਨਾਲ ਜੋੜ ਕੇ ਲਾਈਵ UI ਅੱਪਡੇਟ ਲਈ ਖੋਜ ਕਰੋ।
- ਅਗਲਾ: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**ਅਸਵੀਕਾਰੋਪੱਤਰ**:  
ਇਹ ਦਸਤਾਵੇਜ਼ AI ਅਨੁਵਾਦ ਸੇਵਾ [Co-op Translator](https://github.com/Azure/co-op-translator) ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅਨੁਵਾਦਿਤ ਕੀਤਾ ਗਿਆ ਹੈ। ਜਦੋਂ ਕਿ ਅਸੀਂ ਸਹੀਤਾ ਲਈ ਕੋਸ਼ਿਸ਼ ਕਰਦੇ ਹਾਂ, ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਰੱਖੋ ਕਿ ਸਵੈਚਾਲਿਤ ਅਨੁਵਾਦਾਂ ਵਿੱਚ ਗਲਤੀਆਂ ਜਾਂ ਅਸਮਰਥਤਾਵਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ। ਮੂਲ ਦਸਤਾਵੇਜ਼ ਆਪਣੀ ਮੂਲ ਭਾਸ਼ਾ ਵਿੱਚ ਹੀ ਅਧਿਕਾਰਤ ਸਰੋਤ ਮੰਨਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ। ਮਹੱਤਵਪੂਰਨ ਜਾਣਕਾਰੀ ਲਈ, ਪੇਸ਼ੇਵਰ ਮਨੁੱਖੀ ਅਨੁਵਾਦ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਇਸ ਅਨੁਵਾਦ ਦੀ ਵਰਤੋਂ ਨਾਲ ਹੋਣ ਵਾਲੀਆਂ ਕਿਸੇ ਵੀ ਗਲਤਫਹਿਮੀਆਂ ਜਾਂ ਗਲਤ ਵਿਆਖਿਆਵਾਂ ਲਈ ਅਸੀਂ ਜ਼ਿੰਮੇਵਾਰ ਨਹੀਂ ਹਾਂ।