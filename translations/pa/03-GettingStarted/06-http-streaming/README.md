<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T18:20:30+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "pa"
}
-->
# HTTPS ਸਟ੍ਰੀਮਿੰਗ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ

ਇਸ ਅਧਿਆਇ ਵਿੱਚ HTTPS ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਮਾਡਲ ਕਾਂਟੈਕਸਟ ਪ੍ਰੋਟੋਕੋਲ (MCP) ਨਾਲ ਸੁਰੱਖਿਅਤ, ਸਕੇਲ ਕਰਨ ਯੋਗ ਅਤੇ ਰੀਅਲ-ਟਾਈਮ ਸਟ੍ਰੀਮਿੰਗ ਲਾਗੂ ਕਰਨ ਲਈ ਵਿਸਤ੍ਰਿਤ ਮਾਰਗਦਰਸ਼ਨ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਇਹ ਸਟ੍ਰੀਮਿੰਗ ਦੀ ਪ੍ਰੇਰਣਾ, ਉਪਲਬਧ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ, MCP ਵਿੱਚ ਸਟ੍ਰੀਮ ਕਰਨ ਯੋਗ HTTP ਨੂੰ ਕਿਵੇਂ ਲਾਗੂ ਕਰਨਾ ਹੈ, ਸੁਰੱਖਿਆ ਦੀਆਂ ਵਧੀਆ ਪ੍ਰਥਾਵਾਂ, SSE ਤੋਂ ਮਾਈਗ੍ਰੇਸ਼ਨ ਅਤੇ ਆਪਣੇ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਬਣਾਉਣ ਲਈ ਪ੍ਰਯੋਗਿਕ ਮਦਦ ਨੂੰ ਕਵਰ ਕਰਦਾ ਹੈ।

## MCP ਵਿੱਚ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ ਸਟ੍ਰੀਮਿੰਗ

ਇਸ ਭਾਗ ਵਿੱਚ MCP ਵਿੱਚ ਉਪਲਬਧ ਵੱਖ-ਵੱਖ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਅਤੇ ਉਹਨਾਂ ਦੀ ਭੂਮਿਕਾ ਦੀ ਜਾਂਚ ਕੀਤੀ ਗਈ ਹੈ ਜੋ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰਾਂ ਵਿਚਕਾਰ ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਸਮਰੱਥਾਵਾਂ ਨੂੰ ਯਕੀਨੀ ਬਣਾਉਂਦੇ ਹਨ।

### ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਕੀ ਹੈ?

ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਇਹ ਪਰਿਭਾਸ਼ਿਤ ਕਰਦਾ ਹੈ ਕਿ ਕਿਵੇਂ ਡਾਟਾ ਕਲਾਇੰਟ ਅਤੇ ਸਰਵਰ ਵਿਚਕਾਰ ਅਦਾਨ-ਪ੍ਰਦਾਨ ਹੁੰਦਾ ਹੈ। MCP ਵੱਖ-ਵੱਖ ਵਾਤਾਵਰਣਾਂ ਅਤੇ ਲੋੜਾਂ ਲਈ ਕਈ ਟ੍ਰਾਂਸਪੋਰਟ ਕਿਸਮਾਂ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ:

- **stdio**: ਸਟੈਂਡਰਡ ਇਨਪੁੱਟ/ਆਉਟਪੁੱਟ, ਸਥਾਨਕ ਅਤੇ CLI-ਅਧਾਰਿਤ ਟੂਲਾਂ ਲਈ ਉਚਿਤ। ਸਧਾਰਣ ਪਰ ਵੈੱਬ ਜਾਂ ਕਲਾਉਡ ਲਈ ਉਚਿਤ ਨਹੀਂ।
- **SSE (Server-Sent Events)**: ਸਰਵਰਾਂ ਨੂੰ HTTP ਰਾਹੀਂ ਕਲਾਇੰਟਾਂ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ ਭੇਜਣ ਦੀ ਆਗਿਆ ਦਿੰਦਾ ਹੈ। ਵੈੱਬ UI ਲਈ ਚੰਗਾ, ਪਰ ਸਕੇਲਬਿਲਟੀ ਅਤੇ ਲਚਕੀਲਾਪਣ ਵਿੱਚ ਸੀਮਿਤ।
- **Streamable HTTP**: ਆਧੁਨਿਕ HTTP-ਅਧਾਰਿਤ ਸਟ੍ਰੀਮਿੰਗ ਟ੍ਰਾਂਸਪੋਰਟ, ਸੂਚਨਾਵਾਂ ਅਤੇ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ ਦਾ ਸਮਰਥਨ ਕਰਦਾ ਹੈ। ਜ਼ਿਆਦਾਤਰ ਉਤਪਾਦਨ ਅਤੇ ਕਲਾਉਡ ਸਥਿਤੀਆਂ ਲਈ ਸਿਫਾਰਸ਼ੀ।

### ਤੁਲਨਾਤਮਕ ਟੇਬਲ

ਹੇਠਾਂ ਦਿੱਤੇ ਤੁਲਨਾਤਮਕ ਟੇਬਲ ਨੂੰ ਦੇਖੋ ਤਾਂ ਜੋ ਇਹ ਸਮਝ ਸਕੋ ਕਿ ਇਹ ਟ੍ਰਾਂਸਪੋਰਟ ਮਕੈਨਿਜ਼ਮ ਕਿਵੇਂ ਵੱਖ-ਵੱਖ ਹਨ:

| ਟ੍ਰਾਂਸਪੋਰਟ         | ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ | ਸਟ੍ਰੀਮਿੰਗ | ਸਕੇਲਬਿਲਟੀ | ਵਰਤੋਂ ਦਾ ਕੇਸ           |
|---------------------|--------------------|-----------|-------------|-------------------------|
| stdio               | ਨਹੀਂ               | ਨਹੀਂ      | ਘੱਟ        | ਸਥਾਨਕ CLI ਟੂਲ          |
| SSE                 | ਹਾਂ                | ਹਾਂ       | ਦਰਮਿਆਨਾ   | ਵੈੱਬ, ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ |
| Streamable HTTP     | ਹਾਂ                | ਹਾਂ       | ਉੱਚ        | ਕਲਾਉਡ, ਬਹੁ-ਕਲਾਇੰਟ      |

> **Tip:** ਸਹੀ ਟ੍ਰਾਂਸਪੋਰਟ ਚੁਣਨਾ ਪ੍ਰਦਰਸ਼ਨ, ਸਕੇਲਬਿਲਟੀ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ 'ਤੇ ਪ੍ਰਭਾਵ ਪਾਂਦਾ ਹੈ। ਆਧੁਨਿਕ, ਸਕੇਲ ਕਰਨ ਯੋਗ ਅਤੇ ਕਲਾਉਡ-ਤਿਆਰ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ **Streamable HTTP** ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ।

ਪਿਛਲੇ ਅਧਿਆਇਆਂ ਵਿੱਚ ਤੁਹਾਨੂੰ ਦਿਖਾਏ ਗਏ stdio ਅਤੇ SSE ਟ੍ਰਾਂਸਪੋਰਟਾਂ ਨੂੰ ਨੋਟ ਕਰੋ ਅਤੇ ਇਸ ਅਧਿਆਇ ਵਿੱਚ ਕਵਰ ਕੀਤਾ ਗਿਆ Streamable HTTP ਟ੍ਰਾਂਸਪੋਰਟ।

## ਸਟ੍ਰੀਮਿੰਗ: ਧਾਰਣਾਵਾਂ ਅਤੇ ਪ੍ਰੇਰਣਾ

ਸਟ੍ਰੀਮਿੰਗ ਦੇ ਮੂਲ ਧਾਰਣਾਵਾਂ ਅਤੇ ਪ੍ਰੇਰਣਾਵਾਂ ਨੂੰ ਸਮਝਣਾ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਰੀਅਲ-ਟਾਈਮ ਸੰਚਾਰ ਪ੍ਰਣਾਲੀਆਂ ਲਾਗੂ ਕਰਨ ਲਈ ਜ਼ਰੂਰੀ ਹੈ।

**ਸਟ੍ਰੀਮਿੰਗ** ਨੈੱਟਵਰਕ ਪ੍ਰੋਗ੍ਰਾਮਿੰਗ ਵਿੱਚ ਇੱਕ ਤਕਨੀਕ ਹੈ ਜੋ ਡਾਟਾ ਨੂੰ ਛੋਟੇ, ਸੰਭਾਲਣ ਯੋਗ ਹਿੱਸਿਆਂ ਵਿੱਚ ਜਾਂ ਘਟਨਾਵਾਂ ਦੀ ਲੜੀ ਵਜੋਂ ਭੇਜਣ ਅਤੇ ਪ੍ਰਾਪਤ ਕਰਨ ਦੀ ਆਗਿਆ ਦਿੰਦੀ ਹੈ, ਨਾ ਕਿ ਪੂਰੇ ਜਵਾਬ ਦੇ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰਨ ਲਈ। ਇਹ ਖਾਸ ਕਰਕੇ ਲਾਭਦਾਇਕ ਹੈ:

- ਵੱਡੀਆਂ ਫਾਈਲਾਂ ਜਾਂ ਡਾਟਾਸੈੱਟਾਂ ਲਈ।
- ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ (ਜਿਵੇਂ ਕਿ ਚੈਟ, ਪ੍ਰਗਤੀ ਬਾਰ)।
- ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੀਆਂ ਗਣਨਾਵਾਂ ਜਿੱਥੇ ਤੁਸੀਂ ਉਪਭੋਗਤਾ ਨੂੰ ਜਾਣੂ ਰੱਖਣਾ ਚਾਹੁੰਦੇ ਹੋ।

ਇੱਥੇ ਸਟ੍ਰੀਮਿੰਗ ਬਾਰੇ ਉੱਚ-ਸਤਰ 'ਤੇ ਜਾਣਕਾਰੀ ਹੈ:

- ਡਾਟਾ ਕ੍ਰਮਵਾਰ ਤੌਰ 'ਤੇ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ, ਸਾਰਾ ਇਕੱਠਾ ਨਹੀਂ।
- ਕਲਾਇੰਟ ਆਉਂਦੇ ਹੀ ਡਾਟਾ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰ ਸਕਦਾ ਹੈ।
- ਲਗਭਗ ਲੇਟੈਂਸੀ ਘਟਾਉਂਦਾ ਹੈ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ ਨੂੰ ਸੁਧਾਰਦਾ ਹੈ।

### ਸਟ੍ਰੀਮਿੰਗ ਕਿਉਂ ਵਰਤੋਂ?

ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਣ ਦੇ ਕਾਰਨ ਇਹ ਹਨ:

- ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਤੁਰੰਤ ਫੀਡਬੈਕ ਮਿਲਦਾ ਹੈ, ਸਿਰਫ ਅੰਤ ਵਿੱਚ ਨਹੀਂ।
- ਰੀਅਲ-ਟਾਈਮ ਐਪਲੀਕੇਸ਼ਨਾਂ ਅਤੇ ਜਵਾਬਦੇਹ UI ਨੂੰ ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ।
- ਨੈੱਟਵਰਕ ਅਤੇ ਕੰਪਿਊਟ ਸਰੋਤਾਂ ਦੀ ਵੱਧ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਵਰਤੋਂ।

### ਸਧਾਰਣ ਉਦਾਹਰਨ: HTTP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ

ਇੱਥੇ ਇੱਕ ਸਧਾਰਣ ਉਦਾਹਰਨ ਹੈ ਕਿ ਸਟ੍ਰੀਮਿੰਗ ਕਿਵੇਂ ਲਾਗੂ ਕੀਤੀ ਜਾ ਸਕਦੀ ਹੈ:

## Python

**ਸਰਵਰ (Python, FastAPI ਅਤੇ StreamingResponse ਦੀ ਵਰਤੋਂ ਨਾਲ):**

### Python

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**ਕਲਾਇੰਟ (Python, requests ਦੀ ਵਰਤੋਂ ਨਾਲ):**

### Python

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

ਇਹ ਉਦਾਹਰਨ ਦਿਖਾਉਂਦੀ ਹੈ ਕਿ ਸਰਵਰ ਕਿਵੇਂ ਕਲਾਇੰਟ ਨੂੰ ਸੁਨੇਹਿਆਂ ਦੀ ਲੜੀ ਭੇਜਦਾ ਹੈ ਜਿਵੇਂ ਹੀ ਉਹ ਉਪਲਬਧ ਹੁੰਦੇ ਹਨ, ਨਾ ਕਿ ਸਾਰੇ ਸੁਨੇਹੇ ਤਿਆਰ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰਦਾ ਹੈ।

**ਕਿਵੇਂ ਕੰਮ ਕਰਦਾ ਹੈ:**
- ਸਰਵਰ ਹਰ ਸੁਨੇਹਾ ਤਿਆਰ ਹੋਣ 'ਤੇ ਭੇਜਦਾ ਹੈ।
- ਕਲਾਇੰਟ ਹਰ ਹਿੱਸਾ ਆਉਂਦੇ ਹੀ ਪ੍ਰਾਪਤ ਕਰਦਾ ਅਤੇ ਪ੍ਰਿੰਟ ਕਰਦਾ ਹੈ।

**ਲੋੜੀਂਦੇ:**
- ਸਰਵਰ ਨੂੰ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਵਰਤਣਾ ਚਾਹੀਦਾ ਹੈ (ਜਿਵੇਂ FastAPI ਵਿੱਚ `StreamingResponse`)।
- ਕਲਾਇੰਟ ਨੂੰ ਜਵਾਬ ਨੂੰ ਸਟ੍ਰੀਮ ਵਜੋਂ ਪ੍ਰਕਿਰਿਆ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ (`stream=True` requests ਵਿੱਚ)।
- Content-Type ਆਮ ਤੌਰ 'ਤੇ `text/event-stream` ਜਾਂ `application/octet-stream` ਹੁੰਦਾ ਹੈ।

## Java

**ਸਰਵਰ (Java, Spring Boot ਅਤੇ Server-Sent Events ਦੀ ਵਰਤੋਂ ਨਾਲ):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ਕਲਾਇੰਟ (Java, Spring WebFlux WebClient ਦੀ ਵਰਤੋਂ ਨਾਲ):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java ਲਾਗੂ ਕਰਨ ਦੇ ਨੋਟਸ:**
- Spring Boot ਦੇ ਰੀਐਕਟਿਵ ਸਟੈਕ ਨਾਲ `Flux` ਦੀ ਵਰਤੋਂ ਕਰਦਾ ਹੈ
- `ServerSentEvent` ਘਟਨਾ ਪ੍ਰਕਾਰਾਂ ਨਾਲ ਸੰਰਚਿਤ ਇਵੈਂਟ ਸਟ੍ਰੀਮਿੰਗ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ
- `WebClient` `bodyToFlux()` ਨਾਲ ਰੀਐਕਟਿਵ ਸਟ੍ਰੀਮਿੰਗ ਖਪਤ ਯੋਗ ਬਣਾਉਂਦਾ ਹੈ
- `delayElements()` ਇਵੈਂਟਾਂ ਵਿਚਕਾਰ ਪ੍ਰਕਿਰਿਆ ਸਮਾਂ ਨਕਲ ਕਰਦਾ ਹੈ
- ਇਵੈਂਟਾਂ ਕੋਲ ਬਿਹਤਰ ਕਲਾਇੰਟ ਹੈਂਡਲਿੰਗ ਲਈ ਪ੍ਰਕਾਰ (ਜਿਵੇਂ `info`, `result`) ਹੋ ਸਕਦੇ ਹਨ

### ਤੁਲਨਾ: ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਵਿਰੁੱਧ MCP ਸਟ੍ਰੀਮਿੰਗ

ਕਿਵੇਂ ਸਟ੍ਰੀਮਿੰਗ "ਕਲਾਸਿਕ" ਢੰਗ ਨਾਲ ਕੰਮ ਕਰਦੀ ਹੈ ਅਤੇ MCP ਵਿੱਚ ਕਿਵੇਂ ਕੰਮ ਕਰਦੀ ਹੈ, ਇਹਨਾਂ ਵਿੱਚ ਫਰਕ ਹੇਠਾਂ ਦਿੱਤੇ ਗਏ ਹਨ:

| ਵਿਸ਼ੇਸ਼ਤਾ              | ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ          | MCP ਸਟ੍ਰੀਮਿੰਗ (ਸੂਚਨਾਵਾਂ)          |
|------------------------|--------------------------------|-------------------------------------|
| ਮੁੱਖ ਜਵਾਬ             | ਚੰਕਡ                          | ਇਕੱਲਾ, ਅੰਤ ਵਿੱਚ                    |
| ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ          | ਡਾਟਾ ਚੰਕ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ   | ਸੂਚਨਾਵਾਂ ਵਜੋਂ ਭੇਜੇ ਜਾਂਦੇ ਹਨ        |
| ਕਲਾਇੰਟ ਦੀ ਲੋੜ          | ਸਟ੍ਰੀਮ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਕਰਨਾ ਲਾਜ਼ਮੀ | ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਲਾਗੂ ਕਰਨਾ ਲਾਜ਼ਮੀ     |
| ਵਰਤੋਂ ਦਾ ਕੇਸ           | ਵੱਡੀਆਂ ਫਾਈਲਾਂ, AI ਟੋਕਨ ਸਟ੍ਰੀਮ | ਪ੍ਰਗਤੀ, ਲੌਗ, ਰੀਅਲ-ਟਾਈਮ ਫੀਡਬੈਕ     |

### ਮੁੱਖ ਫਰਕ

ਹੋਰ ਕੁਝ ਮੁੱਖ ਫਰਕ ਇਹ ਹਨ:

- **ਸੰਚਾਰ ਪੈਟਰਨ:**
   - ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ: ਸਧਾਰਣ ਚੰਕਡ ਟ੍ਰਾਂਸਫਰ ਐਨਕੋਡਿੰਗ ਨਾਲ ਡਾਟਾ ਭੇਜਦਾ ਹੈ
   - MCP ਸਟ੍ਰੀਮਿੰਗ: JSON-RPC ਪ੍ਰੋਟੋਕੋਲ ਨਾਲ ਸੰਰਚਿਤ ਸੂਚਨਾ ਪ੍ਰਣਾਲੀ ਵਰਤਦਾ ਹੈ

- **ਸੁਨੇਹਾ ਫਾਰਮੈਟ:**
   - ਕਲਾਸਿਕ HTTP: ਨਿਊਲਾਈਨ ਸਮੇਤ ਸਧਾਰਣ ਟੈਕਸਟ ਚੰਕ
   - MCP: ਮੈਟਾਡੇਟਾ ਸਮੇਤ ਸੰਰਚਿਤ LoggingMessageNotification ਆਬਜੈਕਟ

- **ਕਲਾਇੰਟ ਲਾਗੂ ਕਰਨ:**
   - ਕਲਾਸਿਕ HTTP: ਸਧਾਰਣ ਕਲਾਇੰਟ ਜੋ ਸਟ੍ਰੀਮਿੰਗ ਜਵਾਬ ਪ੍ਰਕਿਰਿਆ ਕਰਦਾ ਹੈ
   - MCP: ਵਧੀਆ ਕਲਾਇੰਟ ਜਿਸ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਪ੍ਰਕਾਰਾਂ ਦੇ ਸੁਨੇਹਿਆਂ ਲਈ ਸੁਨੇਹਾ ਹੈਂਡਲਰ ਹੁੰਦਾ ਹੈ

- **ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ:**
   - ਕਲਾਸਿਕ HTTP: ਪ੍ਰਗਤੀ ਮੁੱਖ ਜਵਾਬ ਸਟ੍ਰੀਮ ਦਾ ਹਿੱਸਾ ਹੁੰਦੀ ਹੈ
   - MCP: ਪ੍ਰਗਤੀ ਅਲੱਗ ਸੂਚਨਾ ਸੁਨੇਹਿਆਂ ਰਾਹੀਂ ਭੇਜੀ ਜਾਂਦੀ ਹੈ ਜਦਕਿ ਮੁੱਖ ਜਵਾਬ ਅੰਤ ਵਿੱਚ ਆਉਂਦਾ ਹੈ

### ਸਿਫਾਰਸ਼ਾਂ

ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ (ਜਿਵੇਂ `/stream` ਐਂਡਪੌਇੰਟ ਨਾਲ) ਅਤੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਵਿਚੋਂ ਚੁਣਦੇ ਸਮੇਂ ਕੁਝ ਸਿਫਾਰਸ਼ਾਂ ਹਨ:

- **ਸਧਾਰਣ ਸਟ੍ਰੀਮਿੰਗ ਲੋੜਾਂ ਲਈ:** ਕਲਾਸਿਕ HTTP ਸਟ੍ਰੀਮਿੰਗ ਲਾਗੂ ਕਰਨ ਵਿੱਚ ਸੌਖਾ ਅਤੇ ਬੁਨਿਆਦੀ ਲੋੜਾਂ ਲਈ ਕਾਫ਼ੀ ਹੈ।

- **ਜਟਿਲ, ਇੰਟਰਐਕਟਿਵ ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** MCP ਸਟ੍ਰੀਮਿੰਗ ਵਧੀਆ ਸੰਰਚਿਤ ਪਹੁੰਚ ਪ੍ਰਦਾਨ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਧਨਾਢ ਮੈਟਾਡੇਟਾ ਅਤੇ ਸੂਚਨਾਵਾਂ ਅਤੇ ਅੰਤਿਮ ਨਤੀਜਿਆਂ ਵਿਚਕਾਰ ਵੰਡ ਹੁੰਦੀ ਹੈ।

- **AI ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ:** MCP ਦੀ ਸੂਚਨਾ ਪ੍ਰਣਾਲੀ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ AI ਕੰਮਾਂ ਲਈ ਖਾਸ ਤੌਰ 'ਤੇ ਲਾਭਦਾਇਕ ਹੈ ਜਿੱਥੇ ਤੁਸੀਂ ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਪ੍ਰਗਤੀ ਬਾਰੇ ਜਾਣੂ ਰੱਖਣਾ ਚਾਹੁੰਦੇ ਹੋ।

## MCP ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ

ਠੀਕ ਹੈ, ਹੁਣ ਤੱਕ ਤੁਸੀਂ ਕਲਾਸਿਕ ਸਟ੍ਰੀਮਿੰਗ ਅਤੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਵਿਚਕਾਰ ਕੁਝ ਸਿਫਾਰਸ਼ਾਂ ਅਤੇ ਤੁਲਨਾਵਾਂ ਵੇਖੀਆਂ ਹਨ। ਆਓ ਵੇਖੀਏ ਕਿ MCP ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਕਿਵੇਂ ਲਾਗੂ ਕੀਤਾ ਜਾ ਸਕਦਾ ਹੈ।

MCP ਫਰੇਮਵਰਕ ਵਿੱਚ ਸਟ੍ਰੀਮਿੰਗ ਕਿਵੇਂ ਕੰਮ ਕਰਦੀ ਹੈ ਇਹ ਸਮਝਣਾ ਜ਼ਰੂਰੀ ਹੈ ਤਾਂ ਜੋ ਤੁਸੀਂ ਜਵਾਬਦੇਹ ਐਪਲੀਕੇਸ਼ਨ ਬਣਾ ਸਕੋ ਜੋ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ ਕਾਰਜਾਂ ਦੌਰਾਨ ਉਪਭੋਗਤਾਵਾਂ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਫੀਡਬੈਕ ਦੇ ਸਕਣ।

MCP ਵਿੱਚ, ਸਟ੍ਰੀਮਿੰਗ ਦਾ ਮਤਲਬ ਮੁੱਖ ਜਵਾਬ ਨੂੰ ਚੰਕਾਂ ਵਿੱਚ ਭੇਜਣਾ ਨਹੀਂ, ਸਗੋਂ ਟੂਲ ਦੇ ਕਾਰਜ ਦੌਰਾਨ ਕਲਾਇੰਟ ਨੂੰ **ਸੂਚਨਾਵਾਂ** ਭੇਜਣਾ ਹੈ। ਇਹ ਸੂਚਨਾਵਾਂ ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ, ਲੌਗ ਜਾਂ ਹੋਰ ਘਟਨਾਵਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ।

### ਇਹ ਕਿਵੇਂ ਕੰਮ ਕਰਦਾ ਹੈ

ਮੁੱਖ ਨਤੀਜਾ ਅਜੇ ਵੀ ਇਕੱਲੇ ਜਵਾਬ ਵਜੋਂ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ। ਪਰ, ਪ੍ਰਕਿਰਿਆ ਦੌਰਾਨ ਸੂਚਨਾਵਾਂ ਵੱਖ-ਵੱਖ ਸੁਨੇਹਿਆਂ ਵਜੋਂ ਭੇਜੀਆਂ ਜਾ ਸਕਦੀਆਂ ਹਨ ਜੋ ਕਲਾਇੰਟ ਨੂੰ ਰੀਅਲ-ਟਾਈਮ ਅੱਪਡੇਟ ਕਰਦੀਆਂ ਹਨ। ਕਲਾਇੰਟ ਨੂੰ ਇਹ ਸੂਚਨਾਵਾਂ ਸੰਭਾਲਣ ਅਤੇ ਦਿਖਾਉਣ ਯੋਗ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।

## ਸੂਚਨਾ ਕੀ ਹੈ?

ਅਸੀਂ "ਸੂਚਨਾ" ਬਾਰੇ ਗੱਲ ਕੀਤੀ, MCP ਦੇ ਸੰਦਰਭ ਵਿੱਚ ਇਸਦਾ ਕੀ ਮਤਲਬ ਹੈ?

ਸੂਚਨਾ ਇੱਕ ਸੁਨੇਹਾ ਹੈ ਜੋ ਸਰਵਰ ਵੱਲੋਂ ਕਲਾਇੰਟ ਨੂੰ ਭੇਜਿਆ ਜਾਂਦਾ ਹੈ ਤਾਂ ਜੋ ਲੰਬੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ ਕਾਰਜ ਦੌਰਾਨ ਪ੍ਰਗਤੀ, ਸਥਿਤੀ ਜਾਂ ਹੋਰ ਘਟਨਾਵਾਂ ਬਾਰੇ ਜਾਣੂ ਕਰਵਾਇਆ ਜਾ ਸਕੇ। ਸੂਚਨਾਵਾਂ ਪਾਰਦਰਸ਼ਤਾ ਅਤੇ ਉਪਭੋਗਤਾ ਅਨੁਭਵ ਨੂੰ ਸੁਧਾਰਦੀਆਂ ਹਨ।

ਉਦਾਹਰਨ ਵਜੋਂ, ਜਦੋਂ ਕਲਾਇੰਟ ਸਰਵਰ ਨਾਲ ਸ਼ੁਰੂਆਤੀ ਹੈਂਡਸ਼ੇਕ ਕਰ ਲੈਂਦਾ ਹੈ, ਤਾਂ ਇੱਕ ਸੂਚਨਾ ਭੇਜਣੀ ਚਾਹੀਦੀ ਹੈ।

ਇੱਕ ਸੂਚਨਾ ਇਸ ਤਰ੍ਹਾਂ JSON ਸੁਨੇਹੇ ਵਜੋਂ ਦਿਖਾਈ ਦਿੰਦੀ ਹੈ:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

ਸੂਚਨਾਵਾਂ MCP ਵਿੱਚ ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) ਨਾਮਕ ਵਿਸ਼ੇ ਨਾਲ ਸੰਬੰਧਿਤ ਹੁੰਦੀਆਂ ਹਨ।

ਲੌਗਿੰਗ ਨੂੰ ਕੰਮ ਕਰਨ ਲਈ, ਸਰਵਰ ਨੂੰ ਇਸਨੂੰ ਫੀਚਰ/ਸਮਰੱਥਾ ਵਜੋਂ ਯੋਗ ਕਰਨਾ ਪੈਂਦਾ ਹੈ:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ਵਰਤੇ ਗਏ SDK ਦੇ ਅਨੁਸਾਰ, ਲੌਗਿੰਗ ਡਿਫਾਲਟ ਰੂਪ ਵਿੱਚ ਯੋਗ ਹੋ ਸਕਦੀ ਹੈ, ਜਾਂ ਤੁਹਾਨੂੰ ਆਪਣੇ ਸਰਵਰ ਸੰਰਚਨਾ ਵਿੱਚ ਇਸਨੂੰ ਖਾਸ ਤੌਰ 'ਤੇ ਯੋਗ ਕਰਨਾ ਪੈ ਸਕਦਾ ਹੈ।

ਸੂਚਨਾਵਾਂ ਦੇ ਵੱਖ-ਵੱਖ ਪ੍ਰਕਾਰ ਹਨ:

| ਪੱਧਰ       | ਵਰਣਨ                         | ਉਦਾਹਰਨ ਵਰਤੋਂ ਦਾ ਕੇਸ           |
|-------------|------------------------------|--------------------------------|
| debug       | ਵਿਸਥਾਰਪੂਰਕ ਡੀਬੱਗਿੰਗ ਜਾਣਕਾਰੀ | ਫੰਕਸ਼ਨ ਐਂਟਰੀ/ਐਗਜ਼ਿਟ ਪੁਆਇੰਟ    |
| info        | ਆਮ ਜਾਣਕਾਰੀ ਸੁਨੇਹੇ            | ਕਾਰਜ ਦੀ ਪ੍ਰਗਤੀ ਅੱਪਡੇਟ          |
| notice      | ਆਮ ਪਰ ਮਹੱਤਵਪੂਰਨ ਘਟਨਾਵਾਂ    | ਸੰਰਚਨਾ ਬਦਲਾਅ                  |
| warning     | ਚੇਤਾਵਨੀ ਸਥਿਤੀਆਂ             | ਡੀਪ੍ਰੀਕੇਟਡ ਫੀਚਰ ਦੀ ਵਰਤੋਂ     |
| error       | ਗਲਤੀ
### ਕਿਉਂ ਅਪਗ੍ਰੇਡ ਕਰਨਾ?

SSE ਤੋਂ Streamable HTTP ਵੱਲ ਅਪਗ੍ਰੇਡ ਕਰਨ ਦੇ ਦੋ ਮੁੱਖ ਕਾਰਨ ਹਨ:

- Streamable HTTP SSE ਨਾਲੋਂ ਵਧੀਆ ਸਕੇਲਬਿਲਟੀ, ਅਨੁਕੂਲਤਾ ਅਤੇ ਧਨਾਢ਼ ਸੂਚਨਾ ਸਹਾਇਤਾ ਦਿੰਦਾ ਹੈ।
- ਇਹ ਨਵੇਂ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ ਸਿਫਾਰਸ਼ੀ ਟਰਾਂਸਪੋਰਟ ਹੈ।

### ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੇ ਕਦਮ

ਆਪਣੇ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਵਿੱਚ SSE ਤੋਂ Streamable HTTP ਵੱਲ ਮਾਈਗ੍ਰੇਟ ਕਰਨ ਲਈ ਇਹ ਤਰੀਕਾ ਹੈ:

- **ਸਰਵਰ ਕੋਡ ਅਪਡੇਟ ਕਰੋ** ਤਾਂ ਜੋ `mcp.run()` ਵਿੱਚ `transport="streamable-http"` ਵਰਤਿਆ ਜਾਵੇ।
- **ਕਲਾਇੰਟ ਕੋਡ ਅਪਡੇਟ ਕਰੋ** ਤਾਂ ਜੋ SSE ਕਲਾਇੰਟ ਦੀ ਥਾਂ `streamablehttp_client` ਵਰਤਿਆ ਜਾਵੇ।
- **ਕਲਾਇੰਟ ਵਿੱਚ ਇੱਕ ਮੈਸੇਜ ਹੈਂਡਲਰ ਲਾਗੂ ਕਰੋ** ਜੋ ਸੂਚਨਾਵਾਂ ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰੇ।
- **ਮੌਜੂਦਾ ਟੂਲਜ਼ ਅਤੇ ਵਰਕਫਲੋਜ਼ ਨਾਲ ਅਨੁਕੂਲਤਾ ਦੀ ਜਾਂਚ ਕਰੋ**।

### ਅਨੁਕੂਲਤਾ ਬਣਾਈ ਰੱਖਣਾ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੌਰਾਨ ਮੌਜੂਦਾ SSE ਕਲਾਇੰਟਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਬਣਾਈ ਰੱਖਣ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਕੁਝ ਤਰੀਕੇ ਇਹ ਹਨ:

- ਤੁਸੀਂ ਦੋਹਾਂ SSE ਅਤੇ Streamable HTTP ਨੂੰ ਵੱਖ-ਵੱਖ ਐਂਡਪੌਇੰਟਾਂ 'ਤੇ ਚਲਾ ਕੇ ਦੋਹਾਂ ਦਾ ਸਮਰਥਨ ਕਰ ਸਕਦੇ ਹੋ।
- ਕਲਾਇੰਟਾਂ ਨੂੰ ਧੀਰੇ-ਧੀਰੇ ਨਵੇਂ ਟਰਾਂਸਪੋਰਟ ਵੱਲ ਮਾਈਗ੍ਰੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

ਮਾਈਗ੍ਰੇਸ਼ਨ ਦੌਰਾਨ ਇਹ ਚੁਣੌਤੀਆਂ ਹੱਲ ਕਰਨੀ ਜਰੂਰੀ ਹਨ:

- ਇਹ ਯਕੀਨੀ ਬਣਾਉਣਾ ਕਿ ਸਾਰੇ ਕਲਾਇੰਟ ਅਪਡੇਟ ਹੋ ਗਏ ਹਨ
- ਸੂਚਨਾ ਡਿਲਿਵਰੀ ਵਿੱਚ ਫਰਕਾਂ ਨੂੰ ਸੰਭਾਲਣਾ

## ਸੁਰੱਖਿਆ ਸੰਬੰਧੀ ਵਿਚਾਰ

ਕਿਸੇ ਵੀ ਸਰਵਰ ਨੂੰ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ, ਖਾਸ ਕਰਕੇ MCP ਵਿੱਚ HTTP-ਆਧਾਰਿਤ ਟਰਾਂਸਪੋਰਟ ਵਰਤਦੇ ਸਮੇਂ, ਸੁਰੱਖਿਆ ਸਭ ਤੋਂ ਵੱਡੀ ਪ੍ਰਾਥਮਿਕਤਾ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।

HTTP-ਆਧਾਰਿਤ ਟਰਾਂਸਪੋਰਟਾਂ ਨਾਲ MCP ਸਰਵਰ ਬਣਾਉਂਦੇ ਸਮੇਂ, ਸੁਰੱਖਿਆ ਇੱਕ ਮਹੱਤਵਪੂਰਨ ਚਿੰਤਾ ਬਣ ਜਾਂਦੀ ਹੈ ਜਿਸ ਲਈ ਕਈ ਤਰ੍ਹਾਂ ਦੇ ਹਮਲਿਆਂ ਅਤੇ ਸੁਰੱਖਿਆ ਮਕੈਨਿਜ਼ਮਾਂ 'ਤੇ ਧਿਆਨ ਦੇਣਾ ਲਾਜ਼ਮੀ ਹੁੰਦਾ ਹੈ।

### ਝਲਕ

HTTP ਰਾਹੀਂ MCP ਸਰਵਰ ਖੋਲ੍ਹਣ ਸਮੇਂ ਸੁਰੱਖਿਆ ਬਹੁਤ ਜਰੂਰੀ ਹੈ। Streamable HTTP ਨਵੇਂ ਹਮਲੇ ਦੇ ਮੌਕੇ ਲਿਆਉਂਦਾ ਹੈ ਅਤੇ ਸਾਵਧਾਨੀ ਨਾਲ ਸੰਰਚਨਾ ਦੀ ਲੋੜ ਹੁੰਦੀ ਹੈ।

ਇੱਥੇ ਕੁਝ ਮੁੱਖ ਸੁਰੱਖਿਆ ਵਿਚਾਰ ਹਨ:

- **Origin Header ਦੀ ਜਾਂਚ**: DNS ਰੀਬਾਈਂਡਿੰਗ ਹਮਲਿਆਂ ਤੋਂ ਬਚਣ ਲਈ ਹਮੇਸ਼ਾ `Origin` ਹੈਡਰ ਦੀ ਜਾਂਚ ਕਰੋ।
- **Localhost ਬਾਈਂਡਿੰਗ**: ਸਥਾਨਕ ਵਿਕਾਸ ਲਈ ਸਰਵਰਾਂ ਨੂੰ `localhost` 'ਤੇ ਬਾਈਂਡ ਕਰੋ ਤਾਂ ਜੋ ਉਹ ਪਬਲਿਕ ਇੰਟਰਨੈੱਟ 'ਤੇ ਨਾ ਖੁਲ੍ਹਣ।
- **ਪ੍ਰਮਾਣਿਕਤਾ**: ਪ੍ਰੋਡਕਸ਼ਨ ਡਿਪਲੋਇਮੈਂਟ ਲਈ ਪ੍ਰਮਾਣਿਕਤਾ (ਜਿਵੇਂ API ਕੀਜ਼, OAuth) ਲਾਗੂ ਕਰੋ।
- **CORS**: ਐਕਸੈਸ ਨੂੰ ਸੀਮਿਤ ਕਰਨ ਲਈ Cross-Origin Resource Sharing (CORS) ਨੀਤੀਆਂ ਸੈੱਟ ਕਰੋ।
- **HTTPS**: ਟ੍ਰੈਫਿਕ ਨੂੰ ਇਨਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਪ੍ਰੋਡਕਸ਼ਨ ਵਿੱਚ HTTPS ਵਰਤੋ।

### ਵਧੀਆ ਅਭਿਆਸ

ਆਪਣੇ MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ ਇਹ ਵਧੀਆ ਅਭਿਆਸ ਮੰਨੋ:

- ਬਿਨਾਂ ਜਾਂਚ ਦੇ ਆਉਣ ਵਾਲੀਆਂ ਬੇਨਤੀਆਂ 'ਤੇ ਕਦੇ ਭਰੋਸਾ ਨਾ ਕਰੋ।
- ਸਾਰੇ ਐਕਸੈਸ ਅਤੇ ਗਲਤੀਆਂ ਨੂੰ ਲੌਗ ਅਤੇ ਮਾਨੀਟਰ ਕਰੋ।
- ਸੁਰੱਖਿਆ ਖਾਮੀਆਂ ਨੂੰ ਠੀਕ ਕਰਨ ਲਈ ਨਿਯਮਤ ਤੌਰ 'ਤੇ ਡਿਪੈਂਡੈਂਸੀਜ਼ ਅਪਡੇਟ ਕਰੋ।

### ਚੁਣੌਤੀਆਂ

MCP ਸਟ੍ਰੀਮਿੰਗ ਸਰਵਰਾਂ ਵਿੱਚ ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਦੇ ਸਮੇਂ ਤੁਹਾਨੂੰ ਕੁਝ ਚੁਣੌਤੀਆਂ ਦਾ ਸਾਹਮਣਾ ਕਰਨਾ ਪਵੇਗਾ:

- ਵਿਕਾਸ ਦੀ ਸੌਖਿਆ ਅਤੇ ਸੁਰੱਖਿਆ ਵਿੱਚ ਸੰਤੁਲਨ ਬਣਾਈ ਰੱਖਣਾ
- ਵੱਖ-ਵੱਖ ਕਲਾਇੰਟ ਵਾਤਾਵਰਣਾਂ ਨਾਲ ਅਨੁਕੂਲਤਾ ਯਕੀਨੀ ਬਣਾਉਣਾ

### ਅਸਾਈਨਮੈਂਟ: ਆਪਣਾ ਸਟ੍ਰੀਮਿੰਗ MCP ਐਪ ਬਣਾਓ

**ਸਥਿਤੀ:**
ਇੱਕ MCP ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਬਣਾਓ ਜਿੱਥੇ ਸਰਵਰ ਆਈਟਮਾਂ ਦੀ ਸੂਚੀ (ਜਿਵੇਂ ਫਾਈਲਾਂ ਜਾਂ ਦਸਤਾਵੇਜ਼) ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰਦਾ ਹੈ ਅਤੇ ਹਰ ਪ੍ਰੋਸੈਸ ਕੀਤੇ ਆਈਟਮ ਲਈ ਸੂਚਨਾ ਭੇਜਦਾ ਹੈ। ਕਲਾਇੰਟ ਹਰ ਸੂਚਨਾ ਨੂੰ ਜਿਵੇਂ ਹੀ ਮਿਲੇ, ਦਿਖਾਏ।

**ਕਦਮ:**

1. ਇੱਕ ਸਰਵਰ ਟੂਲ ਲਾਗੂ ਕਰੋ ਜੋ ਸੂਚੀ ਨੂੰ ਪ੍ਰੋਸੈਸ ਕਰੇ ਅਤੇ ਹਰ ਆਈਟਮ ਲਈ ਸੂਚਨਾ ਭੇਜੇ।
2. ਇੱਕ ਕਲਾਇੰਟ ਲਾਗੂ ਕਰੋ ਜਿਸ ਵਿੱਚ ਮੈਸੇਜ ਹੈਂਡਲਰ ਹੋਵੇ ਜੋ ਸੂਚਨਾਵਾਂ ਨੂੰ ਰੀਅਲ ਟਾਈਮ ਵਿੱਚ ਦਿਖਾਏ।
3. ਆਪਣੇ ਲਾਗੂ ਕਰਨ ਦੀ ਜਾਂਚ ਕਰਨ ਲਈ ਸਰਵਰ ਅਤੇ ਕਲਾਇੰਟ ਦੋਹਾਂ ਚਲਾਓ ਅਤੇ ਸੂਚਨਾਵਾਂ ਨੂੰ ਦੇਖੋ।

[Solution](./solution/README.md)

## ਹੋਰ ਪੜ੍ਹਾਈ ਅਤੇ ਅਗਲਾ ਕਦਮ?

MCP ਸਟ੍ਰੀਮਿੰਗ ਨਾਲ ਆਪਣਾ ਸਫਰ ਜਾਰੀ ਰੱਖਣ ਅਤੇ ਆਪਣਾ ਗਿਆਨ ਵਧਾਉਣ ਲਈ, ਇਹ ਹਿੱਸਾ ਵਾਧੂ ਸਰੋਤ ਅਤੇ ਅਗਲੇ ਕਦਮਾਂ ਦੀ ਸਿਫਾਰਸ਼ ਕਰਦਾ ਹੈ ਜੋ ਵਧੇਰੇ ਉੱਨਤ ਐਪਲੀਕੇਸ਼ਨਾਂ ਬਣਾਉਣ ਵਿੱਚ ਮਦਦਗਾਰ ਹਨ।

### ਹੋਰ ਪੜ੍ਹਾਈ

- [Microsoft: HTTP Streaming ਦਾ ਪਰਿਚਯ](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core ਵਿੱਚ CORS](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### ਅਗਲਾ ਕਦਮ?

- ਅਜਿਹੇ MCP ਟੂਲ ਬਣਾਉ ਜੋ ਰੀਅਲ-ਟਾਈਮ ਵਿਸ਼ਲੇਸ਼ਣ, ਚੈਟ ਜਾਂ ਸਹਿਯੋਗੀ ਸੰਪਾਦਨ ਲਈ ਸਟ੍ਰੀਮਿੰਗ ਵਰਤਦੇ ਹੋਣ।
- MCP ਸਟ੍ਰੀਮਿੰਗ ਨੂੰ ਫਰੰਟਐਂਡ ਫਰੇਮਵਰਕਾਂ (React, Vue ਆਦਿ) ਨਾਲ ਜੋੜ ਕੇ ਲਾਈਵ UI ਅੱਪਡੇਟਸ ਲਈ ਖੋਜ ਕਰੋ।
- ਅਗਲਾ: [VSCode ਲਈ AI Toolkit ਦੀ ਵਰਤੋਂ](../07-aitk/README.md)

**ਅਸਵੀਕਾਰੋਪਣ**:  
ਇਹ ਦਸਤਾਵੇਜ਼ AI ਅਨੁਵਾਦ ਸੇਵਾ [Co-op Translator](https://github.com/Azure/co-op-translator) ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅਨੁਵਾਦਿਤ ਕੀਤਾ ਗਿਆ ਹੈ। ਜਦੋਂ ਕਿ ਅਸੀਂ ਸਹੀਅਤ ਲਈ ਕੋਸ਼ਿਸ਼ ਕਰਦੇ ਹਾਂ, ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਰੱਖੋ ਕਿ ਸਵੈਚਾਲਿਤ ਅਨੁਵਾਦਾਂ ਵਿੱਚ ਗਲਤੀਆਂ ਜਾਂ ਅਸਮਰਥਤਾਵਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ। ਮੂਲ ਦਸਤਾਵੇਜ਼ ਆਪਣੀ ਮੂਲ ਭਾਸ਼ਾ ਵਿੱਚ ਪ੍ਰਮਾਣਿਕ ਸਰੋਤ ਮੰਨਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ। ਮਹੱਤਵਪੂਰਨ ਜਾਣਕਾਰੀ ਲਈ, ਪੇਸ਼ੇਵਰ ਮਨੁੱਖੀ ਅਨੁਵਾਦ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਇਸ ਅਨੁਵਾਦ ਦੀ ਵਰਤੋਂ ਤੋਂ ਉਤਪੰਨ ਕਿਸੇ ਵੀ ਗਲਤਫਹਿਮੀ ਜਾਂ ਗਲਤ ਵਿਆਖਿਆ ਲਈ ਅਸੀਂ ਜ਼ਿੰਮੇਵਾਰ ਨਹੀਂ ਹਾਂ।