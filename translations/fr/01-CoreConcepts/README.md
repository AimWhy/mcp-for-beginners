<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "f00defb149ee1ac4a799e44a9783c7fc",
  "translation_date": "2025-06-06T17:53:32+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "fr"
}
-->
# üìñ Concepts cl√©s du MCP : Ma√Ætriser le Model Context Protocol pour l‚Äôint√©gration de l‚ÄôIA

Le Model Context Protocol (MCP) est un cadre standardis√© puissant qui optimise la communication entre les grands mod√®les de langage (LLM) et les outils, applications et sources de donn√©es externes. Ce guide optimis√© pour le SEO vous expliquera les concepts fondamentaux du MCP, en vous assurant de bien comprendre son architecture client-serveur, ses composants essentiels, les m√©canismes de communication et les meilleures pratiques d‚Äôimpl√©mentation.

## Aper√ßu

Cette le√ßon explore l‚Äôarchitecture fondamentale et les composants qui constituent l‚Äô√©cosyst√®me du Model Context Protocol (MCP). Vous d√©couvrirez l‚Äôarchitecture client-serveur, les composants cl√©s et les m√©canismes de communication qui rendent possibles les interactions MCP.

## üë©‚Äçüéì Objectifs d‚Äôapprentissage cl√©s

√Ä la fin de cette le√ßon, vous serez capable de :

- Comprendre l‚Äôarchitecture client-serveur du MCP.
- Identifier les r√¥les et responsabilit√©s des Hosts, Clients et Servers.
- Analyser les fonctionnalit√©s principales qui font du MCP une couche d‚Äôint√©gration flexible.
- Appr√©hender le flux d‚Äôinformation au sein de l‚Äô√©cosyst√®me MCP.
- Obtenir des insights pratiques gr√¢ce √† des exemples de code en .NET, Java, Python et JavaScript.

## üîé Architecture du MCP : un regard approfondi

L‚Äô√©cosyst√®me MCP repose sur un mod√®le client-serveur. Cette structure modulaire permet aux applications d‚ÄôIA d‚Äôinteragir efficacement avec des outils, bases de donn√©es, API et ressources contextuelles. D√©composons cette architecture en ses composants principaux.

### 1. Hosts

Dans le Model Context Protocol (MCP), les Hosts jouent un r√¥le crucial en tant qu‚Äôinterface principale par laquelle les utilisateurs interagissent avec le protocole. Les Hosts sont des applications ou environnements qui initient des connexions avec les serveurs MCP pour acc√©der aux donn√©es, outils et prompts. Parmi les exemples de Hosts figurent les environnements de d√©veloppement int√©gr√©s (IDE) comme Visual Studio Code, des outils IA comme Claude Desktop, ou des agents personnalis√©s con√ßus pour des t√¢ches sp√©cifiques.

**Les Hosts** sont des applications LLM qui initient les connexions. Ils :

- Ex√©cutent ou interagissent avec les mod√®les IA pour g√©n√©rer des r√©ponses.
- Initient les connexions avec les serveurs MCP.
- G√®rent le d√©roulement des conversations et l‚Äôinterface utilisateur.
- Contr√¥lent les permissions et les contraintes de s√©curit√©.
- G√®rent le consentement utilisateur pour le partage des donn√©es et l‚Äôex√©cution d‚Äôoutils.

### 2. Clients

Les Clients sont des composants essentiels qui facilitent l‚Äôinteraction entre les Hosts et les serveurs MCP. Ils agissent comme des interm√©diaires, permettant aux Hosts d‚Äôacc√©der et d‚Äôutiliser les fonctionnalit√©s offertes par les serveurs MCP. Ils jouent un r√¥le cl√© pour assurer une communication fluide et un √©change de donn√©es efficace dans l‚Äôarchitecture MCP.

**Les Clients** sont des connecteurs int√©gr√©s dans l‚Äôapplication Host. Ils :

- Envoient des requ√™tes aux serveurs avec des prompts ou instructions.
- N√©gocient les capacit√©s avec les serveurs.
- G√®rent les demandes d‚Äôex√©cution d‚Äôoutils provenant des mod√®les.
- Traitent et affichent les r√©ponses aux utilisateurs.

### 3. Servers

Les Servers sont responsables du traitement des requ√™tes des clients MCP et de la fourniture des r√©ponses appropri√©es. Ils g√®rent diverses op√©rations telles que la r√©cup√©ration de donn√©es, l‚Äôex√©cution d‚Äôoutils et la g√©n√©ration de prompts. Les serveurs garantissent que la communication entre clients et Hosts est efficace et fiable, en maintenant l‚Äôint√©grit√© du processus d‚Äôinteraction.

**Les Servers** sont des services qui fournissent contexte et fonctionnalit√©s. Ils :

- Enregistrent les fonctionnalit√©s disponibles (ressources, prompts, outils).
- Re√ßoivent et ex√©cutent les appels d‚Äôoutils provenant du client.
- Fournissent des informations contextuelles pour am√©liorer les r√©ponses des mod√®les.
- Renvoient les r√©sultats au client.
- Maintiennent l‚Äô√©tat entre les interactions si n√©cessaire.

Les serveurs peuvent √™tre d√©velopp√©s par n‚Äôimporte qui pour √©tendre les capacit√©s des mod√®les avec des fonctionnalit√©s sp√©cialis√©es.

### 4. Fonctionnalit√©s des Servers

Les serveurs dans le Model Context Protocol (MCP) offrent des blocs fondamentaux qui permettent des interactions riches entre clients, hosts et mod√®les de langage. Ces fonctionnalit√©s visent √† renforcer les capacit√©s du MCP en proposant un contexte structur√©, des outils et des prompts.

Les serveurs MCP peuvent proposer l‚Äôune des fonctionnalit√©s suivantes :

#### üìë Ressources

Les ressources dans le Model Context Protocol (MCP) englobent diff√©rents types de contexte et de donn√©es utilisables par les utilisateurs ou les mod√®les IA. Elles comprennent :

- **Donn√©es contextuelles** : Informations et contexte que les utilisateurs ou mod√®les peuvent exploiter pour la prise de d√©cision et l‚Äôex√©cution des t√¢ches.
- **Bases de connaissances et d√©p√¥ts documentaires** : Collections de donn√©es structur√©es ou non, comme des articles, manuels et publications de recherche, fournissant des informations pr√©cieuses.
- **Fichiers locaux et bases de donn√©es** : Donn√©es stock√©es localement sur des appareils ou dans des bases de donn√©es, accessibles pour traitement et analyse.
- **APIs et services web** : Interfaces externes offrant des donn√©es et fonctionnalit√©s suppl√©mentaires, permettant l‚Äôint√©gration avec diverses ressources et outils en ligne.

Un exemple de ressource peut √™tre un sch√©ma de base de donn√©es ou un fichier accessible comme suit :

```text
file://log.txt
database://schema
```

### ü§ñ Prompts

Les prompts dans le Model Context Protocol (MCP) incluent divers mod√®les pr√©-d√©finis et sch√©mas d‚Äôinteraction con√ßus pour simplifier les flux de travail utilisateurs et am√©liorer la communication. Ils comprennent :

- **Messages et workflows templatis√©s** : Messages et processus pr√©-structur√©s guidant les utilisateurs dans des t√¢ches et interactions sp√©cifiques.
- **Sch√©mas d‚Äôinteraction pr√©-d√©finis** : S√©quences standardis√©es d‚Äôactions et de r√©ponses facilitant une communication coh√©rente et efficace.
- **Mod√®les de conversation sp√©cialis√©s** : Templates personnalisables adapt√©s √† des types de conversations sp√©cifiques, garantissant des interactions pertinentes et contextuelles.

Un mod√®le de prompt peut ressembler √† ceci :

```markdown
Generate a product slogan based on the following {{product}} with the following {{keywords}}
```

#### ‚õèÔ∏è Outils

Les outils dans le Model Context Protocol (MCP) sont des fonctions que le mod√®le IA peut ex√©cuter pour accomplir des t√¢ches sp√©cifiques. Ces outils sont con√ßus pour renforcer les capacit√©s du mod√®le IA en fournissant des op√©rations structur√©es et fiables. Les points cl√©s sont :

- **Fonctions ex√©cutables par le mod√®le IA** : Les outils sont des fonctions que le mod√®le peut invoquer pour r√©aliser diff√©rentes t√¢ches.
- **Nom unique et description** : Chaque outil poss√®de un nom distinct et une description d√©taill√©e expliquant son but et ses fonctionnalit√©s.
- **Param√®tres et r√©sultats** : Les outils acceptent des param√®tres sp√©cifiques et retournent des r√©sultats structur√©s, assurant des sorties coh√©rentes et pr√©visibles.
- **Fonctions distinctes** : Les outils effectuent des fonctions bien d√©finies telles que recherches web, calculs, ou requ√™tes en base de donn√©es.

Un exemple d‚Äôoutil pourrait ressembler √† ceci :

```typescript
server.tool(
  "GetProducts",
  {
    pageSize: z.string().optional(),
    pageCount: z.string().optional()
  }, () => {
    // return results from API
  }
)
```

## Fonctionnalit√©s des Clients

Dans le Model Context Protocol (MCP), les clients offrent plusieurs fonctionnalit√©s cl√©s aux serveurs, am√©liorant la fonctionnalit√© globale et l‚Äôinteraction au sein du protocole. L‚Äôune des fonctionnalit√©s notables est le Sampling.

### üëâ Sampling

- **Comportements agentiques initi√©s par le serveur** : Les clients permettent aux serveurs d‚Äôinitier des actions ou comportements sp√©cifiques de mani√®re autonome, augmentant les capacit√©s dynamiques du syst√®me.
- **Interactions r√©cursives avec les LLM** : Cette fonctionnalit√© autorise des interactions r√©cursives avec les grands mod√®les de langage, permettant un traitement plus complexe et it√©ratif des t√¢ches.
- **Demande de compl√©tions suppl√©mentaires du mod√®le** : Les serveurs peuvent solliciter des compl√©tions additionnelles du mod√®le, garantissant des r√©ponses compl√®tes et contextuellement pertinentes.

## Flux d‚Äôinformation dans le MCP

Le Model Context Protocol (MCP) d√©finit un flux structur√© d‚Äôinformation entre hosts, clients, serveurs et mod√®les. Comprendre ce flux aide √† clarifier comment les requ√™tes utilisateurs sont trait√©es et comment les outils et donn√©es externes sont int√©gr√©s dans les r√©ponses des mod√®les.

- **Le Host initie la connexion**  
  L‚Äôapplication host (comme un IDE ou une interface de chat) √©tablit une connexion √† un serveur MCP, g√©n√©ralement via STDIO, WebSocket ou un autre transport support√©.

- **N√©gociation des capacit√©s**  
  Le client (int√©gr√© dans le host) et le serveur √©changent des informations sur leurs fonctionnalit√©s, outils, ressources et versions de protocole support√©s. Cela garantit que les deux parties comprennent les capacit√©s disponibles pour la session.

- **Requ√™te utilisateur**  
  L‚Äôutilisateur interagit avec le host (par exemple, saisit un prompt ou une commande). Le host collecte cette entr√©e et la transmet au client pour traitement.

- **Utilisation de ressources ou d‚Äôoutils**  
  - Le client peut demander au serveur des ressources ou contexte suppl√©mentaires (fichiers, entr√©es en base, articles de base de connaissances) pour enrichir la compr√©hension du mod√®le.
  - Si le mod√®le d√©termine qu‚Äôun outil est n√©cessaire (par exemple pour r√©cup√©rer des donn√©es, effectuer un calcul, ou appeler une API), le client envoie une requ√™te d‚Äôinvocation d‚Äôoutil au serveur, en pr√©cisant le nom de l‚Äôoutil et ses param√®tres.

- **Ex√©cution c√¥t√© serveur**  
  Le serveur re√ßoit la requ√™te de ressource ou d‚Äôoutil, ex√©cute les op√©rations n√©cessaires (ex√©cution de fonction, requ√™te en base, r√©cup√©ration de fichier), puis renvoie les r√©sultats au client sous une forme structur√©e.

- **G√©n√©ration de la r√©ponse**  
  Le client int√®gre les r√©ponses du serveur (donn√©es, r√©sultats d‚Äôoutils, etc.) dans l‚Äôinteraction en cours avec le mod√®le. Le mod√®le utilise ces informations pour produire une r√©ponse compl√®te et contextuellement pertinente.

- **Pr√©sentation du r√©sultat**  
  Le host re√ßoit la sortie finale du client et la pr√©sente √† l‚Äôutilisateur, incluant souvent le texte g√©n√©r√© par le mod√®le ainsi que les r√©sultats des ex√©cutions d‚Äôoutils ou recherches de ressources.

Ce flux permet au MCP de supporter des applications IA avanc√©es, interactives et conscientes du contexte en connectant harmonieusement les mod√®les avec des outils et donn√©es externes.

## D√©tails du protocole

Le MCP (Model Context Protocol) est construit sur [JSON-RPC 2.0](https://www.jsonrpc.org/), offrant un format de message standardis√© et ind√©pendant du langage pour la communication entre hosts, clients et serveurs. Cette base garantit des interactions fiables, structur√©es et extensibles sur diverses plateformes et langages de programmation.

### Fonctionnalit√©s cl√©s du protocole

Le MCP √©tend JSON-RPC 2.0 avec des conventions suppl√©mentaires pour l‚Äôinvocation d‚Äôoutils, l‚Äôacc√®s aux ressources et la gestion des prompts. Il supporte plusieurs couches de transport (STDIO, WebSocket, SSE) et permet une communication s√©curis√©e, extensible et ind√©pendante du langage entre composants.

#### üß¢ Protocole de base

- **Format des messages JSON-RPC** : Toutes les requ√™tes et r√©ponses utilisent la sp√©cification JSON-RPC 2.0, garantissant une structure coh√©rente pour les appels de m√©thode, param√®tres, r√©sultats et gestion des erreurs.
- **Connexions avec √©tat** : Les sessions MCP conservent l‚Äô√©tat sur plusieurs requ√™tes, supportant des conversations continues, l‚Äôaccumulation de contexte et la gestion des ressources.
- **N√©gociation des capacit√©s** : Lors de l‚Äô√©tablissement de la connexion, clients et serveurs √©changent des informations sur les fonctionnalit√©s support√©es, versions du protocole, outils et ressources disponibles. Cela assure une compr√©hension mutuelle des capacit√©s et une adaptation en cons√©quence.

#### ‚ûï Utilitaires suppl√©mentaires

Voici quelques utilitaires et extensions du protocole que MCP fournit pour am√©liorer l‚Äôexp√©rience d√©veloppeur et permettre des sc√©narios avanc√©s :

- **Options de configuration** : MCP permet la configuration dynamique des param√®tres de session, tels que les permissions d‚Äôoutils, l‚Äôacc√®s aux ressources et les r√©glages du mod√®le, adapt√©s √† chaque interaction.
- **Suivi de progression** : Les op√©rations longues peuvent rapporter des mises √† jour de progression, permettant des interfaces utilisateur r√©actives et une meilleure exp√©rience durant les t√¢ches complexes.
- **Annulation de requ√™tes** : Les clients peuvent annuler des requ√™tes en cours, offrant la possibilit√© d‚Äôinterrompre des op√©rations inutiles ou trop longues.
- **Rapport d‚Äôerreurs** : Des messages et codes d‚Äôerreur standardis√©s aident √† diagnostiquer les probl√®mes, g√©rer les √©checs de mani√®re √©l√©gante et fournir des retours exploitables aux utilisateurs et d√©veloppeurs.
- **Journalisation** : Clients et serveurs peuvent √©mettre des logs structur√©s pour l‚Äôaudit, le d√©bogage et la surveillance des interactions du protocole.

Gr√¢ce √† ces fonctionnalit√©s, MCP assure une communication robuste, s√©curis√©e et flexible entre mod√®les de langage et outils ou sources de donn√©es externes.

### üîê Consid√©rations de s√©curit√©

Les impl√©mentations MCP doivent respecter plusieurs principes cl√©s de s√©curit√© pour garantir des interactions s√ªres et dignes de confiance :

- **Consentement et contr√¥le utilisateur** : Les utilisateurs doivent donner leur consentement explicite avant tout acc√®s aux donn√©es ou ex√©cution d‚Äôop√©rations. Ils doivent avoir un contr√¥le clair sur les donn√©es partag√©es et les actions autoris√©es, soutenu par des interfaces utilisateur intuitives pour r√©viser et approuver les activit√©s.

- **Confidentialit√© des donn√©es** : Les donn√©es utilisateur ne doivent √™tre expos√©es qu‚Äôavec consentement explicite et doivent √™tre prot√©g√©es par des contr√¥les d‚Äôacc√®s appropri√©s. Les impl√©mentations MCP doivent pr√©venir toute transmission non autoris√©e et assurer la confidentialit√© tout au long des interactions.

- **S√©curit√© des outils** : Avant d‚Äôinvoquer un outil, un consentement explicite est requis. Les utilisateurs doivent bien comprendre la fonctionnalit√© de chaque outil, et des limites de s√©curit√© strictes doivent √™tre appliqu√©es pour √©viter des ex√©cutions non d√©sir√©es ou dangereuses.

En suivant ces principes, MCP garantit la confiance, la confidentialit√© et la s√©curit√© des utilisateurs √† chaque √©tape des interactions du protocole.

## Exemples de code : composants cl√©s

Voici des exemples de code dans plusieurs langages populaires illustrant comment impl√©menter des composants cl√©s de serveurs MCP et des outils.

### Exemple .NET : Cr√©er un serveur MCP simple avec des outils

Voici un exemple concret en .NET montrant comment impl√©menter un serveur MCP simple avec des outils personnalis√©s. Cet exemple illustre la d√©finition et l‚Äôenregistrement des outils, la gestion des requ√™tes, et la connexion du serveur via le Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Exemple Java : Composants serveur MCP

Cet exemple montre le m√™me serveur MCP et l‚Äôenregistrement d‚Äôoutils que dans l‚Äôexemple .NET ci-dessus, mais impl√©ment√© en Java.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f¬∞F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Exemple Python : Construire un serveur MCP

Dans cet exemple, nous montrons comment construire un serveur MCP en Python. Deux m√©thodes diff√©rentes pour cr√©er des outils sont √©galement pr√©sent√©es.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### Exemple JavaScript : Cr√©er un serveur MCP

Cet exemple montre la cr√©ation d‚Äôun serveur MCP en JavaScript et comment enregistrer deux outils li√©s √† la m√©t√©o.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}¬∞F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Cet exemple JavaScript illustre comment cr√©er un client MCP qui se connecte √† un serveur, envoie un prompt, et traite la r√©ponse incluant les appels aux outils effectu√©s.

## S√©curit√© et autorisation

MCP int√®gre plusieurs concepts et m√©canismes pour g√©rer la s√©curit√© et l‚Äôautorisation tout au long du protocole :

1. **Contr√¥le des permissions d‚Äôoutils** :  
  Les clients peuvent sp√©cifier quels outils un mod√®le est autoris√© √† utiliser durant une session. Cela garantit que seuls les outils explicitement autoris√©s sont accessibles, r√©duisant le risque d‚Äôop√©rations non intentionnelles ou dangereuses. Les permissions peuvent √™tre configur√©es dynamiquement selon les pr√©f√©rences utilisateur, les politiques organisationnelles ou le contexte de l‚Äôinteraction.

2. **Authentification** :  
  Les serveurs peuvent exiger une authentification avant d‚Äôaccorder l‚Äôacc√®s aux outils, ressources ou op√©rations sensibles. Cela peut inclure des cl√©s API, des tokens OAuth, ou d‚Äôautres sch√©mas d‚Äôauthentification. Une authentification appropri√©e garantit que seuls les clients et utilisateurs de confiance peuvent invoquer les capacit√©s serveur.

3. **Validation** :  
  La validation des param√®tres est appliqu√©e pour toutes les invocations d‚Äôoutils. Chaque outil d√©finit les types, formats et contraintes attendus pour ses param√®tres, et le serveur valide les requ√™tes entrantes en cons√©quence. Cela emp√™che les entr√©es mal form√©es ou malveillantes d‚Äôatteindre les impl√©mentations d‚Äôoutils et aide √† pr√©server l‚Äôint√©grit√© des op√©rations.

4. **Limitation de d√©bit** :  
  Pour pr√©venir les abus et garantir une utilisation √©quitable des ressources serveur, les serveurs MCP peuvent appliquer des limites de fr√©quence pour les appels d‚Äôoutils et l‚Äôacc√®s aux ressources. Ces limites peuvent √™tre appliqu√©es par utilisateur, par session ou globalement, et prot√®gent contre les attaques par d√©ni de service ou la consommation excessive de ressources.

En combinant ces m√©canismes, MCP offre une base s√©curis√©e pour int√©grer les mod√®les de langage avec des outils et sources de donn√©es externes, tout en donnant aux utilisateurs et d√©veloppeurs un contr√¥le pr√©cis sur l‚Äôacc√®s et l‚Äôusage.

## Messages du protocole

La communication MCP utilise des messages JSON structur√©s pour faciliter des interactions claires et fiables entre clients, serveurs et mod√®les. Les principaux types de messages sont :

- **Requ√™te client**  
  Envoy√©e du client au serveur, ce message inclut g√©n√©ralement :
  - Le prompt ou la commande de l‚Äôutilisateur
  - L‚Äôhistorique de conversation pour le contexte
  - La configuration et permissions des outils
  - Toute m√©tadonn√©e ou information de session suppl√©mentaire

- **R√©ponse du mod√®le**  
  Renvoy√©e par le mod√®le (via le client), ce message contient :
  - Le texte g√©n√©r√© ou la compl√©tion bas√©e sur le prompt et le contexte
  - Des instructions optionnelles d‚Äôappel d‚Äôoutil si le mod√®le juge n√©cessaire une invocation
  - Des r√©f√©rences √† des ressources ou contexte additionnel selon les besoins

- **Requ√™te d‚Äôoutil**  
  Envoy√©e du client au serveur lorsqu‚Äôun outil doit √™tre ex√©cut√©. Ce message inclut :
  - Le nom de l‚Äôoutil √† invoquer
  - Les param√®tres requis par l‚Äôoutil (valid√©s selon le sch√©ma de l‚Äôoutil)
  - Des informations contextuelles ou identifiants pour le suivi de la requ√™te

- **R√©ponse d‚Äôoutil**  
  Renvoy√©e par le serveur apr√®s ex√©cution d‚Äôun outil. Ce message fournit :
  - Les r√©sultats de l‚Äôex√©cution (donn√©es structur√©es ou contenu)
  - Les erreurs ou informations de statut si l‚Äôappel a √©chou√©
  - √âventuellement, des m√©tadonn√©es ou logs li√©s √† l‚Äôex√©cution

Ces messages structur√©s garantissent que chaque √©tape du flux MCP est explicite, tra√ßable et extensible, supportant des sc√©narios avanc√©s comme

**Avertissement** :  
Ce document a √©t√© traduit √† l'aide du service de traduction automatique [Co-op Translator](https://github.com/Azure/co-op-translator). Bien que nous nous effor√ßons d'assurer l'exactitude, veuillez noter que les traductions automatiques peuvent contenir des erreurs ou des inexactitudes. Le document original dans sa langue d'origine doit √™tre consid√©r√© comme la source faisant foi. Pour les informations critiques, une traduction professionnelle r√©alis√©e par un humain est recommand√©e. Nous d√©clinons toute responsabilit√© en cas de malentendus ou de mauvaises interpr√©tations r√©sultant de l'utilisation de cette traduction.