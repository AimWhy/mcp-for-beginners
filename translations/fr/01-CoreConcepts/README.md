<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "056918462dca9b8f75901709fb8f470c",
  "translation_date": "2025-05-16T15:44:35+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "fr"
}
-->
# üìñ Concepts de base MCP : Ma√Ætriser le Model Context Protocol pour l‚Äôint√©gration de l‚ÄôIA

Le Model Context Protocol (MCP) est un cadre standardis√© puissant qui optimise la communication entre les grands mod√®les de langage (LLM) et les outils, applications et sources de donn√©es externes. Ce guide optimis√© pour le r√©f√©rencement vous pr√©sente les concepts cl√©s du MCP, afin que vous compreniez son architecture client-serveur, ses composants essentiels, les m√©canismes de communication et les meilleures pratiques d‚Äôimpl√©mentation.

## Vue d‚Äôensemble

Cette le√ßon explore l‚Äôarchitecture fondamentale et les composants qui constituent l‚Äô√©cosyst√®me du Model Context Protocol (MCP). Vous d√©couvrirez l‚Äôarchitecture client-serveur, les composants cl√©s et les m√©canismes de communication qui animent les interactions MCP.

## üë©‚Äçüéì Objectifs d‚Äôapprentissage principaux

√Ä la fin de cette le√ßon, vous serez capable de :

- Comprendre l‚Äôarchitecture client-serveur du MCP.
- Identifier les r√¥les et responsabilit√©s des Hosts, Clients et Servers.
- Analyser les fonctionnalit√©s principales qui font du MCP une couche d‚Äôint√©gration flexible.
- Appr√©hender le flux d‚Äôinformation au sein de l‚Äô√©cosyst√®me MCP.
- Obtenir des exemples pratiques en .NET, Java, Python et JavaScript.

## üîé Architecture MCP : un regard approfondi

L‚Äô√©cosyst√®me MCP repose sur un mod√®le client-serveur. Cette structure modulaire permet aux applications IA d‚Äôinteragir efficacement avec des outils, bases de donn√©es, API et ressources contextuelles. D√©composons cette architecture en ses composants essentiels.

### 1. Hosts

Dans le Model Context Protocol (MCP), les Hosts jouent un r√¥le crucial en tant qu‚Äôinterface principale par laquelle les utilisateurs interagissent avec le protocole. Les Hosts sont des applications ou environnements qui initient les connexions avec les serveurs MCP pour acc√©der aux donn√©es, outils et prompts. Par exemple, des environnements de d√©veloppement int√©gr√©s (IDE) comme Visual Studio Code, des outils IA comme Claude Desktop, ou des agents personnalis√©s con√ßus pour des t√¢ches sp√©cifiques.

**Les Hosts** sont des applications LLM qui initient les connexions. Ils :

- Ex√©cutent ou interagissent avec les mod√®les IA pour g√©n√©rer des r√©ponses.
- Initient les connexions avec les serveurs MCP.
- G√®rent le d√©roulement des conversations et l‚Äôinterface utilisateur.
- Contr√¥lent les permissions et les contraintes de s√©curit√©.
- G√®rent le consentement utilisateur pour le partage de donn√©es et l‚Äôex√©cution d‚Äôoutils.

### 2. Clients

Les Clients sont des composants essentiels qui facilitent l‚Äôinteraction entre les Hosts et les serveurs MCP. Ils agissent comme interm√©diaires, permettant aux Hosts d‚Äôacc√©der et d‚Äôutiliser les fonctionnalit√©s fournies par les serveurs MCP. Ils jouent un r√¥le cl√© pour assurer une communication fluide et un √©change de donn√©es efficace au sein de l‚Äôarchitecture MCP.

**Les Clients** sont des connecteurs int√©gr√©s √† l‚Äôapplication Host. Ils :

- Envoient des requ√™tes aux serveurs avec des prompts/instructions.
- N√©gocient les capacit√©s avec les serveurs.
- G√®rent les requ√™tes d‚Äôex√©cution d‚Äôoutils provenant des mod√®les.
- Traitent et affichent les r√©ponses aux utilisateurs.

### 3. Servers

Les Servers sont responsables du traitement des requ√™tes des clients MCP et de la fourniture des r√©ponses appropri√©es. Ils g√®rent diverses op√©rations telles que la r√©cup√©ration de donn√©es, l‚Äôex√©cution d‚Äôoutils et la g√©n√©ration de prompts. Les serveurs garantissent une communication efficace et fiable entre clients et Hosts, tout en maintenant l‚Äôint√©grit√© du processus d‚Äôinteraction.

**Les Servers** sont des services qui fournissent contexte et capacit√©s. Ils :

- Enregistrent les fonctionnalit√©s disponibles (ressources, prompts, outils).
- Re√ßoivent et ex√©cutent les appels d‚Äôoutils du client.
- Fournissent des informations contextuelles pour am√©liorer les r√©ponses du mod√®le.
- Restituent les r√©sultats au client.
- Maintiennent l‚Äô√©tat des interactions lorsque n√©cessaire.

Les serveurs peuvent √™tre d√©velopp√©s par quiconque pour √©tendre les capacit√©s du mod√®le avec des fonctionnalit√©s sp√©cialis√©es.

### 4. Fonctionnalit√©s des Servers

Les serveurs du Model Context Protocol (MCP) offrent des blocs de construction fondamentaux qui permettent des interactions riches entre clients, hosts et mod√®les de langage. Ces fonctionnalit√©s visent √† enrichir les capacit√©s du MCP en proposant un contexte structur√©, des outils et des prompts.

Les serveurs MCP peuvent proposer les fonctionnalit√©s suivantes :

#### üìë Ressources

Les ressources dans le Model Context Protocol (MCP) englobent diff√©rents types de contexte et de donn√©es utilisables par les utilisateurs ou les mod√®les IA. Elles comprennent :

- **Donn√©es contextuelles** : Informations et contexte que les utilisateurs ou mod√®les IA peuvent exploiter pour la prise de d√©cision et l‚Äôex√©cution de t√¢ches.
- **Bases de connaissances et d√©p√¥ts documentaires** : Collections de donn√©es structur√©es et non structur√©es, telles que articles, manuels et publications scientifiques, offrant des informations pr√©cieuses.
- **Fichiers locaux et bases de donn√©es** : Donn√©es stock√©es localement sur des appareils ou dans des bases de donn√©es, accessibles pour traitement et analyse.
- **APIs et services web** : Interfaces et services externes fournissant des donn√©es et fonctionnalit√©s suppl√©mentaires, permettant l‚Äôint√©gration avec diverses ressources et outils en ligne.

Un exemple de ressource peut √™tre un sch√©ma de base de donn√©es ou un fichier accessible comme suit :

```text
file://log.txt
database://schema
```

### ü§ñ Prompts

Les prompts dans le Model Context Protocol (MCP) incluent divers mod√®les pr√©d√©finis et sch√©mas d‚Äôinteraction con√ßus pour fluidifier les flux de travail des utilisateurs et am√©liorer la communication. Ceux-ci comprennent :

- **Messages et workflows templatis√©s** : Messages et processus pr√©-structur√©s guidant les utilisateurs √† travers des t√¢ches et interactions sp√©cifiques.
- **Sch√©mas d‚Äôinteraction pr√©d√©finis** : S√©quences standardis√©es d‚Äôactions et de r√©ponses facilitant une communication coh√©rente et efficace.
- **Mod√®les de conversation sp√©cialis√©s** : Templates personnalisables adapt√©s √† des types sp√©cifiques de conversations, garantissant des interactions pertinentes et contextuellement appropri√©es.

Un mod√®le de prompt peut ressembler √† ceci :

```markdown
Generate a product slogan based on the following {{product}} with the following {{keywords}}
```

#### ‚õèÔ∏è Outils

Les outils dans le Model Context Protocol (MCP) sont des fonctions que le mod√®le IA peut ex√©cuter pour accomplir des t√¢ches sp√©cifiques. Ces outils sont con√ßus pour renforcer les capacit√©s du mod√®le IA en fournissant des op√©rations structur√©es et fiables. Les points cl√©s sont :

- **Fonctions ex√©cutables par le mod√®le IA** : Les outils sont des fonctions que le mod√®le peut invoquer pour r√©aliser diverses t√¢ches.
- **Nom unique et description** : Chaque outil poss√®de un nom distinct et une description d√©taill√©e expliquant son objectif et sa fonctionnalit√©.
- **Param√®tres et r√©sultats** : Les outils acceptent des param√®tres sp√©cifiques et renvoient des sorties structur√©es, assurant des r√©sultats coh√©rents et pr√©visibles.
- **Fonctions distinctes** : Les outils r√©alisent des fonctions pr√©cises comme des recherches web, des calculs ou des requ√™tes en base de donn√©es.

Un exemple d‚Äôoutil pourrait ressembler √† ceci :

```typescript
server.tool(
  "GetProducts"
  {
    pageSize: z.string().optional(),
    pageCount: z.string().optional()
  }, () => {
    // return results from API
  }
)
```

## Fonctionnalit√©s des Clients

Dans le Model Context Protocol (MCP), les clients offrent plusieurs fonctionnalit√©s cl√©s aux serveurs, am√©liorant la fonctionnalit√© globale et l‚Äôinteraction au sein du protocole. L‚Äôune des fonctionnalit√©s notables est le Sampling.

### üëâ Sampling

- **Comportements agentiques initi√©s par le serveur** : Les clients permettent aux serveurs d‚Äôinitier des actions ou comportements sp√©cifiques de mani√®re autonome, renfor√ßant les capacit√©s dynamiques du syst√®me.
- **Interactions r√©cursives avec les LLM** : Cette fonctionnalit√© autorise des interactions r√©cursives avec les grands mod√®les de langage, permettant un traitement plus complexe et it√©ratif des t√¢ches.
- **Demande de compl√©tions suppl√©mentaires du mod√®le** : Les serveurs peuvent solliciter des compl√©tions additionnelles du mod√®le, garantissant que les r√©ponses soient compl√®tes et contextuellement pertinentes.

## Flux d‚Äôinformation dans MCP

Le Model Context Protocol (MCP) d√©finit un flux structur√© d‚Äôinformations entre hosts, clients, serveurs et mod√®les. Comprendre ce flux clarifie la mani√®re dont les requ√™tes utilisateur sont trait√©es et comment les outils externes et donn√©es sont int√©gr√©s aux r√©ponses du mod√®le.

- **Le Host initie la connexion**  
  L‚Äôapplication host (comme un IDE ou une interface de chat) √©tablit une connexion avec un serveur MCP, g√©n√©ralement via STDIO, WebSocket ou un autre transport support√©.

- **N√©gociation des capacit√©s**  
  Le client (int√©gr√© dans le host) et le serveur √©changent des informations sur leurs fonctionnalit√©s, outils, ressources et versions de protocole support√©s. Cela garantit que les deux parties comprennent les capacit√©s disponibles pour la session.

- **Requ√™te utilisateur**  
  L‚Äôutilisateur interagit avec le host (par exemple, en saisissant un prompt ou une commande). Le host collecte cette entr√©e et la transmet au client pour traitement.

- **Utilisation de ressources ou d‚Äôoutils**  
  - Le client peut demander au serveur un contexte ou des ressources suppl√©mentaires (fichiers, entr√©es de base de donn√©es, articles de base de connaissances) pour enrichir la compr√©hension du mod√®le.  
  - Si le mod√®le d√©termine qu‚Äôun outil est n√©cessaire (par exemple pour r√©cup√©rer des donn√©es, effectuer un calcul ou appeler une API), le client envoie une requ√™te d‚Äôinvocation d‚Äôoutil au serveur, en pr√©cisant le nom de l‚Äôoutil et ses param√®tres.

- **Ex√©cution c√¥t√© serveur**  
  Le serveur re√ßoit la requ√™te de ressource ou d‚Äôoutil, ex√©cute les op√©rations n√©cessaires (comme lancer une fonction, interroger une base de donn√©es ou r√©cup√©rer un fichier), et renvoie les r√©sultats au client dans un format structur√©.

- **G√©n√©ration de la r√©ponse**  
  Le client int√®gre les r√©ponses du serveur (donn√©es ressources, r√©sultats d‚Äôoutils, etc.) dans l‚Äôinteraction en cours avec le mod√®le. Le mod√®le utilise ces informations pour produire une r√©ponse compl√®te et contextuellement pertinente.

- **Pr√©sentation du r√©sultat**  
  Le host re√ßoit la sortie finale du client et la pr√©sente √† l‚Äôutilisateur, souvent en combinant le texte g√©n√©r√© par le mod√®le avec les r√©sultats des ex√©cutions d‚Äôoutils ou des recherches de ressources.

Ce flux permet au MCP de soutenir des applications IA avanc√©es, interactives et conscientes du contexte, en connectant harmonieusement les mod√®les avec des outils et sources de donn√©es externes.

## D√©tails du protocole

MCP (Model Context Protocol) est construit sur [JSON-RPC 2.0](https://www.jsonrpc.org/), offrant un format de message standardis√© et ind√©pendant du langage pour la communication entre hosts, clients et serveurs. Cette base permet des interactions fiables, structur√©es et extensibles sur diverses plateformes et langages de programmation.

### Fonctionnalit√©s cl√©s du protocole

MCP √©tend JSON-RPC 2.0 avec des conventions suppl√©mentaires pour l‚Äôinvocation d‚Äôoutils, l‚Äôacc√®s aux ressources et la gestion des prompts. Il supporte plusieurs couches de transport (STDIO, WebSocket, SSE) et permet une communication s√©curis√©e, extensible et ind√©pendante du langage entre les composants.

#### üß¢ Protocole de base

- **Format des messages JSON-RPC** : Toutes les requ√™tes et r√©ponses utilisent la sp√©cification JSON-RPC 2.0, garantissant une structure coh√©rente pour les appels de m√©thode, param√®tres, r√©sultats et gestion des erreurs.
- **Connexions avec √©tat** : Les sessions MCP maintiennent l‚Äô√©tat √† travers plusieurs requ√™tes, supportant les conversations continues, l‚Äôaccumulation de contexte et la gestion des ressources.
- **N√©gociation des capacit√©s** : Lors de l‚Äô√©tablissement de la connexion, clients et serveurs √©changent des informations sur les fonctionnalit√©s support√©es, versions de protocole, outils et ressources disponibles. Cela garantit que les deux parties comprennent leurs capacit√©s respectives et peuvent s‚Äôadapter en cons√©quence.

#### ‚ûï Utilitaires suppl√©mentaires

Voici quelques utilitaires et extensions du protocole que MCP offre pour am√©liorer l‚Äôexp√©rience d√©veloppeur et permettre des sc√©narios avanc√©s :

- **Options de configuration** : MCP permet la configuration dynamique des param√®tres de session, comme les permissions d‚Äôoutils, l‚Äôacc√®s aux ressources et les r√©glages du mod√®le, adapt√©s √† chaque interaction.
- **Suivi de progression** : Les op√©rations longues peuvent rapporter des mises √† jour de progression, permettant des interfaces utilisateur r√©actives et une meilleure exp√©rience lors de t√¢ches complexes.
- **Annulation de requ√™tes** : Les clients peuvent annuler des requ√™tes en cours, offrant aux utilisateurs la possibilit√© d‚Äôinterrompre des op√©rations devenues inutiles ou trop longues.
- **Rapport d‚Äôerreurs** : Des messages et codes d‚Äôerreur standardis√©s facilitent le diagnostic, la gestion √©l√©gante des √©checs et fournissent un retour exploitable aux utilisateurs et d√©veloppeurs.
- **Journalisation** : Clients et serveurs peuvent √©mettre des logs structur√©s pour l‚Äôaudit, le d√©bogage et la surveillance des interactions du protocole.

En tirant parti de ces fonctionnalit√©s, MCP garantit une communication robuste, s√©curis√©e et flexible entre mod√®les de langage et outils ou sources de donn√©es externes.

### üîê Consid√©rations de s√©curit√©

Les impl√©mentations MCP doivent respecter plusieurs principes cl√©s de s√©curit√© pour garantir des interactions s√ªres et fiables :

- **Consentement et contr√¥le utilisateur** : Les utilisateurs doivent donner un consentement explicite avant tout acc√®s aux donn√©es ou ex√©cution d‚Äôop√©rations. Ils doivent pouvoir contr√¥ler clairement les donn√©es partag√©es et les actions autoris√©es, soutenus par des interfaces intuitives pour examiner et approuver les activit√©s.

- **Confidentialit√© des donn√©es** : Les donn√©es utilisateur ne doivent √™tre expos√©es qu‚Äôavec consentement explicite et prot√©g√©es par des contr√¥les d‚Äôacc√®s appropri√©s. Les impl√©mentations MCP doivent pr√©venir toute transmission non autoris√©e et assurer la confidentialit√© tout au long des interactions.

- **S√©curit√© des outils** : Avant d‚Äôinvoquer un outil, un consentement explicite est n√©cessaire. Les utilisateurs doivent comprendre clairement la fonctionnalit√© de chaque outil, et des fronti√®res de s√©curit√© solides doivent √™tre appliqu√©es pour √©viter toute ex√©cution non intentionnelle ou dangereuse.

En suivant ces principes, MCP garantit que la confiance, la confidentialit√© et la s√©curit√© des utilisateurs sont pr√©serv√©es dans toutes les interactions du protocole.

## Exemples de code : composants cl√©s

Voici des exemples de code dans plusieurs langages populaires illustrant comment impl√©menter des composants cl√©s de serveurs MCP et des outils.

### Exemple .NET : cr√©er un serveur MCP simple avec des outils

Voici un exemple pratique en .NET montrant comment impl√©menter un serveur MCP simple avec des outils personnalis√©s. Cet exemple illustre la d√©finition et l‚Äôenregistrement d‚Äôoutils, la gestion des requ√™tes et la connexion du serveur via le Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Exemple Java : composants serveur MCP

Cet exemple montre le m√™me serveur MCP et l‚Äôenregistrement d‚Äôoutils que l‚Äôexemple .NET ci-dessus, mais impl√©ment√© en Java.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f¬∞F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Exemple Python : construire un serveur MCP

Dans cet exemple, nous montrons comment construire un serveur MCP en Python. Deux m√©thodes diff√©rentes pour cr√©er des outils sont √©galement pr√©sent√©es.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Initialize class for its methods to be registered as tools
weather_tools = WeatherTools()

if __name__ == "__main__":
    # Start the server with stdio transport
    print("Weather MCP Server starting...")
    asyncio.run(serve_stdio(mcp))
```

### Exemple JavaScript : cr√©ation d‚Äôun serveur MCP

Cet exemple illustre la cr√©ation d‚Äôun serveur MCP en JavaScript et l‚Äôenregistrement de deux outils li√©s √† la m√©t√©o.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}¬∞F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Cet exemple JavaScript montre comment cr√©er un client MCP qui se connecte √† un serveur, envoie un prompt et traite la r√©ponse, y compris les appels d‚Äôoutils effectu√©s.

## S√©curit√© et autorisation

MCP int√®gre plusieurs concepts et m√©canismes pour g√©rer la s√©curit√© et l‚Äôautorisation tout au long du protocole :

1. **Contr√¥le des permissions des outils**  
  Les clients peuvent sp√©cifier quels outils un mod√®le est autoris√© √† utiliser durant une session. Cela garantit que seuls les outils explicitement autoris√©s sont accessibles, r√©duisant le risque d‚Äôop√©rations non intentionnelles ou dangereuses. Les permissions peuvent √™tre configur√©es dynamiquement selon les pr√©f√©rences utilisateur, les politiques organisationnelles ou le contexte de l‚Äôinteraction.

2. **Authentification**  
  Les serveurs peuvent exiger une authentification avant d‚Äôaccorder l‚Äôacc√®s aux outils, ressources ou op√©rations sensibles. Cela peut impliquer des cl√©s API, tokens OAuth ou autres sch√©mas d‚Äôauthentification. Une authentification ad√©quate garantit que seuls les clients et utilisateurs de confiance peuvent invoquer les capacit√©s c√¥t√© serveur.

3. **Validation**  
  La validation des param√®tres est appliqu√©e pour toutes les invocations d‚Äôoutils. Chaque outil d√©finit les types, formats et contraintes attendus pour ses param√®tres, et le serveur valide les requ√™tes entrantes en cons√©quence. Cela emp√™che les entr√©es malform√©es ou malveillantes d‚Äôatteindre les impl√©mentations d‚Äôoutils et aide √† pr√©server l‚Äôint√©grit√© des op√©rations.

4. **Limitation du d√©bit**  
  Pour pr√©venir les abus et assurer un usage √©quitable des ressources serveur, les serveurs MCP peuvent appliquer une limitation du d√©bit pour les appels d‚Äôoutils et l‚Äôacc√®s aux ressources. Les limites peuvent √™tre appliqu√©es par utilisateur, par session ou globalement, et contribuent √† prot√©ger contre les attaques par d√©ni de service ou la consommation excessive de ressources.

En combinant ces m√©canismes, MCP offre une base s√©curis√©e pour int√©grer les mod√®les de langage avec des outils et sources de donn√©es externes, tout en donnant aux utilisateurs et d√©veloppeurs un contr√¥le pr√©cis sur l‚Äôacc√®s et l‚Äôutilisation.

## Messages du protocole

La communication MCP utilise des messages JSON structur√©s pour faciliter des interactions claires et fiables entre clients, serveurs et mod√®les. Les principaux types de messages comprennent :

- **Requ√™te client**  
  Envoy√©e du client au serveur, ce message inclut g√©n√©ralement :  
  - Le prompt ou la commande de l‚Äôutilisateur  
  - L‚Äôhistorique de conversation pour le contexte  
  - La configuration et les permissions des outils  
  - Toute m√©tadonn√©e ou information de session suppl√©mentaire

- **R√©ponse du mod√®le**  
  Renvoy√©e par le mod√®le (via le client), ce message contient :  
  - Le texte g√©n√©r√© ou la compl√©tion bas√©e sur le prompt et le contexte  
  - Des instructions d‚Äôappel d‚Äôoutil optionnelles si le mod√®le juge qu‚Äôun outil doit √™tre invoqu√©  
  - Des r√©f√©rences √† des ressources ou contexte additionnel si n√©cessaire

- **Requ√™te d‚Äôoutil**  
  Envoy√©e du client au serveur lorsqu‚Äôun outil doit √™tre ex√©cut√©. Ce message comprend :  
  - Le nom de l‚Äôoutil √† invoquer  
  - Les param√®tres requis par l‚Äôoutil (valid√©s selon le sch√©ma de l‚Äôoutil)  
  - Des informations contextuelles ou identifiants pour suivre la requ√™te

- **R√©ponse d‚Äôoutil**  
  Renvoy√©e par le serveur apr√®s ex√©cution d‚Äôun outil. Ce message fournit :  
  - Les r√©sultats de l‚Äôex√©cution de l‚Äôoutil (donn√©es structur√©es ou contenu)  
  - Les erreurs ou informations de statut si l‚Äôappel d‚Äôoutil a √©chou√©  
  - √âventuellement, des m√©tadonn√©es ou logs suppl√©mentaires li√©s √† l‚Äôex√©cution

Ces messages structur√©s garantissent que chaque √©tape du workflow MCP est explicite, tra√ß

**Avertissement** :  
Ce document a √©t√© traduit √† l‚Äôaide du service de traduction automatique [Co-op Translator](https://github.com/Azure/co-op-translator). Bien que nous nous efforcions d‚Äôassurer l‚Äôexactitude, veuillez noter que les traductions automatiques peuvent contenir des erreurs ou des inexactitudes. Le document original dans sa langue d‚Äôorigine doit √™tre consid√©r√© comme la source faisant foi. Pour les informations critiques, une traduction professionnelle r√©alis√©e par un humain est recommand√©e. Nous d√©clinons toute responsabilit√© en cas de malentendus ou d‚Äôinterpr√©tations erron√©es r√©sultant de l‚Äôutilisation de cette traduction.