<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-13T20:33:45+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "ne"
}
-->
# HTTPS स्ट्रिमिङ मोडेल कन्टेक्स्ट प्रोटोकल (MCP) सँग

यो अध्यायले HTTPS प्रयोग गरी मोडेल कन्टेक्स्ट प्रोटोकल (MCP) मार्फत सुरक्षित, स्केलेबल, र रियल-टाइम स्ट्रिमिङ कसरी कार्यान्वयन गर्ने भन्ने बारे विस्तृत मार्गदर्शन प्रदान गर्दछ। यसले स्ट्रिमिङको प्रेरणा, उपलब्ध ट्रान्सपोर्ट मेकानिज्महरू, MCP मा स्ट्रिमेबल HTTP कसरी कार्यान्वयन गर्ने, सुरक्षा सर्वोत्तम अभ्यासहरू, SSE बाट माइग्रेशन, र आफ्नै स्ट्रिमिङ MCP अनुप्रयोगहरू निर्माण गर्ने व्यावहारिक निर्देशनहरू समेट्छ।

## MCP मा ट्रान्सपोर्ट मेकानिज्महरू र स्ट्रिमिङ

यस खण्डले MCP मा उपलब्ध विभिन्न ट्रान्सपोर्ट मेकानिज्महरू र तिनीहरूको भूमिका अन्वेषण गर्दछ जसले क्लाइन्ट र सर्भरबीच रियल-टाइम सञ्चारका लागि स्ट्रिमिङ क्षमता सक्षम पार्दछ।

### ट्रान्सपोर्ट मेकानिज्म भनेको के हो?

ट्रान्सपोर्ट मेकानिज्मले क्लाइन्ट र सर्भरबीच डाटा कसरी आदानप्रदान हुन्छ भन्ने परिभाषित गर्छ। MCP ले विभिन्न वातावरण र आवश्यकताहरूलाई मेल खाने विभिन्न ट्रान्सपोर्ट प्रकारहरू समर्थन गर्दछ:

- **stdio**: स्ट्यान्डर्ड इनपुट/आउटपुट, स्थानीय र CLI-आधारित उपकरणहरूका लागि उपयुक्त। सरल तर वेब वा क्लाउडका लागि उपयुक्त छैन।
- **SSE (Server-Sent Events)**: सर्भरहरूले HTTP मार्फत क्लाइन्टलाई रियल-टाइम अपडेटहरू पठाउन अनुमति दिन्छ। वेब UI का लागि राम्रो, तर स्केलेबिलिटी र लचिलोपनमा सीमित।
- **Streamable HTTP**: आधुनिक HTTP-आधारित स्ट्रिमिङ ट्रान्सपोर्ट, सूचना र राम्रो स्केलेबिलिटी समर्थन गर्दछ। अधिकांश उत्पादन र क्लाउड परिदृश्यहरूका लागि सिफारिस गरिन्छ।

### तुलना तालिका

यी ट्रान्सपोर्ट मेकानिज्महरू बीचको भिन्नता बुझ्न तलको तुलना तालिका हेर्नुहोस्:

| ट्रान्सपोर्ट       | रियल-टाइम अपडेटहरू | स्ट्रिमिङ | स्केलेबिलिटी | प्रयोग केस               |
|-------------------|--------------------|-----------|--------------|-------------------------|
| stdio             | छैन                | छैन       | कम           | स्थानीय CLI उपकरणहरू    |
| SSE               | छ                 | छ        | मध्यम        | वेब, रियल-टाइम अपडेटहरू|
| Streamable HTTP   | छ                 | छ        | उच्च         | क्लाउड, बहु-क्लाइन्ट   |

> **टिप:** सही ट्रान्सपोर्ट चयनले प्रदर्शन, स्केलेबिलिटी, र प्रयोगकर्ता अनुभवमा प्रभाव पार्छ। **Streamable HTTP** आधुनिक, स्केलेबल, र क्लाउड-तयार अनुप्रयोगहरूको लागि सिफारिस गरिन्छ।

अघिल्लो अध्यायहरूमा देखाइएका stdio र SSE ट्रान्सपोर्टहरूलाई ध्यान दिनुहोस् र यस अध्यायमा समेटिएको Streamable HTTP ट्रान्सपोर्टलाई पनि।

## स्ट्रिमिङ: अवधारणा र प्रेरणा

स्ट्रिमिङको आधारभूत अवधारणा र प्रेरणा बुझ्नु प्रभावकारी रियल-टाइम सञ्चार प्रणालीहरू कार्यान्वयन गर्न आवश्यक छ।

**स्ट्रिमिङ** नेटवर्क प्रोग्रामिङमा एउटा प्रविधि हो जसले डाटा सानो, व्यवस्थापनयोग्य टुक्राहरूमा वा घटनाहरूको श्रृंखलाको रूपमा पठाउन र प्राप्त गर्न अनुमति दिन्छ, सम्पूर्ण प्रतिक्रिया तयार हुन कुर्नुको सट्टा। यो विशेष गरी उपयोगी छ:

- ठूला फाइलहरू वा डाटासेटहरूका लागि।
- रियल-टाइम अपडेटहरू (जस्तै, च्याट, प्रगति बारहरू)।
- लामो समयसम्म चल्ने गणनाहरू जहाँ प्रयोगकर्तालाई सूचित राख्न चाहिन्छ।

यहाँ स्ट्रिमिङको उच्च स्तरमा के जान्न आवश्यक छ:

- डाटा क्रमिक रूपमा प्रदान गरिन्छ, सबै एकैपटक होइन।
- क्लाइन्टले डाटा प्राप्त हुने बित्तिकै प्रक्रिया गर्न सक्छ।
- महसुस गरिएको विलम्बता घटाउँछ र प्रयोगकर्ता अनुभव सुधार्छ।

### किन स्ट्रिमिङ प्रयोग गर्ने?

स्ट्रिमिङ प्रयोग गर्ने कारणहरू यस्ता छन्:

- प्रयोगकर्ताहरूलाई तुरुन्त प्रतिक्रिया प्राप्त हुन्छ, अन्त्यमा मात्र होइन।
- रियल-टाइम अनुप्रयोगहरू र प्रतिक्रियाशील UI सक्षम पार्दछ।
- नेटवर्क र कम्प्युट स्रोतहरूको अधिक कुशल प्रयोग।

### सरल उदाहरण: HTTP स्ट्रिमिङ सर्भर र क्लाइन्ट

यहाँ स्ट्रिमिङ कसरी कार्यान्वयन गर्न सकिन्छ भन्ने सरल उदाहरण छ:

<details>
<summary>Python</summary>

**सर्भर (Python, FastAPI र StreamingResponse प्रयोग गर्दै):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**क्लाइन्ट (Python, requests प्रयोग गर्दै):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

यस उदाहरणले देखाउँछ कि सर्भरले सबै सन्देशहरू तयार हुन कुर्नुको सट्टा उपलब्ध हुनासाथ क्लाइन्टलाई सन्देशहरूको श्रृंखला पठाउँछ।

**कसरी काम गर्छ:**
- सर्भर प्रत्येक सन्देश तयार हुनासाथ पठाउँछ।
- क्लाइन्ट प्रत्येक टुक्रा प्राप्त हुनासाथ प्रिन्ट गर्छ।

**आवश्यकताहरू:**
- सर्भरले स्ट्रिमिङ प्रतिक्रिया प्रयोग गर्नुपर्छ (जस्तै, FastAPI मा `StreamingResponse`)।
- क्लाइन्टले प्रतिक्रिया स्ट्रिमको रूपमा प्रक्रिया गर्नुपर्छ (`requests` मा `stream=True`)।
- Content-Type सामान्यतया `text/event-stream` वा `application/octet-stream` हुन्छ।

</details>

<details>
<summary>Java</summary>

**सर्भर (Java, Spring Boot र Server-Sent Events प्रयोग गर्दै):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लाइन्ट (Java, Spring WebFlux WebClient प्रयोग गर्दै):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java कार्यान्वयन नोटहरू:**
- Spring Boot को रियाक्टिभ स्ट्याक `Flux` सँग स्ट्रिमिङका लागि प्रयोग गरिन्छ
- `ServerSentEvent` ले घटनाहरूको प्रकार सहित संरचित घटना स्ट्रिमिङ प्रदान गर्छ
- `WebClient` को `bodyToFlux()` ले रियाक्टिभ स्ट्रिमिङ उपभोग सक्षम पार्दछ
- `delayElements()` ले घटनाहरू बीच प्रक्रिया समय अनुकरण गर्छ
- घटनाहरूमा प्रकारहरू (`info`, `result`) हुन सक्छन् जसले क्लाइन्टलाई राम्रोसँग ह्यान्डल गर्न मद्दत गर्छ

</details>

### तुलना: क्लासिक स्ट्रिमिङ र MCP स्ट्रिमिङ

क्लासिक तरिकाले स्ट्रिमिङ कसरी काम गर्छ र MCP मा कसरी काम गर्छ भनी भिन्नता यसरी देखाउन सकिन्छ:

| विशेषता               | क्लासिक HTTP स्ट्रिमिङ          | MCP स्ट्रिमिङ (सूचनाहरू)          |
|-----------------------|-------------------------------|----------------------------------|
| मुख्य प्रतिक्रिया      | टुक्रा टुक्रा पठाइन्छ          | एक पटक, अन्त्यमा पठाइन्छ         |
| प्रगति अपडेटहरू      | डाटा टुक्राहरूको रूपमा पठाइन्छ | सूचनाहरूको रूपमा पठाइन्छ          |
| क्लाइन्ट आवश्यकताहरू | स्ट्रिम प्रक्रिया गर्नुपर्छ     | सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ |
| प्रयोग केस            | ठूला फाइलहरू, AI टोकन स्ट्रिमहरू | प्रगति, लगहरू, रियल-टाइम प्रतिक्रिया |

### मुख्य भिन्नताहरू

थप रूपमा, यहाँ केही मुख्य भिन्नताहरू छन्:

- **सञ्चार ढाँचा:**
   - क्लासिक HTTP स्ट्रिमिङ: सरल टुक्रा ट्रान्सफर इन्कोडिङ प्रयोग गरेर डाटा पठाउँछ
   - MCP स्ट्रिमिङ: JSON-RPC प्रोटोकलसहित संरचित सूचना प्रणाली प्रयोग गर्छ

- **सन्देश ढाँचा:**
   - क्लासिक HTTP: नयाँ लाइन सहितको साधारण पाठ टुक्राहरू
   - MCP: मेटाडाटा सहित संरचित LoggingMessageNotification वस्तुहरू

- **क्लाइन्ट कार्यान्वयन:**
   - क्लासिक HTTP: स्ट्रिमिङ प्रतिक्रिया प्रक्रिया गर्ने सरल क्लाइन्ट
   - MCP: विभिन्न प्रकारका सन्देशहरू प्रक्रिया गर्न सन्देश ह्यान्डलर सहित जटिल क्लाइन्ट

- **प्रगति अपडेटहरू:**
   - क्लासिक HTTP: प्रगति मुख्य प्रतिक्रिया स्ट्रिमको भाग हो
   - MCP: प्रगति अलग सूचनाहरू मार्फत पठाइन्छ, मुख्य प्रतिक्रिया अन्त्यमा आउँछ

### सिफारिसहरू

क्लासिक स्ट्रिमिङ (जस्तै `/stream` अन्तबिन्दु प्रयोग गरेर) र MCP मार्फत स्ट्रिमिङ बीच छनोट गर्दा केही सिफारिसहरू छन्:

- **सरल स्ट्रिमिङ आवश्यकताहरूका लागि:** क्लासिक HTTP स्ट्रिमिङ कार्यान्वयन गर्न सजिलो र आधारभूत आवश्यकताहरूका लागि पर्याप्त छ।

- **जटिल, अन्तरक्रियात्मक अनुप्रयोगहरूका लागि:** MCP स्ट्रिमिङले धनी मेटाडाटा र सूचनाहरू र अन्तिम परिणाम बीच छुट्टाछुट्टै संरचना प्रदान गर्दछ।

- **AI अनुप्रयोगहरूका लागि:** MCP को सूचना प्रणाली लामो समयसम्म चल्ने AI कार्यहरूमा प्रगति सूचित गर्न विशेष रूपमा उपयोगी छ।

## MCP मा स्ट्रिमिङ

अबसम्म तपाईंले क्लासिक स्ट्रिमिङ र MCP स्ट्रिमिङ बीचको भिन्नता र सिफारिसहरू देख्नुभयो। अब MCP मा स्ट्रिमिङ कसरी प्रयोग गर्ने भन्ने विस्तृत रूपमा जानौं।

MCP फ्रेमवर्क भित्र स्ट्रिमिङ कसरी काम गर्छ बुझ्नु आवश्यक छ ताकि लामो समयसम्म चल्ने अपरेसनहरूमा प्रयोगकर्तालाई रियल-टाइम प्रतिक्रिया दिने प्रतिक्रियाशील अनुप्रयोगहरू निर्माण गर्न सकियोस्।

MCP मा, स्ट्रिमिङ मुख्य प्रतिक्रिया टुक्रामा पठाउने होइन, तर उपकरणले अनुरोध प्रक्रिया गर्दा क्लाइन्टलाई **सूचनाहरू** पठाउने कुरा हो। यी सूचनाहरूमा प्रगति अपडेटहरू, लगहरू, वा अन्य घटनाहरू समावेश हुन सक्छन्।

### कसरी काम गर्छ

मुख्य परिणाम अझै एकल प्रतिक्रियाको रूपमा पठाइन्छ। तर, प्रक्रिया भइरहेका बेला सूचनाहरू अलग सन्देशको रूपमा पठाउन सकिन्छ जसले क्लाइन्टलाई रियल-टाइममा अपडेट गर्दछ। क्लाइन्टले यी सूचनाहरूलाई ह्यान्डल र प्रदर्शन गर्न सक्षम हुनुपर्छ।

## सूचना भनेको के हो?

हामीले "सूचना" भनेका थियौं, MCP सन्दर्भमा यसको अर्थ के हो?

सूचना भनेको सर्भरबाट क्लाइन्टलाई पठाइने सन्देश हो जसले लामो समयसम्म चल्ने अपरेसनको प्रगति, स्थिति, वा अन्य घटनाहरूको बारेमा जानकारी दिन्छ। सूचनाले पारदर्शिता र प्रयोगकर्ता अनुभव सुधार्छ।

उदाहरणका लागि, क्लाइन्टले सर्भरसँग प्रारम्भिक ह्याण्डशेक भएपछि सूचना पठाउनुपर्छ।

सूचना JSON सन्देशको रूपमा यसरी देखिन्छ:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

सूचनाहरू MCP मा ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) नामक विषयसँग सम्बन्धित छन्।

लगिङ काम गर्न सर्भरले यसलाई सुविधा/क्षमता रूपमा सक्षम पार्नुपर्छ, यसरी:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> प्रयोग गरिएको SDK अनुसार, लगिङ डिफल्ट रूपमा सक्षम हुन सक्छ, वा तपाईंले सर्भर कन्फिगरेसनमा स्पष्ट रूपमा सक्षम पार्नुपर्ने हुन सक्छ।

विभिन्न प्रकारका सूचनाहरू छन्:

| स्तर       | विवरण                         | उदाहरण प्रयोग केस             |
|------------|------------------------------|-------------------------------|
| debug      | विस्तृत डिबगिङ जानकारी       | फङ्सन प्रवेश/निकास बिन्दुहरू  |
| info       | सामान्य सूचना सन्देशहरू       | अपरेसन प्रगति अपडेटहरू       |
| notice     | सामान्य तर महत्वपूर्ण घटनाहरू | कन्फिगरेसन परिवर्तनहरू        |
| warning    | चेतावनी अवस्था               | अप्रचलित सुविधा प्रयोग        |
| error      | त्रुटि अवस्था                | अपरेसन असफलताहरू             |
| critical   | गम्भीर अवस्था               | प्रणाली कम्पोनेन्ट असफलता     |
| alert      | तुरुन्त कारबाही आवश्यक       | डाटा भ्रष्टाचार पत्ता लागेको  |
| emergency  | प्रणाली प्रयोगयोग्य छैन      | पूर्ण प्रणाली असफलता          |

## MCP मा सूचनाहरू कार्यान्वयन गर्ने

MCP मा सूचनाहरू कार्यान्वयन गर्न, तपाईंले सर्भर र क्लाइन्ट दुवै पक्षलाई रियल-टाइम अपडेटहरू ह्यान्डल गर्न सेटअप गर्नुपर्छ। यसले तपाईंको अनुप्रयोगलाई लामो समयसम्म चल्ने अपरेसनहरूमा प्रयोगकर्तालाई तुरुन्त प्रतिक्रिया दिन सक्षम बनाउँछ।

### सर्भर-पक्ष: सूचनाहरू पठाउने

सर्भर पक्षबाट सुरु गरौं। MCP मा, तपाईंले उपकरणहरू परिभाषित गर्नुहुन्छ जसले अनुरोध प्रक्रिया गर्दा सूचनाहरू पठाउन सक्छन्। सर्भरले सन्देशहरू पठाउन सन्दर्भ वस्तु (सामान्यतया `ctx`) प्रयोग गर्छ।

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

अघिल्लो उदाहरणमा, `process_files` उपकरणले प्रत्येक फाइल प्रक्रिया गर्दा क्लाइन्टलाई तीनवटा सूचनाहरू पठाउँछ। `ctx.info()` विधि सूचना सन्देशहरू पठाउन प्रयोग गरिएको छ।

</details>

थप रूपमा, सूचनाहरू सक्षम गर्न, तपाईंको सर्भरले स्ट्रिमिङ ट्रान्सपोर्ट (जस्तै `streamable-http`) प्रयोग गर्नुपर्छ र क्लाइन्टले सूचनाहरू प्रक्रिया गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ। यहाँ कसरी सर्भरलाई `streamable-http` ट्रान्सपोर्ट प्रयोग गर्न सेटअप गर्ने देखाइएको छ:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

यस .NET उदाहरणमा, `ProcessFiles` उपकरण `Tool` एट्रिब्युटले सजाइएको छ र प्रत्येक फाइल प्रक्रिया गर्दा क्लाइन्टलाई तीनवटा सूचनाहरू पठाउँछ। `ctx.Info()` विधि सूचना सन्देशहरू पठाउन प्रयोग गरिएको छ।

तपाईंको .NET MCP सर्भरमा सूचनाहरू सक्षम गर्न, स्ट्रिमिङ ट्रान्सपोर्ट प्रयोग गरिरहेको सुनिश्चित गर्नुहोस्:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### क्लाइन्ट-पक्ष: सूचनाहरू प्राप्त गर्ने

क्लाइन्टले सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ जसले सूचनाहरू प्राप्त गरी प्रदर्शन गर्छ।

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

अघिल्लो कोडमा, `message_handler` फङ्सनले जाँच गर्छ कि आउने सन्देश सूचना हो कि होइन। यदि हो भने, सूचना प्रिन्ट गर्छ; नभए सामान्य सर्भर सन्देशको रूपमा प्रक्रिया गर्छ। साथै, `ClientSession` लाई `message_handler` सँग इनिसियलाइज गरिएको छ ताकि आउने सूचनाहरू ह्यान्डल गर्न सकियोस्।

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

यस .NET उदाहरणमा, `MessageHandler` फङ्सनले जाँच गर्छ कि आउने सन्देश सूचना हो कि होइन। यदि हो भने, सूचना प्रिन्ट गर्छ; नभए सामान्य सर्भर सन्देशको रूपमा प्रक्रिया गर्छ। `ClientSession` लाई `ClientSessionOptions` मार्फत सन्देश ह्यान्डलरसँग इनिसियलाइज गरिएको छ।

</details>

सूचनाहरू सक्षम गर्न, तपाईंको सर्भरले स्ट्रिमिङ ट्रान्सपोर्ट (जस्तै `streamable-http`) प्रयोग गर्नुपर्छ र क्लाइन्टले सूचनाहरू प्रक्रिया गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ।

## प्रगति सूचनाहरू र परिदृश्यहरू

यस खण्डले MCP मा प्रगति सूचनाहरूको अवधारणा, तिनीहरू किन महत्वपूर्ण छन्, र Streamable HTTP प्रयोग गरी कसरी कार्यान्वयन गर्ने भन्ने व्याख्या गर्दछ। तपाईंले आफ्नो बुझाइलाई बलियो बनाउन व्यावहारिक अभ्यास पनि पाउनुहुनेछ।

प्रगति सूचनाहरू लामो समयसम्म चल्ने अपरेसनहरूमा सर्भरबाट क्लाइन्टलाई पठाइने रियल-टाइम सन्देशहरू हुन्। सम्पूर्ण प्रक्रिया समाप्त हुन कुर्नुको सट्टा, सर्भरले क्लाइन्टलाई वर्तमान स्थितिबारे अपडेट राख्छ। यसले पारदर्शिता, प्रयोगकर्ता अनुभव सुधार्छ र डिबगिङ सजिलो बनाउँछ।

**उदाहरण:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### किन प्रगति सूचनाहरू प्रयोग गर्ने?

प्रगति सूचनाहरू आवश्यक छन् किनभने:

- **राम्रो प्रयोगकर्ता अनुभव:** काम प्रगति भइरहेका बेला प्रयोगकर्ताले अपडेटहरू देख्छन्, अन्त्यमा मात्र होइन।
- **रियल-टाइम प्रतिक्रिया:** क्लाइन्टहरूले प्रगति बार वा लगहरू प्रदर्शन गर्न सक्छन्, जसले अनुप्रयोगलाई प्रतिक्रियाशील बनाउँछ।
- **डिबगिङ र अनुगमन सजिलो:** विकासकर्ता र प्रयोगकर्ताले प्रक्रिया कहाँ ढिलो वा अड्किएको छ देख्न सक्छन्।

### प्रगति सूचनाहरू कसरी कार्यान्वयन गर्ने

MCP मा प्रगति सूचनाहरू कार्यान्वयन गर्ने तरिका:

- **सर्भरमा:** प्रत्येक वस्तु प्रक्रिया हुँदा `ctx.info()` वा `ctx.log()` प्रयोग गरी सूचनाहरू पठाउनुहोस्। यसले मुख्य परिणाम तयार हुनुअघि क्लाइन्टलाई सन्देश पठाउँछ।
- **क्लाइन्टमा:** सूचनाहरू प्राप्त गरी प्रदर्शन गर्ने सन्देश ह्यान्डलर कार्यान्वयन गर्नुहोस्। यो ह्यान्डलरले सूचनाहरू र अन्तिम परिणाम छुट्याउँछ।

**सर्भर उदाहरण:**

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**Client Example:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## सुरक्षा सम्बन्धी विचारहरू

HTTP-आधारित ट्रान्सपोर्टहरूसँग MCP सर्भरहरू कार्यान्वयन गर्दा सुरक्षा अत्यन्त महत्वपूर्ण हुन्छ र यसले विभिन्न आक्रमणका तरिकाहरू र सुरक्षा उपायहरूमा ध्यान दिन आवश्यक हुन्छ।

### अवलोकन

HTTP मार्फत MCP सर्भरहरू सार्वजनिक गर्दा सुरक्षा अत्यावश्यक हुन्छ। Streamable HTTP ले नयाँ आक्रमणका सतहहरू ल्याउँछ र सावधानीपूर्वक कन्फिगरेसन आवश्यक पर्छ।

### मुख्य बुँदाहरू
- **Origin Header प्रमाणीकरण**: DNS rebinding आक्रमणबाट बच्न `Origin` हेडर सधैं प्रमाणीकरण गर्नुहोस्।
- **Localhost बाइन्डिङ**: स्थानीय विकासका लागि सर्भरहरूलाई `localhost` मा बाँध्नुहोस् ताकि तिनीहरू सार्वजनिक इन्टरनेटमा नखुलून्।
- **प्रमाणीकरण**: उत्पादनमा API कुञ्जीहरू, OAuth जस्ता प्रमाणीकरण लागू गर्नुहोस्।
- **CORS**: पहुँच सीमित गर्न Cross-Origin Resource Sharing (CORS) नीति कन्फिगर गर्नुहोस्।
- **HTTPS**: उत्पादनमा ट्राफिक इन्क्रिप्ट गर्न HTTPS प्रयोग गर्नुहोस्।

### उत्तम अभ्यासहरू
- प्रमाणीकरण बिना आउने अनुरोधहरूमा कहिल्यै विश्वास नगर्नुहोस्।
- सबै पहुँच र त्रुटिहरू लग र अनुगमन गर्नुहोस्।
- सुरक्षा कमजोरीहरू मेटाउन नियमित रूपमा निर्भरता अपडेट गर्नुहोस्।

### चुनौतीहरू
- विकास सजिलो बनाउने र सुरक्षा सन्तुलन मिलाउने
- विभिन्न क्लाइन्ट वातावरणहरूसँग अनुकूलता सुनिश्चित गर्ने


## SSE बाट Streamable HTTP मा अपग्रेड गर्ने

हाल Server-Sent Events (SSE) प्रयोग गरिरहेका अनुप्रयोगहरूका लागि Streamable HTTP मा सर्नुले थप क्षमता र दीर्घकालीन टिकाउ MCP कार्यान्वयनका लागि राम्रो विकल्प दिन्छ।

### किन अपग्रेड गर्ने?

SSE बाट Streamable HTTP मा अपग्रेड गर्न दुई मुख्य कारणहरू छन्:

- Streamable HTTP ले SSE भन्दा राम्रो स्केलेबिलिटी, अनुकूलता र समृद्ध सूचना समर्थन दिन्छ।
- नयाँ MCP अनुप्रयोगहरूको लागि यो सिफारिस गरिएको ट्रान्सपोर्ट हो।

### माइग्रेशनका चरणहरू

यहाँ तपाईँले आफ्नो MCP अनुप्रयोगहरूमा SSE बाट Streamable HTTP मा कसरी सर्न सक्नुहुन्छ:

- सर्भर कोडमा `mcp.run()` मा `transport="streamable-http"` प्रयोग गर्न अपडेट गर्नुहोस्।
- क्लाइन्ट कोडमा SSE क्लाइन्टको सट्टा `streamablehttp_client` प्रयोग गर्नुहोस्।
- क्लाइन्टमा सूचना प्रशोधन गर्न मेसेज ह्यान्डलर लागू गर्नुहोस्।
- विद्यमान उपकरण र कार्यप्रवाहहरूसँग अनुकूलता परीक्षण गर्नुहोस्।

### अनुकूलता कायम राख्ने

माइग्रेशनको क्रममा विद्यमान SSE क्लाइन्टहरूसँग अनुकूलता कायम राख्न सिफारिस गरिन्छ। केही रणनीतिहरू:

- SSE र Streamable HTTP दुवैलाई फरक-फरक एन्डपोइन्टहरूमा चलाएर समर्थन गर्न सकिन्छ।
- क्लाइन्टहरूलाई क्रमशः नयाँ ट्रान्सपोर्टमा सार्नुहोस्।

### चुनौतीहरू

माइग्रेशन गर्दा यी चुनौतीहरू समाधान गर्नुहोस्:

- सबै क्लाइन्टहरू अपडेट गरिएको सुनिश्चित गर्नु
- सूचना वितरणमा भिन्नता व्यवस्थापन गर्नु

## सुरक्षा सम्बन्धी विचारहरू

HTTP-आधारित ट्रान्सपोर्टहरू जस्तै Streamable HTTP प्रयोग गर्दा MCP सर्भरहरू कार्यान्वयन गर्दा सुरक्षा सबैभन्दा महत्वपूर्ण हुनुपर्छ।

HTTP मार्फत MCP सर्भरहरू सार्वजनिक गर्दा सुरक्षा अत्यावश्यक हुन्छ। Streamable HTTP ले नयाँ आक्रमणका सतहहरू ल्याउँछ र सावधानीपूर्वक कन्फिगरेसन आवश्यक पर्छ।

यहाँ केही मुख्य सुरक्षा विचारहरू छन्:

- **Origin Header प्रमाणीकरण**: DNS rebinding आक्रमणबाट बच्न `Origin` हेडर सधैं प्रमाणीकरण गर्नुहोस्।
- **Localhost बाइन्डिङ**: स्थानीय विकासका लागि सर्भरहरूलाई `localhost` मा बाँध्नुहोस् ताकि तिनीहरू सार्वजनिक इन्टरनेटमा नखुलून्।
- **प्रमाणीकरण**: उत्पादनमा API कुञ्जीहरू, OAuth जस्ता प्रमाणीकरण लागू गर्नुहोस्।
- **CORS**: पहुँच सीमित गर्न Cross-Origin Resource Sharing (CORS) नीति कन्फिगर गर्नुहोस्।
- **HTTPS**: उत्पादनमा ट्राफिक इन्क्रिप्ट गर्न HTTPS प्रयोग गर्नुहोस्।

### उत्तम अभ्यासहरू

MCP स्ट्रिमिङ सर्भरमा सुरक्षा लागू गर्दा यी उत्तम अभ्यासहरू पालना गर्नुहोस्:

- प्रमाणीकरण बिना आउने अनुरोधहरूमा कहिल्यै विश्वास नगर्नुहोस्।
- सबै पहुँच र त्रुटिहरू लग र अनुगमन गर्नुहोस्।
- सुरक्षा कमजोरीहरू मेटाउन नियमित रूपमा निर्भरता अपडेट गर्नुहोस्।

### चुनौतीहरू

MCP स्ट्रिमिङ सर्भरमा सुरक्षा लागू गर्दा केही चुनौतीहरू आउँछन्:

- विकास सजिलो बनाउने र सुरक्षा सन्तुलन मिलाउने
- विभिन्न क्लाइन्ट वातावरणहरूसँग अनुकूलता सुनिश्चित गर्ने

### कार्य: आफ्नो स्ट्रिमिङ MCP एप बनाउनुहोस्

**परिदृश्य:**
एक MCP सर्भर र क्लाइन्ट बनाउनुहोस् जहाँ सर्भरले वस्तुहरूको सूची (जस्तै फाइलहरू वा कागजातहरू) प्रक्रिया गर्छ र प्रत्येक वस्तु प्रक्रिया भएपछि सूचना पठाउँछ। क्लाइन्टले प्रत्येक सूचना प्राप्त हुने बित्तिकै देखाउनु पर्छ।

**चरणहरू:**

1. सूची प्रक्रिया गर्ने र प्रत्येक वस्तुका लागि सूचना पठाउने सर्भर उपकरण कार्यान्वयन गर्नुहोस्।
2. सूचना वास्तविक समयमा देखाउन मेसेज ह्यान्डलर सहित क्लाइन्ट कार्यान्वयन गर्नुहोस्।
3. सर्भर र क्लाइन्ट दुवै चलाएर आफ्नो कार्यान्वयन परीक्षण गर्नुहोस् र सूचनाहरू अवलोकन गर्नुहोस्।

[Solution](./solution/README.md)

## थप पढाइ र के गर्ने?

MCP स्ट्रिमिङसँग आफ्नो यात्रा जारी राख्न र थप ज्ञान विस्तार गर्न, यो खण्डले थप स्रोतहरू र उन्नत अनुप्रयोगहरू निर्माणका लागि सुझावहरू प्रदान गर्दछ।

### थप पढाइ

- [Microsoft: HTTP Streaming परिचय](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core मा CORS](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### के गर्ने?

- वास्तविक-समय विश्लेषण, च्याट, वा सहकार्य सम्पादनका लागि स्ट्रिमिङ प्रयोग गर्ने थप उन्नत MCP उपकरणहरू बनाउने प्रयास गर्नुहोस्।
- MCP स्ट्रिमिङलाई फ्रन्टएन्ड फ्रेमवर्कहरू (React, Vue, आदि) सँग एकीकृत गरेर प्रत्यक्ष UI अपडेटहरू अन्वेषण गर्नुहोस्।
- अर्को: [VSCode का लागि AI Toolkit को उपयोग](../07-aitk/README.md)

**अस्वीकरण**:  
यो दस्तावेज AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) प्रयोग गरी अनुवाद गरिएको हो। हामी शुद्धताका लागि प्रयासरत छौं, तर कृपया ध्यान दिनुहोस् कि स्वचालित अनुवादमा त्रुटि वा अशुद्धता हुन सक्छ। मूल दस्तावेज यसको मूल भाषामा नै अधिकारिक स्रोत मानिनु पर्छ। महत्वपूर्ण जानकारीका लागि व्यावसायिक मानव अनुवाद सिफारिस गरिन्छ। यस अनुवादको प्रयोगबाट उत्पन्न कुनै पनि गलतफहमी वा गलत व्याख्याका लागि हामी जिम्मेवार छैनौं।