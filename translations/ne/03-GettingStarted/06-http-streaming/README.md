<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T18:15:46+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "ne"
}
-->
# HTTPS स्ट्रिमिङ मोडेल कन्टेक्स्ट प्रोटोकल (MCP) सँग

यस अध्यायले HTTPS प्रयोग गरी मोडेल कन्टेक्स्ट प्रोटोकल (MCP) मार्फत सुरक्षित, स्केलेबल, र रियल-टाइम स्ट्रिमिङ कसरी कार्यान्वयन गर्ने भन्ने विस्तृत मार्गदर्शन प्रदान गर्दछ। यसले स्ट्रिमिङको प्रेरणा, उपलब्ध ट्रान्सपोर्ट मेकानिज्महरू, MCP मा स्ट्रिमेबल HTTP कसरी कार्यान्वयन गर्ने, सुरक्षा सर्वोत्तम अभ्यासहरू, SSE बाट माइग्रेशन, र आफ्नै स्ट्रिमिङ MCP अनुप्रयोगहरू निर्माण गर्ने व्यावहारिक निर्देशनहरू समेट्छ।

## MCP मा ट्रान्सपोर्ट मेकानिज्महरू र स्ट्रिमिङ

यस खण्डले MCP मा उपलब्ध विभिन्न ट्रान्सपोर्ट मेकानिज्महरू र तिनीहरूको भूमिका अन्वेषण गर्दछ जसले क्लाइन्ट र सर्भरबीच रियल-टाइम सञ्चारका लागि स्ट्रिमिङ क्षमता सक्षम पार्दछ।

### ट्रान्सपोर्ट मेकानिज्म भनेको के हो?

ट्रान्सपोर्ट मेकानिज्मले क्लाइन्ट र सर्भरबीच डाटा कसरी आदानप्रदान हुन्छ भन्ने परिभाषित गर्छ। MCP ले विभिन्न वातावरण र आवश्यकताहरूलाई मेल खाने विभिन्न ट्रान्सपोर्ट प्रकारहरू समर्थन गर्दछ:

- **stdio**: स्ट्यान्डर्ड इनपुट/आउटपुट, स्थानीय र CLI-आधारित उपकरणहरूका लागि उपयुक्त। सरल तर वेब वा क्लाउडका लागि उपयुक्त छैन।
- **SSE (Server-Sent Events)**: सर्भरहरूले HTTP मार्फत क्लाइन्टलाई रियल-टाइम अपडेटहरू पठाउन अनुमति दिन्छ। वेब UI का लागि राम्रो, तर स्केलेबिलिटी र लचिलोपनमा सीमित।
- **Streamable HTTP**: आधुनिक HTTP-आधारित स्ट्रिमिङ ट्रान्सपोर्ट, सूचना र राम्रो स्केलेबिलिटी समर्थन गर्दछ। अधिकांश उत्पादन र क्लाउड परिदृश्यहरूका लागि सिफारिस गरिन्छ।

### तुलना तालिका

यी ट्रान्सपोर्ट मेकानिज्महरू बीचको भिन्नता बुझ्न तलको तुलना तालिका हेर्नुहोस्:

| ट्रान्सपोर्ट       | रियल-टाइम अपडेटहरू | स्ट्रिमिङ | स्केलेबिलिटी | प्रयोग केस               |
|-------------------|--------------------|-----------|--------------|-------------------------|
| stdio             | छैन               | छैन       | कम           | स्थानीय CLI उपकरणहरू    |
| SSE               | छ                 | छ         | मध्यम        | वेब, रियल-टाइम अपडेटहरू|
| Streamable HTTP   | छ                 | छ         | उच्च         | क्लाउड, बहु-क्लाइन्ट   |

> **टिप:** सही ट्रान्सपोर्ट चयनले प्रदर्शन, स्केलेबिलिटी, र प्रयोगकर्ता अनुभवमा प्रभाव पार्छ। **Streamable HTTP** आधुनिक, स्केलेबल, र क्लाउड-तयार अनुप्रयोगहरूको लागि सिफारिस गरिन्छ।

अघिल्लो अध्यायहरूमा देखाइएका stdio र SSE ट्रान्सपोर्टहरूलाई ध्यान दिनुहोस् र यस अध्यायमा समेटिएको Streamable HTTP ट्रान्सपोर्टलाई पनि।

## स्ट्रिमिङ: अवधारणा र प्रेरणा

स्ट्रिमिङको आधारभूत अवधारणा र प्रेरणालाई बुझ्नु प्रभावकारी रियल-टाइम सञ्चार प्रणालीहरू कार्यान्वयन गर्न आवश्यक छ।

**स्ट्रिमिङ** नेटवर्क प्रोग्रामिङमा एउटा प्रविधि हो जसले डाटा सानो, व्यवस्थापनयोग्य टुक्राहरूमा वा घटनाहरूको श्रृंखलाको रूपमा पठाउन र प्राप्त गर्न अनुमति दिन्छ, सम्पूर्ण प्रतिक्रिया तयार हुन कुर्नुको सट्टा। यो विशेष गरी उपयोगी छ:

- ठूला फाइलहरू वा डाटासेटहरूका लागि।
- रियल-टाइम अपडेटहरू (जस्तै, च्याट, प्रोग्रेस बारहरू)।
- लामो समयसम्म चल्ने गणनाहरू जहाँ प्रयोगकर्तालाई सूचित राख्न चाहिन्छ।

यहाँ स्ट्रिमिङको उच्च स्तरमा के जान्न आवश्यक छ:

- डाटा क्रमिक रूपमा प्रदान गरिन्छ, सबै एकैपटक होइन।
- क्लाइन्टले डाटा प्राप्त हुने बित्तिकै प्रशोधन गर्न सक्छ।
- महसुस गरिएको विलम्बता घटाउँछ र प्रयोगकर्ता अनुभव सुधार्छ।

### किन स्ट्रिमिङ प्रयोग गर्ने?

स्ट्रिमिङ प्रयोग गर्ने कारणहरू यस्ता छन्:

- प्रयोगकर्ताले तुरुन्त प्रतिक्रिया पाउँछन्, अन्त्यमा मात्र होइन।
- रियल-टाइम अनुप्रयोगहरू र प्रतिक्रियाशील UI सक्षम पार्दछ।
- नेटवर्क र कम्प्युट स्रोतहरूको अधिक कुशल प्रयोग।

### सरल उदाहरण: HTTP स्ट्रिमिङ सर्भर र क्लाइन्ट

यहाँ स्ट्रिमिङ कसरी कार्यान्वयन गर्न सकिन्छ भन्ने सरल उदाहरण छ:

## Python

**सर्भर (Python, FastAPI र StreamingResponse प्रयोग गर्दै):**

### Python

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```


**क्लाइन्ट (Python, requests प्रयोग गर्दै):**

### Python

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```


यो उदाहरणले देखाउँछ कि सर्भरले सबै सन्देशहरू तयार हुन कुर्नुको सट्टा उपलब्ध हुनासाथ क्लाइन्टलाई सन्देशहरूको श्रृंखला पठाउँछ।

**कसरी काम गर्छ:**
- सर्भर प्रत्येक सन्देश तयार भएपछि त्यसलाई पठाउँछ।
- क्लाइन्टले प्राप्त हुने प्रत्येक टुक्रा प्राप्त गरी प्रिन्ट गर्छ।

**आवश्यकताहरू:**
- सर्भरले स्ट्रिमिङ प्रतिक्रिया प्रयोग गर्नुपर्छ (जस्तै, FastAPI मा `StreamingResponse`)।
- क्लाइन्टले प्रतिक्रिया स्ट्रिमको रूपमा प्रशोधन गर्नुपर्छ (`stream=True` requests मा)।
- Content-Type सामान्यतया `text/event-stream` वा `application/octet-stream` हुन्छ।

## Java

**सर्भर (Java, Spring Boot र Server-Sent Events प्रयोग गर्दै):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लाइन्ट (Java, Spring WebFlux WebClient प्रयोग गर्दै):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java कार्यान्वयन नोटहरू:**
- Spring Boot को रियाक्टिभ स्ट्याक `Flux` सँग स्ट्रिमिङका लागि प्रयोग गरिएको
- `ServerSentEvent` ले संरचित इभेन्ट स्ट्रिमिङ र इभेन्ट प्रकारहरू प्रदान गर्दछ
- `WebClient` को `bodyToFlux()` ले रियाक्टिभ स्ट्रिमिङ उपभोग सक्षम पार्दछ
- `delayElements()` ले इभेन्टहरू बीचको प्रशोधन समय अनुकरण गर्दछ
- इभेन्टहरूमा प्रकारहरू (`info`, `result`) हुन सक्छन् जसले क्लाइन्टलाई राम्रोसँग ह्यान्डल गर्न मद्दत गर्छ

### तुलना: क्लासिक स्ट्रिमिङ बनाम MCP स्ट्रिमिङ

क्लासिक HTTP स्ट्रिमिङ र MCP स्ट्रिमिङ कसरी फरक हुन्छन् भन्ने कुरा यसरी देखाउन सकिन्छ:

| विशेषता               | क्लासिक HTTP स्ट्रिमिङ         | MCP स्ट्रिमिङ (सूचनाहरू)          |
|-----------------------|-------------------------------|----------------------------------|
| मुख्य प्रतिक्रिया      | टुक्रा टुक्रा पठाइन्छ          | एक पटक, अन्त्यमा पठाइन्छ         |
| प्रगति अपडेटहरू      | डाटा टुक्राहरूको रूपमा पठाइन्छ | सूचनाहरूको रूपमा पठाइन्छ          |
| क्लाइन्ट आवश्यकताहरू | स्ट्रिम प्रशोधन गर्नुपर्छ      | सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ |
| प्रयोग केस            | ठूला फाइलहरू, AI टोकन स्ट्रिमहरू | प्रगति, लगहरू, रियल-टाइम प्रतिक्रिया |

### मुख्य भिन्नताहरू

थप रूपमा, यहाँ केही मुख्य भिन्नताहरू छन्:

- **सञ्चार ढाँचा:**
   - क्लासिक HTTP स्ट्रिमिङ: सरल टुक्रा ट्रान्सफर इन्कोडिङ प्रयोग गरेर डाटा पठाउँछ
   - MCP स्ट्रिमिङ: JSON-RPC प्रोटोकलसहित संरचित सूचना प्रणाली प्रयोग गर्दछ

- **सन्देश ढाँचा:**
   - क्लासिक HTTP: नयाँ लाइन सहितको साधारण पाठ टुक्राहरू
   - MCP: मेटाडाटा सहित संरचित LoggingMessageNotification वस्तुहरू

- **क्लाइन्ट कार्यान्वयन:**
   - क्लासिक HTTP: स्ट्रिमिङ प्रतिक्रिया प्रशोधन गर्ने सरल क्लाइन्ट
   - MCP: विभिन्न प्रकारका सन्देशहरू प्रशोधन गर्न सन्देश ह्यान्डलर भएको जटिल क्लाइन्ट

- **प्रगति अपडेटहरू:**
   - क्लासिक HTTP: प्रगति मुख्य प्रतिक्रिया स्ट्रिमको भाग हो
   - MCP: प्रगति अलग सूचनाहरू मार्फत पठाइन्छ, मुख्य प्रतिक्रिया अन्त्यमा आउँछ

### सिफारिसहरू

क्लासिक स्ट्रिमिङ (जस्तै `/stream` अन्तबिन्दु प्रयोग गरेर) र MCP स्ट्रिमिङ बीच छनोट गर्दा केही सिफारिसहरू छन्:

- **सरल स्ट्रिमिङ आवश्यकताहरूका लागि:** क्लासिक HTTP स्ट्रिमिङ कार्यान्वयन गर्न सरल र आधारभूत आवश्यकताहरूका लागि पर्याप्त छ।

- **जटिल, अन्तरक्रियात्मक अनुप्रयोगहरूका लागि:** MCP स्ट्रिमिङले धनी मेटाडाटा र सूचनाहरू र अन्तिम परिणामहरू बीच छुट्टाछुट्टै विभाजन सहित संरचित दृष्टिकोण प्रदान गर्दछ।

- **AI अनुप्रयोगहरूका लागि:** MCP को सूचना प्रणाली लामो समयसम्म चल्ने AI कार्यहरूमा प्रगति सूचित गर्न विशेष रूपमा उपयोगी छ।

## MCP मा स्ट्रिमिङ

अहिले सम्म तपाईंले क्लासिक स्ट्रिमिङ र MCP स्ट्रिमिङ बीचको भिन्नता र सिफारिसहरू देख्नुभयो। अब MCP मा स्ट्रिमिङ कसरी प्रयोग गर्ने भन्ने विस्तृत रूपमा जानौं।

MCP फ्रेमवर्क भित्र स्ट्रिमिङ कसरी काम गर्छ भन्ने बुझ्नु आवश्यक छ ताकि लामो समयसम्म चल्ने अपरेसनहरूमा प्रयोगकर्तालाई रियल-टाइम प्रतिक्रिया दिने प्रतिक्रियाशील अनुप्रयोगहरू निर्माण गर्न सकियोस्।

MCP मा, स्ट्रिमिङ मुख्य प्रतिक्रियालाई टुक्रा टुक्रा पठाउने कुरा होइन, तर उपकरणले अनुरोध प्रशोधन गर्दा क्लाइन्टलाई **सूचनाहरू** पठाउने कुरा हो। यी सूचनाहरूमा प्रगति अपडेटहरू, लगहरू, वा अन्य घटनाहरू समावेश हुन सक्छन्।

### कसरी काम गर्छ

मुख्य परिणाम अझै एकल प्रतिक्रियाको रूपमा पठाइन्छ। तर, प्रशोधनको क्रममा अलग सन्देशहरूका रूपमा सूचनाहरू पठाउन सकिन्छ जसले क्लाइन्टलाई रियल-टाइममा अपडेट गर्दछ। क्लाइन्टले यी सूचनाहरूलाई ह्यान्डल र प्रदर्शन गर्न सक्षम हुनुपर्छ।

## सूचना भनेको के हो?

हामीले "सूचना" भनेका थियौं, MCP सन्दर्भमा यसको अर्थ के हो?

सूचना भनेको सर्भरबाट क्लाइन्टलाई पठाइने सन्देश हो जसले लामो समयसम्म चल्ने अपरेसनको प्रगति, स्थिति, वा अन्य घटनाहरूको बारेमा जानकारी दिन्छ। सूचनाले पारदर्शिता र प्रयोगकर्ता अनुभव सुधार्छ।

उदाहरणका लागि, क्लाइन्टले सर्भरसँग प्रारम्भिक ह्याण्डशेक भएपछि सूचना पठाउनुपर्छ।

सूचना JSON सन्देशको रूपमा यसरी देखिन्छ:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

सूचनाहरू MCP मा ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) शीर्षक अन्तर्गत पर्छन्।

लगिङ काम गर्न सर्भरले यसलाई सुविधा/क्षमता रूपमा सक्षम पार्नुपर्छ:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> प्रयोग गरिएको SDK अनुसार, लगिङ डिफल्टमा सक्षम हुन सक्छ वा तपाईंले सर्भर कन्फिगरेसनमा स्पष्ट रूपमा सक्षम पार्नुपर्ने हुन सक्छ।

सूचनाका विभिन्न प्रकारहरू छन्:

| स्तर       | विवरण                         | उदाहरण प्रयोग केस             |
|------------|-------------------------------|-------------------------------|
| debug      | विस्तृत डिबगिङ जानकारी       | फङ्सन प्रवेश/निकास बिन्दुहरू  |
| info       | सामान्य सूचना सन्देशहरू       | अपरेसन प्रगति अपडेटहरू       |
| notice     | सामान्य तर महत्वपूर्ण घटनाहरू | कन्फिगरेसन परिवर्तनहरू        |
| warning    | चेतावनी अवस्था               | अप्रचलित सुविधा प्रयोग        |
| error      | त्रुटि अवस्था                | अपरेसन असफलताहरू             |
| critical   | गम्भीर अवस्था               | प्रणाली कम्पोनेन्ट असफलता     |
| alert      | तुरुन्त कारबाही आवश्यक       | डाटा भ्रष्टाचार पत्ता लागेको |
| emergency  | प्रणाली प्रयोगयोग्य छैन       | पूर्ण प्रणाली असफलता          |

## MCP मा सूचनाहरू कार्यान्वयन गर्ने

MCP मा सूचनाहरू कार्यान्वयन गर्न, तपाईंले सर्भर र क्लाइन्ट दुवै पक्षलाई रियल-टाइम अपडेटहरू ह्यान्डल गर्न तयार पार्नुपर्छ। यसले लामो समयसम्म चल्ने अपरेसनहरूमा प्रयोगकर्तालाई तुरुन्त प्रतिक्रिया दिन मद्दत गर्दछ।

### सर्भर-पक्ष: सूचनाहरू पठाउने

सर्भर पक्षबाट सुरु गरौं। MCP मा, तपाईंले उपकरणहरू परिभाषित गर्नुहुन्छ जसले अनुरोध प्रशोधन गर्दा सूचनाहरू पठाउन सक्छन्। सर्भरले सन्देशहरू पठाउन सन्दर्भ वस्तु (सामान्यतया `ctx`) प्रयोग गर्छ।

### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

अघिल्लो उदाहरणमा, `process_files` उपकरणले प्रत्येक फाइल प्रशोधन गर्दा क्लाइन्टलाई तीनवटा सूचना पठाउँछ। `ctx.info()` विधि सूचना सन्देशहरू पठाउन प्रयोग गरिएको छ।

थप रूपमा, सूचनाहरू सक्षम गर्न, तपाईंको सर्भरले स्ट्रिमिङ ट्रान्सपोर्ट (जस्तै `streamable-http`) प्रयोग गर्नुपर्छ र क्लाइन्टले सूचनाहरू प्रशोधन गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ। यहाँ कसरी सर्भरलाई `streamable-http` ट्रान्सपोर्ट प्रयोग गर्न सेटअप गर्ने देखाइएको छ:

```python
mcp.run(transport="streamable-http")
```

### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

यस .NET उदाहरणमा, `ProcessFiles` उपकरण `Tool` एट्रिब्युटले सजाइएको छ र प्रत्येक फाइल प्रशोधन गर्दा क्लाइन्टलाई तीनवटा सूचना पठाउँछ। `ctx.Info()` विधि सूचना सन्देशहरू पठाउन प्रयोग गरिएको छ।

तपाईंको .NET MCP सर्भरमा सूचनाहरू सक्षम गर्न, स्ट्रिमिङ ट्रान्सपोर्ट प्रयोग गरिरहेको सुनिश्चित गर्नुहोस्:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### क्लाइन्ट-पक्ष: सूचनाहरू प्राप्त गर्ने

क्लाइन्टले सूचनाहरू प्राप्त गरी प्रदर्शन गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ।

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

अघिल्लो कोडमा, `message_handler` फङ्सनले आउने सन्देश सूचना हो कि होइन जाँच गर्छ। यदि हो भने, सूचना प्रिन्ट गर्छ; नभए सामान्य सर्भर सन्देशको रूपमा प्रशोधन गर्छ। साथै, `ClientSession` लाई `message_handler` सँग इनिसियलाइज गरिएको छ ताकि आउने सूचनाहरू ह्यान्डल गर्न सकियोस्।

### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

यस .NET उदाहरणमा, `MessageHandler` फङ्सनले आउने सन्देश सूचना हो कि होइन जाँच गर्छ। यदि हो भने, सूचना प्रिन्ट गर्छ; नभए सामान्य सर्भर सन्देशको रूपमा प्रशोधन गर्छ। `ClientSession` लाई `ClientSessionOptions` मार्फत सन्देश ह्यान्डलरसँग इनिसियलाइज गरिएको छ।

सूचनाहरू सक्षम गर्न, सर्भरले स्ट्रिमिङ ट्रान्सपोर्ट (जस्तै `streamable-http`) प्रयोग गर्नुपर्छ र क्लाइन्टले सूचनाहरू प्रशोधन गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुपर्छ।

## प्रगति सूचनाहरू र परिदृश्यहरू

यस खण्डले MCP मा प्रगति सूचनाहरूको अवधारणा, तिनीहरू किन महत्वपूर्ण छन्, र Streamable HTTP प्रयोग गरी कसरी कार्यान्वयन गर्ने व्याख्या गर्दछ। तपाईंले बुझाइलाई बलियो बनाउन व्यावहारिक अभ्यास पनि पाउनुहुनेछ।

प्रगति सूचनाहरू लामो समयसम्म चल्ने अपरेसनहरूमा सर्भरबाट क्लाइन्टलाई पठाइने रियल-टाइम सन्देशहरू हुन्। सम्पूर्ण प्रक्रिया समाप्त हुन कुर्नुको सट्टा, सर्भरले क्लाइन्टलाई वर्तमान स्थिति बारे अपडेट राख्छ। यसले पारदर्शिता, प्रयोगकर्ता अनुभव सुधार्छ र डिबगिङ सजिलो बनाउँछ।

**उदाहरण:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### किन प्रगति सूचनाहरू प्रयोग गर्ने?

प्रगति सूचनाहरू आवश्यक छन् किनभने:

- **राम्रो प्रयोगकर्ता अनुभव:** काम प्रगति भइरहँदा प्रयोगकर्ताले अपडेटहरू देख्छन्, अन्त्यमा मात्र होइन।
- **रियल-टाइम प्रतिक्रिया:** क्लाइन्टहरूले प्रगति बार वा लगहरू प्रदर्शन गर्न सक्छन्, जसले अनुप्रयोगलाई प्रतिक्रियाशील बनाउँछ।
- **डिबगिङ र अनुगमन सजिलो:** विकासकर्ता र प्रयोगकर्ताले प्रक्रिया कहाँ ढिलो वा अड्किएको छ देख्न सक्छन्।

### प्रगति सूचनाहरू कसरी कार्यान्वयन गर्ने

MCP मा प्रगति सूचनाहरू कार्यान्वयन गर्ने तरिका:

- **सर्भरमा:** प्रत्येक वस्तु प्रशोधन हुँदा `ctx.info()` वा `ctx.log()` प्रयोग गरी सूचनाहरू पठाउनुहोस्। यसले मुख्य परिणाम तयार हुनु अघि क्लाइन्टलाई सन्देश पठाउँछ।
- **क्लाइन्टमा:** सूचनाहरू प्राप्त गरी प्रदर्शन गर्न सन्देश ह्यान्डलर कार्यान्वयन गर्नुहोस्। यस ह्यान्डलरले सूचनाहरू र अन्तिम परिणाम छुट्याउँछ।

**सर्भर उदाहरण:**

## Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```


**क्लाइन्ट उदाहरण:**

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```


## सुरक्षा विचारहरू

HTTP-आधारित ट्रान्सपोर्टहरूसँग MCP सर्भरहरू कार्यान्वयन गर्दा सुरक्षा अत्यन्त महत्वपूर्ण हुन्छ र विभिन्न आक्रमण मार्गहरू र सुरक्षा उपायहरूमा ध्यान दिनुपर्छ।

### अवलोकन

HTTP मार्फत MCP सर्भरहरू सार्वजनिक गर्दा सुरक्षा महत्वपूर्ण हुन्छ। Streamable HTTP ले नयाँ आक्रमण सतहहरू ल्याउँछ र सावधानीपूर्वक कन्फिगरेसन आवश्यक हुन्छ।

### मुख्य बुँदाहरू
- **Origin Header प्रमाणीकरण:** DNS रिबाइन्डिङ आक्रमण रोक्न `Origin
### किन अपग्रेड गर्ने?

SSE बाट Streamable HTTP मा अपग्रेड गर्न दुई मुख्य कारणहरू छन्:

- Streamable HTTP ले SSE भन्दा राम्रो स्केलेबिलिटी, कम्प्याटिबिलिटी, र समृद्ध सूचना समर्थन प्रदान गर्छ।
- यो नयाँ MCP एप्लिकेसनहरूको लागि सिफारिस गरिएको ट्रान्सपोर्ट हो।

### माइग्रेशनका चरणहरू

यहाँ तपाईँले आफ्नो MCP एप्लिकेसनहरूमा SSE बाट Streamable HTTP मा कसरी माइग्रेट गर्ने भनेर छ:

- **सर्भर कोड अपडेट गर्नुहोस्** `mcp.run()` मा `transport="streamable-http"` प्रयोग गर्न।
- **क्लाइन्ट कोड अपडेट गर्नुहोस्** SSE क्लाइन्टको सट्टा `streamablehttp_client` प्रयोग गर्न।
- **क्लाइन्टमा मेसेज ह्यान्डलर लागू गर्नुहोस्** सूचना प्रक्रिया गर्न।
- **मौजुदा उपकरण र कार्यप्रवाहहरूसँग कम्प्याटिबिलिटी परीक्षण गर्नुहोस्**।

### कम्प्याटिबिलिटी कायम राख्ने

माइग्रेशन प्रक्रियामा मौजुदा SSE क्लाइन्टहरूसँग कम्प्याटिबिलिटी कायम राख्न सिफारिस गरिन्छ। यहाँ केही रणनीतिहरू छन्:

- तपाईँ SSE र Streamable HTTP दुवैलाई फरक-फरक एन्डपोइन्टहरूमा चलाएर समर्थन गर्न सक्नुहुन्छ।
- क्लाइन्टहरूलाई क्रमशः नयाँ ट्रान्सपोर्टमा माइग्रेट गर्नुहोस्।

### चुनौतीहरू

माइग्रेशनको क्रममा निम्न चुनौतीहरू समाधान गर्न सुनिश्चित गर्नुहोस्:

- सबै क्लाइन्टहरू अपडेट गरिएको छ कि छैन भनेर सुनिश्चित गर्नु।
- सूचना वितरणमा भिन्नताहरूको व्यवस्थापन।

## सुरक्षा सम्बन्धी विचारहरू

कुनै पनि सर्भर लागू गर्दा सुरक्षा सबैभन्दा महत्वपूर्ण हुनुपर्छ, विशेष गरी MCP मा Streamable HTTP जस्ता HTTP-आधारित ट्रान्सपोर्टहरू प्रयोग गर्दा।

HTTP-आधारित ट्रान्सपोर्टहरूसँग MCP सर्भरहरू लागू गर्दा सुरक्षा धेरै महत्त्वपूर्ण हुन्छ र यसले विभिन्न आक्रमणका तरिकाहरू र सुरक्षा उपायहरूमा ध्यान दिन आवश्यक हुन्छ।

### अवलोकन

HTTP मार्फत MCP सर्भरहरू एक्सपोज गर्दा सुरक्षा अत्यन्त जरुरी हुन्छ। Streamable HTTP ले नयाँ आक्रमण सतहहरू ल्याउँछ र सावधानीपूर्वक कन्फिगरेसन आवश्यक पर्छ।

यहाँ केही मुख्य सुरक्षा विचारहरू छन्:

- **Origin Header मान्यकरण**: DNS rebinding आक्रमण रोक्न `Origin` हेडर सधैं मान्य गर्नुहोस्।
- **Localhost बाइन्डिङ**: स्थानीय विकासका लागि सर्भरहरूलाई `localhost` मा बाइन्ड गर्नुहोस् ताकि सार्वजनिक इन्टरनेटमा एक्सपोज नहोस्।
- **प्रमाणीकरण**: उत्पादनमा API कुञ्जीहरू, OAuth जस्ता प्रमाणीकरण लागू गर्नुहोस्।
- **CORS**: पहुँच सीमित गर्न Cross-Origin Resource Sharing (CORS) नीति कन्फिगर गर्नुहोस्।
- **HTTPS**: उत्पादनमा ट्राफिक इन्क्रिप्ट गर्न HTTPS प्रयोग गर्नुहोस्।

### उत्तम अभ्यासहरू

MCP स्ट्रिमिङ सर्भरमा सुरक्षा लागू गर्दा यी उत्तम अभ्यासहरू पालना गर्नुहोस्:

- बिना मान्यकरण आउने अनुरोधहरूमा कहिल्यै विश्वास नगर्नुहोस्।
- सबै पहुँच र त्रुटिहरू लग र अनुगमन गर्नुहोस्।
- सुरक्षा कमजोरीहरू पत्ता लगाउन नियमित रूपमा निर्भरता अपडेट गर्नुहोस्।

### चुनौतीहरू

MCP स्ट्रिमिङ सर्भरमा सुरक्षा लागू गर्दा तपाईँले केही चुनौतीहरू सामना गर्नु पर्नेछ:

- विकास सजिलो र सुरक्षा बीच सन्तुलन कायम राख्नु।
- विभिन्न क्लाइन्ट वातावरणहरूसँग कम्प्याटिबिलिटी सुनिश्चित गर्नु।

### कार्य: आफ्नो स्ट्रिमिङ MCP एप बनाउनुहोस्

**परिदृश्य:**
एक MCP सर्भर र क्लाइन्ट बनाउनुहोस् जहाँ सर्भरले वस्तुहरूको सूची (जस्तै फाइलहरू वा कागजातहरू) प्रक्रिया गर्छ र प्रत्येक वस्तु प्रक्रिया भएपछि सूचना पठाउँछ। क्लाइन्टले प्रत्येक सूचना प्राप्त हुने बित्तिकै देखाउनु पर्छ।

**चरणहरू:**

1. सूची प्रक्रिया गर्ने र प्रत्येक वस्तुका लागि सूचना पठाउने सर्भर उपकरण लागू गर्नुहोस्।
2. सूचना वास्तविक समयमा देखाउन मेसेज ह्यान्डलर सहित क्लाइन्ट लागू गर्नुहोस्।
3. सर्भर र क्लाइन्ट दुवै चलाएर आफ्नो कार्यान्वयन परीक्षण गर्नुहोस् र सूचनाहरू अवलोकन गर्नुहोस्।

[Solution](./solution/README.md)

## थप पढाइ र के गर्ने?

MCP स्ट्रिमिङसँग आफ्नो यात्रा जारी राख्न र ज्ञान विस्तार गर्न, यो खण्डले थप स्रोतहरू र उन्नत एप्लिकेसनहरू बनाउनका लागि सुझावहरू प्रदान गर्दछ।

### थप पढाइ

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### के गर्ने?

- वास्तविक-समय विश्लेषण, च्याट, वा सहकार्य सम्पादनका लागि स्ट्रिमिङ प्रयोग गर्ने थप उन्नत MCP उपकरणहरू बनाउन प्रयास गर्नुहोस्।
- MCP स्ट्रिमिङलाई फ्रन्टएन्ड फ्रेमवर्कहरू (React, Vue, आदि) सँग एकीकृत गरेर लाइभ UI अपडेटहरू अन्वेषण गर्नुहोस्।
- अर्को: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**अस्वीकरण**:  
यो दस्तावेज AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) प्रयोग गरी अनुवाद गरिएको हो। हामी शुद्धताका लागि प्रयासरत छौं, तर कृपया ध्यान दिनुहोस् कि स्वचालित अनुवादमा त्रुटि वा अशुद्धता हुन सक्छ। मूल दस्तावेज यसको मूल भाषामा नै अधिकारिक स्रोत मानिनुपर्छ। महत्वपूर्ण जानकारीका लागि व्यावसायिक मानव अनुवाद सिफारिस गरिन्छ। यस अनुवादको प्रयोगबाट उत्पन्न कुनै पनि गलतफहमी वा गलत व्याख्याका लागि हामी जिम्मेवार छैनौं।