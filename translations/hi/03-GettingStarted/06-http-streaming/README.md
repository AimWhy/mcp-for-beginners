<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T18:04:41+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "hi"
}
-->
# Model Context Protocol (MCP) के साथ HTTPS स्ट्रीमिंग

यह अध्याय Model Context Protocol (MCP) का उपयोग करके HTTPS के माध्यम से सुरक्षित, स्केलेबल और रियल-टाइम स्ट्रीमिंग को लागू करने के लिए एक व्यापक मार्गदर्शिका प्रदान करता है। इसमें स्ट्रीमिंग के पीछे प्रेरणा, उपलब्ध ट्रांसपोर्ट मैकेनिज्म, MCP में स्ट्रीमेबल HTTP को कैसे लागू करें, सुरक्षा सर्वोत्तम प्रथाएँ, SSE से माइग्रेशन, और अपने स्वयं के स्ट्रीमिंग MCP एप्लिकेशन बनाने के लिए व्यावहारिक मार्गदर्शन शामिल है।

## MCP में ट्रांसपोर्ट मैकेनिज्म और स्ट्रीमिंग

यह अनुभाग MCP में उपलब्ध विभिन्न ट्रांसपोर्ट मैकेनिज्म और क्लाइंट और सर्वर के बीच रियल-टाइम संचार के लिए स्ट्रीमिंग क्षमताओं को सक्षम करने में उनकी भूमिका का पता लगाता है।

### ट्रांसपोर्ट मैकेनिज्म क्या है?

ट्रांसपोर्ट मैकेनिज्म यह परिभाषित करता है कि क्लाइंट और सर्वर के बीच डेटा कैसे आदान-प्रदान किया जाता है। MCP विभिन्न वातावरणों और आवश्यकताओं के अनुसार कई ट्रांसपोर्ट प्रकारों का समर्थन करता है:

- **stdio**: स्टैंडर्ड इनपुट/आउटपुट, स्थानीय और CLI-आधारित टूल्स के लिए उपयुक्त। सरल लेकिन वेब या क्लाउड के लिए उपयुक्त नहीं।
- **SSE (Server-Sent Events)**: सर्वर को HTTP के माध्यम से क्लाइंट को रियल-टाइम अपडेट भेजने की अनुमति देता है। वेब UI के लिए अच्छा, लेकिन स्केलेबिलिटी और लचीलापन सीमित।
- **Streamable HTTP**: आधुनिक HTTP-आधारित स्ट्रीमिंग ट्रांसपोर्ट, नोटिफिकेशन और बेहतर स्केलेबिलिटी का समर्थन करता है। अधिकांश प्रोडक्शन और क्लाउड परिदृश्यों के लिए अनुशंसित।

### तुलना तालिका

नीचे दी गई तुलना तालिका में इन ट्रांसपोर्ट मैकेनिज्म के बीच अंतर को समझें:

| ट्रांसपोर्ट       | रियल-टाइम अपडेट्स | स्ट्रीमिंग | स्केलेबिलिटी | उपयोग का मामला           |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | नहीं             | नहीं      | कम          | स्थानीय CLI टूल्स       |
| SSE               | हाँ              | हाँ       | मध्यम       | वेब, रियल-टाइम अपडेट्स |
| Streamable HTTP   | हाँ              | हाँ       | उच्च        | क्लाउड, मल्टी-क्लाइंट   |

> **टिप:** सही ट्रांसपोर्ट चुनना प्रदर्शन, स्केलेबिलिटी और उपयोगकर्ता अनुभव को प्रभावित करता है। **Streamable HTTP** आधुनिक, स्केलेबल और क्लाउड-तैयार एप्लिकेशन के लिए अनुशंसित है।

पिछले अध्यायों में आपको दिखाए गए stdio और SSE ट्रांसपोर्ट को ध्यान में रखें और देखें कि इस अध्याय में स्ट्रीमेबल HTTP ट्रांसपोर्ट को कवर किया गया है।

## स्ट्रीमिंग: अवधारणाएँ और प्रेरणा

स्ट्रीमिंग के मूलभूत सिद्धांतों और प्रेरणाओं को समझना प्रभावी रियल-टाइम संचार प्रणालियों को लागू करने के लिए आवश्यक है।

**स्ट्रीमिंग** नेटवर्क प्रोग्रामिंग में एक तकनीक है जो डेटा को छोटे, प्रबंधनीय हिस्सों में या घटनाओं की एक श्रृंखला के रूप में भेजने और प्राप्त करने की अनुमति देती है, बजाय इसके कि पूरी प्रतिक्रिया तैयार होने तक इंतजार किया जाए। यह विशेष रूप से उपयोगी है:

- बड़े फ़ाइलों या डेटा सेट के लिए।
- रियल-टाइम अपडेट्स (जैसे, चैट, प्रोग्रेस बार) के लिए।
- लंबी अवधि के कंप्यूटेशन के लिए जहाँ आप उपयोगकर्ता को सूचित रखना चाहते हैं।

यहाँ स्ट्रीमिंग के बारे में उच्च स्तर पर जानने योग्य बातें हैं:

- डेटा धीरे-धीरे भेजा जाता है, एक साथ नहीं।
- क्लाइंट डेटा को आते ही प्रोसेस कर सकता है।
- प्रत्याशित विलंबता को कम करता है और उपयोगकर्ता अनुभव को बेहतर बनाता है।

### स्ट्रीमिंग क्यों उपयोग करें?

स्ट्रीमिंग के उपयोग के कारण निम्नलिखित हैं:

- उपयोगकर्ताओं को तुरंत प्रतिक्रिया मिलती है, केवल अंत में नहीं।
- रियल-टाइम एप्लिकेशन और प्रतिक्रियाशील UI सक्षम करता है।
- नेटवर्क और कंप्यूट संसाधनों का अधिक कुशल उपयोग।

### सरल उदाहरण: HTTP स्ट्रीमिंग सर्वर और क्लाइंट

यहाँ एक सरल उदाहरण है कि स्ट्रीमिंग को कैसे लागू किया जा सकता है:

## Python

**सर्वर (Python, FastAPI और StreamingResponse का उपयोग करते हुए):**

### Python

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**क्लाइंट (Python, requests का उपयोग करते हुए):**

### Python

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

यह उदाहरण दिखाता है कि सर्वर क्लाइंट को संदेशों की एक श्रृंखला भेजता है जैसे ही वे उपलब्ध होते हैं, बजाय इसके कि सभी संदेश तैयार होने तक इंतजार किया जाए।

**यह कैसे काम करता है:**
- सर्वर प्रत्येक संदेश को जैसे ही वह तैयार होता है, भेजता है।
- क्लाइंट प्रत्येक प्राप्त हिस्से को प्राप्त करता है और प्रिंट करता है।

**आवश्यकताएँ:**
- सर्वर को स्ट्रीमिंग प्रतिक्रिया का उपयोग करना चाहिए (जैसे, FastAPI में `StreamingResponse`)।
- क्लाइंट को प्रतिक्रिया को स्ट्रीम के रूप में प्रोसेस करना चाहिए (`stream=True` requests में)।
- Content-Type आमतौर पर `text/event-stream` या `application/octet-stream` होता है।

## Java

**सर्वर (Java, Spring Boot और Server-Sent Events का उपयोग करते हुए):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**क्लाइंट (Java, Spring WebFlux WebClient का उपयोग करते हुए):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java कार्यान्वयन नोट्स:**
- Spring Boot के रिएक्टिव स्टैक के साथ `Flux` का उपयोग करता है स्ट्रीमिंग के लिए
- `ServerSentEvent` इवेंट प्रकारों के साथ संरचित इवेंट स्ट्रीमिंग प्रदान करता है
- `WebClient` के साथ `bodyToFlux()` रिएक्टिव स्ट्रीमिंग उपभोग सक्षम करता है
- `delayElements()` इवेंट्स के बीच प्रोसेसिंग समय का अनुकरण करता है
- इवेंट्स के प्रकार हो सकते हैं (`info`, `result`) बेहतर क्लाइंट हैंडलिंग के लिए

### तुलना: क्लासिक स्ट्रीमिंग बनाम MCP स्ट्रीमिंग

"क्लासिक" HTTP स्ट्रीमिंग और MCP में स्ट्रीमिंग के बीच अंतर इस प्रकार दर्शाया जा सकता है:

| विशेषता               | क्लासिक HTTP स्ट्रीमिंग       | MCP स्ट्रीमिंग (नोटिफिकेशन)       |
|-----------------------|------------------------------|-----------------------------------|
| मुख्य प्रतिक्रिया      | चंकीड (टुकड़ों में)           | एकल, अंत में                      |
| प्रगति अपडेट्स        | डेटा चंक्स के रूप में भेजे जाते हैं | नोटिफिकेशन के रूप में भेजे जाते हैं |
| क्लाइंट आवश्यकताएँ    | स्ट्रीम को प्रोसेस करना चाहिए | मैसेज हैंडलर लागू करना चाहिए       |
| उपयोग का मामला        | बड़ी फ़ाइलें, AI टोकन स्ट्रीम | प्रगति, लॉग, रियल-टाइम फीडबैक    |

### मुख्य अंतर

इसके अलावा, कुछ मुख्य अंतर हैं:

- **संचार पैटर्न:**
   - क्लासिक HTTP स्ट्रीमिंग: सरल चंकीड ट्रांसफर एन्कोडिंग का उपयोग करता है
   - MCP स्ट्रीमिंग: JSON-RPC प्रोटोकॉल के साथ संरचित नोटिफिकेशन सिस्टम का उपयोग करता है

- **मैसेज फॉर्मेट:**
   - क्लासिक HTTP: नए लाइनों के साथ प्लेन टेक्स्ट चंक्स
   - MCP: मेटाडेटा के साथ संरचित LoggingMessageNotification ऑब्जेक्ट्स

- **क्लाइंट कार्यान्वयन:**
   - क्लासिक HTTP: सरल क्लाइंट जो स्ट्रीमिंग प्रतिक्रियाओं को प्रोसेस करता है
   - MCP: अधिक परिष्कृत क्लाइंट जो विभिन्न प्रकार के संदेशों को प्रोसेस करने के लिए मैसेज हैंडलर का उपयोग करता है

- **प्रगति अपडेट्स:**
   - क्लासिक HTTP: प्रगति मुख्य प्रतिक्रिया स्ट्रीम का हिस्सा होती है
   - MCP: प्रगति अलग नोटिफिकेशन संदेशों के माध्यम से भेजी जाती है जबकि मुख्य प्रतिक्रिया अंत में आती है

### सिफारिशें

क्लासिक स्ट्रीमिंग (जैसे हमने ऊपर `/stream` का उपयोग करते हुए दिखाया) और MCP के माध्यम से स्ट्रीमिंग के बीच चयन करते समय कुछ सिफारिशें हैं:

- **सरल स्ट्रीमिंग आवश्यकताओं के लिए:** क्लासिक HTTP स्ट्रीमिंग लागू करने में सरल है और बुनियादी स्ट्रीमिंग आवश्यकताओं के लिए पर्याप्त है।

- **जटिल, इंटरैक्टिव एप्लिकेशन के लिए:** MCP स्ट्रीमिंग अधिक संरचित दृष्टिकोण प्रदान करता है जिसमें समृद्ध मेटाडेटा और नोटिफिकेशन तथा अंतिम परिणाम के बीच स्पष्ट विभाजन होता है।

- **AI एप्लिकेशन के लिए:** MCP का नोटिफिकेशन सिस्टम लंबी अवधि के AI कार्यों के लिए विशेष रूप से उपयोगी है जहाँ आप उपयोगकर्ताओं को प्रगति से अवगत रखना चाहते हैं।

## MCP में स्ट्रीमिंग

अब तक आपने क्लासिक स्ट्रीमिंग और MCP में स्ट्रीमिंग के बीच कुछ सिफारिशें और तुलना देखी हैं। आइए विस्तार से देखें कि आप MCP में स्ट्रीमिंग का लाभ कैसे उठा सकते हैं।

MCP फ्रेमवर्क के भीतर स्ट्रीमिंग कैसे काम करती है यह समझना आवश्यक है ताकि आप प्रतिक्रियाशील एप्लिकेशन बना सकें जो लंबी अवधि के ऑपरेशनों के दौरान उपयोगकर्ताओं को रियल-टाइम फीडबैक प्रदान करें।

MCP में, स्ट्रीमिंग का मतलब मुख्य प्रतिक्रिया को टुकड़ों में भेजना नहीं है, बल्कि एक टूल के अनुरोध को प्रोसेस करते समय क्लाइंट को **नोटिफिकेशन** भेजना है। ये नोटिफिकेशन प्रगति अपडेट, लॉग, या अन्य घटनाएँ हो सकती हैं।

### यह कैसे काम करता है

मुख्य परिणाम अभी भी एकल प्रतिक्रिया के रूप में भेजा जाता है। हालांकि, प्रोसेसिंग के दौरान नोटिफिकेशन अलग संदेशों के रूप में भेजे जा सकते हैं और इस प्रकार क्लाइंट को रियल-टाइम में अपडेट किया जा सकता है। क्लाइंट को इन नोटिफिकेशन को संभालने और प्रदर्शित करने में सक्षम होना चाहिए।

## नोटिफिकेशन क्या है?

हमने "नोटिफिकेशन" कहा, MCP के संदर्भ में इसका क्या मतलब है?

नोटिफिकेशन एक संदेश है जो सर्वर से क्लाइंट को भेजा जाता है ताकि लंबी अवधि के ऑपरेशन के दौरान प्रगति, स्थिति, या अन्य घटनाओं के बारे में सूचित किया जा सके। नोटिफिकेशन पारदर्शिता और उपयोगकर्ता अनुभव को बेहतर बनाते हैं।

उदाहरण के लिए, क्लाइंट को एक नोटिफिकेशन भेजना चाहिए जब सर्वर के साथ प्रारंभिक हैंडशेक पूरा हो जाए।

नोटिफिकेशन इस प्रकार JSON संदेश के रूप में दिखता है:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

नोटिफिकेशन MCP में ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) नामक एक टॉपिक से संबंधित होते हैं।

लॉगिंग को काम करने के लिए, सर्वर को इसे फीचर/क्षमता के रूप में सक्षम करना होता है, जैसे:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> उपयोग किए गए SDK के आधार पर, लॉगिंग डिफ़ॉल्ट रूप से सक्षम हो सकता है, या आपको इसे अपने सर्वर कॉन्फ़िगरेशन में स्पष्ट रूप से सक्षम करना पड़ सकता है।

नोटिफिकेशन के विभिन्न प्रकार होते हैं:

| स्तर       | विवरण                         | उदाहरण उपयोग मामला             |
|------------|------------------------------|-------------------------------|
| debug      | विस्तृत डिबगिंग जानकारी       | फ़ंक्शन एंट्री/एग्जिट पॉइंट्स |
| info       | सामान्य सूचना संदेश           | ऑपरेशन प्रगति अपडेट्स         |
| notice     | सामान्य लेकिन महत्वपूर्ण घटनाएँ | कॉन्फ़िगरेशन परिवर्तन          |
| warning    | चेतावनी स्थितियाँ             | अप्रचलित फीचर का उपयोग         |
| error      | त्रुटि स्थितियाँ              | ऑपरेशन विफलताएँ               |
| critical   | गंभीर स्थितियाँ              | सिस्टम कंपोनेंट विफलताएँ      |
| alert      | तुरंत कार्रवाई आवश्यक         | डेटा भ्रष्टाचार का पता लगना    |
| emergency  | सिस्टम अनुपयोगी है           | पूर्ण सिस्टम विफलता            |

## MCP में नोटिफिकेशन लागू करना

MCP में नोटिफिकेशन लागू करने के लिए, आपको सर्वर और क्लाइंट दोनों पक्षों को रियल-टाइम अपडेट्स को संभालने के लिए सेटअप करना होगा। इससे आपका एप्लिकेशन लंबी अवधि के ऑपरेशनों के दौरान उपयोगकर्ताओं को तुरंत प्रतिक्रिया प्रदान कर सकेगा।

### सर्वर-साइड: नोटिफिकेशन भेजना

आइए सर्वर साइड से शुरू करें। MCP में, आप ऐसे टूल परिभाषित करते हैं जो अनुरोधों को प्रोसेस करते समय नोटिफिकेशन भेज सकते हैं। सर्वर संदर्भ ऑब्जेक्ट (आमतौर पर `ctx`) का उपयोग क्लाइंट को संदेश भेजने के लिए करता है।

### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

पिछले उदाहरण में, `process_files` टूल प्रत्येक फ़ाइल को प्रोसेस करते समय क्लाइंट को तीन नोटिफिकेशन भेजता है। `ctx.info()` मेथड का उपयोग सूचना संदेश भेजने के लिए किया जाता है।

इसके अलावा, नोटिफिकेशन सक्षम करने के लिए, सुनिश्चित करें कि आपका सर्वर स्ट्रीमिंग ट्रांसपोर्ट (जैसे `streamable-http`) का उपयोग करता है और आपका क्लाइंट नोटिफिकेशन प्रोसेस करने के लिए मैसेज हैंडलर लागू करता है। यहाँ बताया गया है कि आप सर्वर को `streamable-http` ट्रांसपोर्ट का उपयोग करने के लिए कैसे सेटअप कर सकते हैं:

```python
mcp.run(transport="streamable-http")
```

### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

इस .NET उदाहरण में, `ProcessFiles` टूल `Tool` एट्रिब्यूट के साथ सजाया गया है और प्रत्येक फ़ाइल को प्रोसेस करते समय क्लाइंट को तीन नोटिफिकेशन भेजता है। `ctx.Info()` मेथड का उपयोग सूचना संदेश भेजने के लिए किया जाता है।

अपने .NET MCP सर्वर में नोटिफिकेशन सक्षम करने के लिए, सुनिश्चित करें कि आप स्ट्रीमिंग ट्रांसपोर्ट का उपयोग कर रहे हैं:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### क्लाइंट-साइड: नोटिफिकेशन प्राप्त करना

क्लाइंट को एक मैसेज हैंडलर लागू करना चाहिए जो नोटिफिकेशन को प्रोसेस और प्रदर्शित करे जैसे ही वे आते हैं।

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

पिछले कोड में, `message_handler` फ़ंक्शन जांचता है कि क्या आने वाला संदेश नोटिफिकेशन है। यदि हाँ, तो यह नोटिफिकेशन को प्रिंट करता है; अन्यथा, इसे सामान्य सर्वर संदेश के रूप में प्रोसेस करता है। ध्यान दें कि `ClientSession` को `message_handler` के साथ इनिशियलाइज़ किया गया है ताकि आने वाली नोटिफिकेशन को संभाला जा सके।

### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

इस .NET उदाहरण में, `MessageHandler` फ़ंक्शन जांचता है कि क्या आने वाला संदेश नोटिफिकेशन है। यदि हाँ, तो यह नोटिफिकेशन को प्रिंट करता है; अन्यथा, इसे सामान्य सर्वर संदेश के रूप में प्रोसेस करता है। `ClientSession` को `ClientSessionOptions` के माध्यम से मैसेज हैंडलर के साथ इनिशियलाइज़ किया गया है।

नोटिफिकेशन सक्षम करने के लिए, सुनिश्चित करें कि आपका सर्वर स्ट्रीमिंग ट्रांसपोर्ट (जैसे `streamable-http`) का उपयोग करता है और आपका क्लाइंट नोटिफिकेशन प्रोसेस करने के लिए मैसेज हैंडलर लागू करता है।

## प्रगति नोटिफिकेशन और परिदृश्य

यह अनुभाग MCP में प्रगति नोटिफिकेशन की अवधारणा, उनके महत्व, और Streamable HTTP का उपयोग करके उन्हें कैसे लागू करें, समझाता है। साथ ही, आपकी समझ को मजबूत करने के लिए एक व्यावहारिक असाइनमेंट भी है।

प्रगति नोटिफिकेशन वे रियल-टाइम संदेश हैं जो लंबी अवधि के ऑपरेशनों के दौरान सर्वर से क्लाइंट को भेजे जाते हैं। पूरी प्रक्रिया समाप्त होने का इंतजार करने के बजाय, सर्वर क्लाइंट को वर्तमान स्थिति के बारे में अपडेट रखता है। इससे पारदर्शिता, उपयोगकर्ता अनुभव बेहतर होता है और डिबगिंग आसान होती है।

**उदाहरण:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### प्रगति नोटिफिकेशन क्यों उपयोग करें?

प्रगति नोटिफिकेशन कई कारणों से आवश्यक हैं:

- **बेहतर उपयोगकर्ता अनुभव:** उपयोगकर्ता काम की प्रगति को देखते हैं, केवल अंत में नहीं।
- **रियल-टाइम फीडबैक:** क्लाइंट प्रगति बार या लॉग दिखा सकते हैं, जिससे ऐप प्रतिक्रियाशील लगता है।
- **डिबगिंग और मॉनिटरिंग आसान:** डेवलपर्स और उपयोगकर्ता देख सकते हैं कि प्रक्रिया कहाँ धीमी या अटकी हुई है।

### प्रगति नोटिफिकेशन कैसे लागू करें

MCP में प्रगति नोटिफिकेशन लागू करने का तरीका:

- **सर्वर पर:** `ctx.info()` या `ctx.log()` का उपयोग करके प्रत्येक आइटम प्रोसेस होने पर नोटिफिकेशन भेजें। यह मुख्य परिणाम तैयार होने से पहले क्लाइंट को संदेश भेजता है।
- **क्लाइंट पर:** एक मैसेज हैंडलर लागू करें जो नोटिफिकेशन सुनता है और उन्हें प्रदर्शित करता है। यह हैंडलर नोटिफिकेशन और अंतिम परिणाम के बीच अंतर करता है।

**सर्वर उदाहरण:**

## Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

**क्लाइंट उदाहरण:**

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

## सुरक्षा विचार

जब MCP सर्वर HTTP-आधारित ट्रांसपोर्ट के साथ लागू किए जाते हैं, तो सुरक्षा एक अत्यंत महत्वपूर्ण चिंता बन
### क्यों अपग्रेड करें?

SSE से Streamable HTTP में अपग्रेड करने के दो मुख्य कारण हैं:

- Streamable HTTP, SSE की तुलना में बेहतर स्केलेबिलिटी, संगतता और अधिक समृद्ध नोटिफिकेशन सपोर्ट प्रदान करता है।
- यह नए MCP एप्लिकेशन के लिए अनुशंसित ट्रांसपोर्ट है।

### माइग्रेशन के चरण

अपने MCP एप्लिकेशन में SSE से Streamable HTTP में माइग्रेट करने का तरीका इस प्रकार है:

- **सर्वर कोड अपडेट करें** ताकि `mcp.run()` में `transport="streamable-http"` का उपयोग हो।
- **क्लाइंट कोड अपडेट करें** ताकि SSE क्लाइंट की जगह `streamablehttp_client` का उपयोग हो।
- **क्लाइंट में एक मैसेज हैंडलर लागू करें** जो नोटिफिकेशन को प्रोसेस करे।
- **मौजूदा टूल्स और वर्कफ़्लो के साथ संगतता के लिए परीक्षण करें**।

### संगतता बनाए रखना

माइग्रेशन प्रक्रिया के दौरान मौजूदा SSE क्लाइंट्स के साथ संगतता बनाए रखना बेहतर होता है। कुछ रणनीतियाँ इस प्रकार हैं:

- आप दोनों SSE और Streamable HTTP को अलग-अलग एंडपॉइंट्स पर चलाकर सपोर्ट कर सकते हैं।
- धीरे-धीरे क्लाइंट्स को नए ट्रांसपोर्ट पर माइग्रेट करें।

### चुनौतियाँ

माइग्रेशन के दौरान निम्नलिखित चुनौतियों का समाधान सुनिश्चित करें:

- सभी क्लाइंट्स को अपडेट करना
- नोटिफिकेशन डिलीवरी में अंतर को संभालना

## सुरक्षा संबंधी विचार

किसी भी सर्वर को लागू करते समय सुरक्षा सर्वोच्च प्राथमिकता होनी चाहिए, खासकर जब MCP में HTTP-आधारित ट्रांसपोर्ट जैसे Streamable HTTP का उपयोग किया जा रहा हो।

HTTP-आधारित ट्रांसपोर्ट के साथ MCP सर्वर लागू करते समय सुरक्षा एक महत्वपूर्ण चिंता होती है, जिसमें कई हमले के तरीकों और सुरक्षा उपायों पर ध्यान देना आवश्यक होता है।

### अवलोकन

HTTP के माध्यम से MCP सर्वर एक्सपोज़ करते समय सुरक्षा अत्यंत महत्वपूर्ण होती है। Streamable HTTP नए हमले के रास्ते खोलता है और सावधानीपूर्वक कॉन्फ़िगरेशन की मांग करता है।

यहाँ कुछ मुख्य सुरक्षा विचार दिए गए हैं:

- **Origin Header Validation**: DNS रिबाइंडिंग हमलों को रोकने के लिए हमेशा `Origin` हेडर को मान्य करें।
- **Localhost Binding**: स्थानीय विकास के लिए सर्वर को `localhost` पर बाइंड करें ताकि इसे सार्वजनिक इंटरनेट पर एक्सपोज़ न किया जाए।
- **Authentication**: प्रोडक्शन डिप्लॉयमेंट के लिए प्रमाणीकरण (जैसे API keys, OAuth) लागू करें।
- **CORS**: एक्सेस को सीमित करने के लिए Cross-Origin Resource Sharing (CORS) नीतियाँ कॉन्फ़िगर करें।
- **HTTPS**: ट्रैफ़िक को एन्क्रिप्ट करने के लिए प्रोडक्शन में HTTPS का उपयोग करें।

### सर्वोत्तम प्रथाएँ

अपने MCP स्ट्रीमिंग सर्वर में सुरक्षा लागू करते समय निम्न सर्वोत्तम प्रथाओं का पालन करें:

- बिना सत्यापन के आने वाले अनुरोधों पर कभी भरोसा न करें।
- सभी एक्सेस और त्रुटियों को लॉग और मॉनिटर करें।
- सुरक्षा कमजोरियों को ठीक करने के लिए नियमित रूप से डिपेंडेंसी अपडेट करें।

### चुनौतियाँ

MCP स्ट्रीमिंग सर्वर में सुरक्षा लागू करते समय आपको कुछ चुनौतियों का सामना करना पड़ेगा:

- विकास की सुविधा और सुरक्षा के बीच संतुलन बनाना
- विभिन्न क्लाइंट वातावरणों के साथ संगतता सुनिश्चित करना

### असाइनमेंट: अपना खुद का स्ट्रीमिंग MCP ऐप बनाएं

**परिदृश्य:**
एक MCP सर्वर और क्लाइंट बनाएं जहाँ सर्वर आइटमों (जैसे फाइलें या दस्तावेज़) की एक सूची को प्रोसेस करता है और प्रत्येक प्रोसेस किए गए आइटम के लिए नोटिफिकेशन भेजता है। क्लाइंट को प्रत्येक नोटिफिकेशन को जैसे ही वह आता है, दिखाना चाहिए।

**चरण:**

1. एक सर्वर टूल लागू करें जो सूची को प्रोसेस करे और प्रत्येक आइटम के लिए नोटिफिकेशन भेजे।
2. एक क्लाइंट लागू करें जिसमें नोटिफिकेशन को रियल टाइम में दिखाने के लिए मैसेज हैंडलर हो।
3. अपने इम्प्लीमेंटेशन का परीक्षण करें, सर्वर और क्लाइंट दोनों चलाएं, और नोटिफिकेशन देखें।

[Solution](./solution/README.md)

## आगे पढ़ें और आगे क्या करें?

MCP स्ट्रीमिंग के साथ अपनी यात्रा जारी रखने और अपने ज्ञान का विस्तार करने के लिए, यह सेक्शन अतिरिक्त संसाधन और अधिक उन्नत एप्लिकेशन बनाने के लिए सुझाए गए अगले कदम प्रदान करता है।

### आगे पढ़ें

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### आगे क्या करें?

- रियल-टाइम एनालिटिक्स, चैट, या सहयोगी संपादन के लिए स्ट्रीमिंग का उपयोग करने वाले अधिक उन्नत MCP टूल बनाना आज़माएं।
- लाइव UI अपडेट के लिए MCP स्ट्रीमिंग को फ्रंटेंड फ्रेमवर्क (React, Vue, आदि) के साथ इंटीग्रेट करना एक्सप्लोर करें।
- अगला: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। मूल दस्तावेज़ अपनी मूल भाषा में ही प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सलाह दी जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।