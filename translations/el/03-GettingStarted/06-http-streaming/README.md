<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-10T16:11:32+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "el"
}
-->
# HTTPS Streaming με το Model Context Protocol (MCP)

Αυτό το κεφάλαιο παρέχει έναν ολοκληρωμένο οδηγό για την υλοποίηση ασφαλούς, κλιμακούμενου και σε πραγματικό χρόνο streaming με το Model Context Protocol (MCP) χρησιμοποιώντας HTTPS. Καλύπτει το κίνητρο για streaming, τους διαθέσιμους μηχανισμούς μεταφοράς, πώς να υλοποιήσετε streamable HTTP στο MCP, βέλτιστες πρακτικές ασφάλειας, τη μετάβαση από SSE και πρακτικές οδηγίες για την κατασκευή των δικών σας streaming εφαρμογών MCP.

## Μηχανισμοί Μεταφοράς και Streaming στο MCP

Αυτή η ενότητα εξερευνά τους διαφορετικούς μηχανισμούς μεταφοράς που είναι διαθέσιμοι στο MCP και τον ρόλο τους στην ενεργοποίηση δυνατοτήτων streaming για επικοινωνία σε πραγματικό χρόνο μεταξύ πελατών και διακομιστών.

### Τι είναι ένας Μηχανισμός Μεταφοράς;

Ένας μηχανισμός μεταφοράς ορίζει πώς ανταλλάσσονται τα δεδομένα μεταξύ πελάτη και διακομιστή. Το MCP υποστηρίζει πολλούς τύπους μεταφοράς για να ταιριάζει σε διαφορετικά περιβάλλοντα και απαιτήσεις:

- **stdio**: Τυπική είσοδος/έξοδος, κατάλληλη για τοπικά εργαλεία και εργαλεία γραμμής εντολών. Απλή αλλά όχι κατάλληλη για web ή cloud.
- **SSE (Server-Sent Events)**: Επιτρέπει στους διακομιστές να στέλνουν ενημερώσεις σε πραγματικό χρόνο στους πελάτες μέσω HTTP. Καλή για web UI, αλλά περιορισμένη σε κλιμακωσιμότητα και ευελιξία.
- **Streamable HTTP**: Σύγχρονος μηχανισμός μεταφοράς βασισμένος σε HTTP για streaming, υποστηρίζει ειδοποιήσεις και καλύτερη κλιμακωσιμότητα. Συνιστάται για τις περισσότερες παραγωγικές και cloud περιπτώσεις.

### Πίνακας Σύγκρισης

Δείτε τον παρακάτω πίνακα σύγκρισης για να κατανοήσετε τις διαφορές μεταξύ αυτών των μηχανισμών μεταφοράς:

| Μεταφορά          | Ενημερώσεις σε Πραγματικό Χρόνο | Streaming | Κλιμακωσιμότητα | Περίπτωση Χρήσης          |
|-------------------|---------------------------------|-----------|-----------------|--------------------------|
| stdio             | Όχι                             | Όχι       | Χαμηλή          | Τοπικά εργαλεία CLI      |
| SSE               | Ναι                             | Ναι       | Μέτρια          | Web, ενημερώσεις σε πραγματικό χρόνο |
| Streamable HTTP   | Ναι                             | Ναι       | Υψηλή           | Cloud, πολλαπλοί πελάτες |

> **Tip:** Η επιλογή του κατάλληλου μηχανισμού μεταφοράς επηρεάζει την απόδοση, την κλιμακωσιμότητα και την εμπειρία χρήστη. Το **Streamable HTTP** συνιστάται για σύγχρονες, κλιμακούμενες και cloud-έτοιμες εφαρμογές.

Σημειώστε τους μηχανισμούς stdio και SSE που παρουσιάστηκαν στα προηγούμενα κεφάλαια και πώς το streamable HTTP είναι ο μηχανισμός που καλύπτεται σε αυτό το κεφάλαιο.

## Streaming: Έννοιες και Κίνητρα

Η κατανόηση των βασικών εννοιών και κινήτρων πίσω από το streaming είναι απαραίτητη για την υλοποίηση αποτελεσματικών συστημάτων επικοινωνίας σε πραγματικό χρόνο.

**Το streaming** είναι μια τεχνική στον προγραμματισμό δικτύων που επιτρέπει την αποστολή και λήψη δεδομένων σε μικρά, διαχειρίσιμα κομμάτια ή ως ακολουθία γεγονότων, αντί να περιμένουμε ολόκληρη την απάντηση να είναι έτοιμη. Αυτό είναι ιδιαίτερα χρήσιμο για:

- Μεγάλα αρχεία ή σύνολα δεδομένων.
- Ενημερώσεις σε πραγματικό χρόνο (π.χ. chat, μπάρες προόδου).
- Μακροχρόνιους υπολογισμούς όπου θέλετε να κρατάτε τον χρήστη ενήμερο.

Ακολουθούν τα βασικά που πρέπει να γνωρίζετε για το streaming σε υψηλό επίπεδο:

- Τα δεδομένα παραδίδονται σταδιακά, όχι όλα μαζί.
- Ο πελάτης μπορεί να επεξεργαστεί τα δεδομένα καθώς φτάνουν.
- Μειώνει την αντιληπτή καθυστέρηση και βελτιώνει την εμπειρία χρήστη.

### Γιατί να χρησιμοποιήσετε streaming;

Οι λόγοι για τη χρήση του streaming είναι οι εξής:

- Οι χρήστες λαμβάνουν άμεση ανατροφοδότηση, όχι μόνο στο τέλος.
- Επιτρέπει εφαρμογές σε πραγματικό χρόνο και ευέλικτα UI.
- Αποτελεσματικότερη χρήση πόρων δικτύου και υπολογιστικής ισχύος.

### Απλό Παράδειγμα: HTTP Streaming Server & Client

Ακολουθεί ένα απλό παράδειγμα για το πώς μπορεί να υλοποιηθεί το streaming:

<details>
<summary>Python</summary>

**Διακομιστής (Python, με FastAPI και StreamingResponse):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**Πελάτης (Python, με requests):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

Αυτό το παράδειγμα δείχνει έναν διακομιστή που στέλνει μια σειρά μηνυμάτων στον πελάτη καθώς γίνονται διαθέσιμα, αντί να περιμένει να είναι έτοιμα όλα τα μηνύματα.

**Πώς λειτουργεί:**
- Ο διακομιστής αποδίδει κάθε μήνυμα μόλις είναι έτοιμο.
- Ο πελάτης λαμβάνει και εκτυπώνει κάθε κομμάτι μόλις φτάσει.

**Απαιτήσεις:**
- Ο διακομιστής πρέπει να χρησιμοποιεί streaming response (π.χ. `StreamingResponse` στο FastAPI).
- Ο πελάτης πρέπει να επεξεργάζεται την απάντηση ως ροή (`stream=True` στα requests).
- Το Content-Type είναι συνήθως `text/event-stream` ή `application/octet-stream`.

</details>

<details>
<summary>Java</summary>

**Διακομιστής (Java, με Spring Boot και Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Πελάτης (Java, με Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Σημειώσεις Υλοποίησης Java:**
- Χρησιμοποιεί το reactive stack του Spring Boot με `Flux` για streaming
- Το `ServerSentEvent` παρέχει δομημένο streaming γεγονότων με τύπους γεγονότων
- Το `WebClient` με `bodyToFlux()` επιτρέπει την κατανάλωση reactive streaming
- Το `delayElements()` προσομοιώνει χρόνο επεξεργασίας μεταξύ γεγονότων
- Τα γεγονότα μπορούν να έχουν τύπους (`info`, `result`) για καλύτερη διαχείριση από τον πελάτη

</details>

### Σύγκριση: Κλασικό Streaming vs MCP Streaming

Οι διαφορές μεταξύ του πώς λειτουργεί το streaming με τον "κλασικό" τρόπο και πώς λειτουργεί στο MCP μπορούν να απεικονιστούν ως εξής:

| Χαρακτηριστικό         | Κλασικό HTTP Streaming          | MCP Streaming (Ειδοποιήσεις)       |
|-----------------------|--------------------------------|-----------------------------------|
| Κύρια απάντηση        | Τμηματοποιημένη (chunked)       | Μοναδική, στο τέλος               |
| Ενημερώσεις προόδου   | Αποστέλλονται ως κομμάτια δεδομένων | Αποστέλλονται ως ειδοποιήσεις     |
| Απαιτήσεις πελάτη     | Πρέπει να επεξεργάζεται τη ροή  | Πρέπει να υλοποιεί χειριστή μηνυμάτων |
| Περίπτωση χρήσης      | Μεγάλα αρχεία, ροές token AI   | Πρόοδος, logs, ανατροφοδότηση σε πραγματικό χρόνο |

### Κύριες Διαφορές

Επιπλέον, μερικές βασικές διαφορές:

- **Πρότυπο Επικοινωνίας:**
   - Κλασικό HTTP streaming: Χρησιμοποιεί απλή κωδικοποίηση μεταφοράς σε κομμάτια για αποστολή δεδομένων
   - MCP streaming: Χρησιμοποιεί δομημένο σύστημα ειδοποιήσεων με πρωτόκολλο JSON-RPC

- **Μορφή Μηνύματος:**
   - Κλασικό HTTP: Απλά κομμάτια κειμένου με αλλαγές γραμμής
   - MCP: Δομημένα αντικείμενα LoggingMessageNotification με μεταδεδομένα

- **Υλοποίηση Πελάτη:**
   - Κλασικό HTTP: Απλός πελάτης που επεξεργάζεται streaming απαντήσεις
   - MCP: Πιο σύνθετος πελάτης με χειριστή μηνυμάτων για επεξεργασία διαφορετικών τύπων μηνυμάτων

- **Ενημερώσεις Προόδου:**
   - Κλασικό HTTP: Η πρόοδος είναι μέρος της κύριας ροής απάντησης
   - MCP: Η πρόοδος αποστέλλεται μέσω ξεχωριστών μηνυμάτων ειδοποίησης ενώ η κύρια απάντηση έρχεται στο τέλος

### Συστάσεις

Υπάρχουν ορισμένα που προτείνουμε όταν πρόκειται για την επιλογή μεταξύ υλοποίησης κλασικού streaming (ως endpoint που δείξαμε παραπάνω με χρήση `/stream`) ή streaming μέσω MCP.

- **Για απλές ανάγκες streaming:** Το κλασικό HTTP streaming είναι πιο απλό στην υλοποίηση και επαρκεί για βασικές ανάγκες streaming.

- **Για σύνθετες, διαδραστικές εφαρμογές:** Το MCP streaming παρέχει πιο δομημένη προσέγγιση με πλουσιότερα μεταδεδομένα και διαχωρισμό μεταξύ ειδοποιήσεων και τελικών αποτελεσμάτων.

- **Για εφαρμογές AI:** Το σύστημα ειδοποιήσεων του MCP είναι ιδιαίτερα χρήσιμο για μακροχρόνιες εργασίες AI όπου θέλετε να κρατάτε τους χρήστες ενήμερους για την πρόοδο.

## Streaming στο MCP

Λοιπόν, έχετε δει κάποιες συστάσεις και συγκρίσεις μέχρι τώρα σχετικά με τη διαφορά μεταξύ κλασικού streaming και streaming στο MCP. Ας δούμε αναλυτικά πώς ακριβώς μπορείτε να αξιοποιήσετε το streaming στο MCP.

Η κατανόηση του πώς λειτουργεί το streaming μέσα στο πλαίσιο του MCP είναι απαραίτητη για την κατασκευή ευέλικτων εφαρμογών που παρέχουν ανατροφοδότηση σε πραγματικό χρόνο στους χρήστες κατά τη διάρκεια μακροχρόνιων λειτουργιών.

Στο MCP, το streaming δεν αφορά την αποστολή της κύριας απάντησης σε κομμάτια, αλλά την αποστολή **ειδοποιήσεων** στον πελάτη ενώ ένα εργαλείο επεξεργάζεται ένα αίτημα. Αυτές οι ειδοποιήσεις μπορεί να περιλαμβάνουν ενημερώσεις προόδου, logs ή άλλα γεγονότα.

### Πώς λειτουργεί

Το κύριο αποτέλεσμα αποστέλλεται ακόμα ως μία μοναδική απάντηση. Ωστόσο, οι ειδοποιήσεις μπορούν να αποστέλλονται ως ξεχωριστά μηνύματα κατά τη διάρκεια της επεξεργασίας και έτσι να ενημερώνουν τον πελάτη σε πραγματικό χρόνο. Ο πελάτης πρέπει να μπορεί να χειρίζεται και να εμφανίζει αυτές τις ειδοποιήσεις.

## Τι είναι μια Ειδοποίηση;

Είπαμε "Ειδοποίηση", τι σημαίνει αυτό στο πλαίσιο του MCP;

Μια ειδοποίηση είναι ένα μήνυμα που αποστέλλεται από τον διακομιστή στον πελάτη για να ενημερώσει σχετικά με την πρόοδο, την κατάσταση ή άλλα γεγονότα κατά τη διάρκεια μιας μακροχρόνιας λειτουργίας. Οι ειδοποιήσεις βελτιώνουν τη διαφάνεια και την εμπειρία χρήστη.

Για παράδειγμα, ένας πελάτης πρέπει να στείλει μια ειδοποίηση μόλις ολοκληρωθεί η αρχική χειραψία με τον διακομιστή.

Μια ειδοποίηση μοιάζει ως εξής σε μορφή JSON:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

Οι ειδοποιήσεις ανήκουν σε ένα θέμα στο MCP που αναφέρεται ως ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging).

Για να λειτουργήσει το logging, ο διακομιστής πρέπει να το ενεργοποιήσει ως λειτουργία/δυνατότητα ως εξής:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> Ανάλογα με το SDK που χρησιμοποιείται, το logging μπορεί να είναι ενεργοποιημένο από προεπιλογή ή μπορεί να χρειαστεί να το ενεργοποιήσετε ρητά στη διαμόρφωση του διακομιστή σας.

Υπάρχουν διαφορετικοί τύποι ειδοποιήσεων:

| Επίπεδο    | Περιγραφή                      | Παράδειγμα Χρήσης             |
|------------|-------------------------------|------------------------------|
| debug      | Λεπτομερείς πληροφορίες αποσφαλμάτωσης | Σημεία εισόδου/εξόδου συναρτήσεων |
| info       | Γενικά πληροφοριακά μηνύματα  | Ενημερώσεις προόδου λειτουργίας |
| notice     | Κανονικά αλλά σημαντικά γεγονότα | Αλλαγές ρυθμίσεων            |
| warning    | Συνθήκες προειδοποίησης       | Χρήση αποσυρμένης λειτουργίας |
| error      | Συνθήκες σφάλματος            | Αποτυχίες λειτουργίας        |
| critical   | Κρίσιμες συνθήκες             | Αποτυχίες συστημικών στοιχείων |
| alert      | Απαιτείται άμεση ενέργεια     | Ανίχνευση καταστροφής δεδομένων |
| emergency  | Το σύστημα είναι μη λειτουργικό | Πλήρης αποτυχία συστήματος   |

## Υλοποίηση Ειδοποιήσεων στο MCP

Για να υλοποιήσετε ειδοποιήσεις στο MCP, πρέπει να ρυθμίσετε τόσο την πλευρά του διακομιστή όσο και του πελάτη ώστε να χειρίζονται ενημερώσεις σε πραγματικό χρόνο. Αυτό επιτρέπει στην εφαρμογή σας να παρέχει άμεση ανατροφοδότηση στους χρήστες κατά τη διάρκεια μακροχρόνιων λειτουργιών.

### Πλευρά Διακομιστή: Αποστολή Ειδοποιήσεων

Ας ξεκινήσουμε με την πλευρά του διακομιστή. Στο MCP, ορίζετε εργαλεία που μπορούν να στέλνουν ειδοποιήσεις ενώ επεξεργάζονται αιτήματα. Ο διακομιστής χρησιμοποιεί το αντικείμενο context (συνήθως `ctx`) για να στέλνει μηνύματα στον πελάτη.

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

Στο προηγούμενο παράδειγμα, το εργαλείο `process_files` στέλνει τρεις ειδοποιήσεις στον πελάτη καθώς επεξεργάζεται κάθε αρχείο. Η μέθοδος `ctx.info()` χρησιμοποιείται για την αποστολή πληροφοριακών μηνυμάτων.

</details>

Επιπλέον, για να ενεργοποιήσετε τις ειδοποιήσεις, βεβαιωθείτε ότι ο διακομιστής σας χρησιμοποιεί streaming transport (όπως `streamable-http`) και ο πελάτης υλοποιεί χειριστή μηνυμάτων για την επεξεργασία των ειδοποιήσεων. Δείτε πώς μπορείτε να ρυθμίσετε τον διακομιστή να χρησιμοποιεί το `streamable-http` transport:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

Σε αυτό το παράδειγμα .NET, το εργαλείο `ProcessFiles` είναι διακοσμημένο με το χαρακτηριστικό `Tool` και στέλνει τρεις ειδοποιήσεις στον πελάτη καθώς επεξεργάζεται κάθε αρχείο. Η μέθοδος `ctx.Info()` χρησιμοποιείται για την αποστολή πληροφοριακών μηνυμάτων.

Για να ενεργοποιήσετε τις ειδοποιήσεις στον MCP διακομιστή σας .NET, βεβαιωθείτε ότι χρησιμοποιείτε streaming transport:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### Πλευρά Πελάτη: Λήψη Ειδοποιήσεων

Ο πελάτης πρέπει να υλοποιήσει έναν χειριστή μηνυμάτων για να επεξεργάζεται και να εμφανίζει τις ειδοποιήσεις καθώς φτάνουν.

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

Στον παραπάνω κώδικα, η συνάρτηση `message_handler` ελέγχει αν το εισερχόμενο μήνυμα είναι ειδοποίηση. Αν ναι, εκτυπώνει την ειδοποίηση, αλλιώς το επεξεργάζεται ως κανονικό μήνυμα διακομιστή. Σημειώστε επίσης πώς το `ClientSession` αρχικοποιείται με τον `message_handler` για να χειρίζεται τις εισερχόμενες ειδοποιήσεις.

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

Σε αυτό το παράδειγμα .NET, η συνάρτηση `MessageHandler` ελέγχει αν το εισερχόμενο μήνυμα είναι ειδοποίηση. Αν ναι, εκτυπώνει την ειδοποίηση, αλλιώς το επεξεργάζεται ως κα

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**Παράδειγμα Πελάτη:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## Θέματα Ασφαλείας

Κατά την υλοποίηση MCP servers με μεταφορές βασισμένες σε HTTP, η ασφάλεια γίνεται πρωταρχικό ζήτημα που απαιτεί προσεκτική προσοχή σε πολλαπλές επιθέσεις και μηχανισμούς προστασίας.

### Επισκόπηση

Η ασφάλεια είναι κρίσιμη όταν εκθέτουμε MCP servers μέσω HTTP. Το Streamable HTTP εισάγει νέες επιφάνειες επίθεσης και απαιτεί προσεκτική ρύθμιση.

### Βασικά Σημεία
- **Επαλήθευση της κεφαλίδας Origin**: Πάντα να επαληθεύετε την κεφαλίδα `Origin` για να αποτρέψετε επιθέσεις DNS rebinding.
- **Δέσμευση σε localhost**: Για τοπική ανάπτυξη, δέστε τους servers στο `localhost` για να αποφύγετε την έκθεσή τους στο δημόσιο διαδίκτυο.
- **Πιστοποίηση**: Υλοποιήστε πιστοποίηση (π.χ. API keys, OAuth) για παραγωγικές εγκαταστάσεις.
- **CORS**: Ρυθμίστε πολιτικές Cross-Origin Resource Sharing (CORS) για περιορισμό πρόσβασης.
- **HTTPS**: Χρησιμοποιήστε HTTPS στην παραγωγή για κρυπτογράφηση της κίνησης.

### Καλές Πρακτικές
- Μην εμπιστεύεστε ποτέ αιτήματα χωρίς επαλήθευση.
- Καταγράψτε και παρακολουθήστε όλες τις προσβάσεις και τα σφάλματα.
- Ενημερώνετε τακτικά τις εξαρτήσεις για να διορθώσετε ευπάθειες ασφαλείας.

### Προκλήσεις
- Ισορροπία μεταξύ ασφάλειας και ευκολίας ανάπτυξης
- Εξασφάλιση συμβατότητας με διάφορα περιβάλλοντα πελατών


## Αναβάθμιση από SSE σε Streamable HTTP

Για εφαρμογές που χρησιμοποιούν Server-Sent Events (SSE), η μετάβαση σε Streamable HTTP προσφέρει βελτιωμένες δυνατότητες και καλύτερη μακροπρόθεσμη βιωσιμότητα για τις υλοποιήσεις MCP.

### Γιατί να Αναβαθμίσετε;

Υπάρχουν δύο βασικοί λόγοι για να αναβαθμίσετε από SSE σε Streamable HTTP:

- Το Streamable HTTP προσφέρει καλύτερη κλιμάκωση, συμβατότητα και πλουσιότερη υποστήριξη ειδοποιήσεων σε σχέση με το SSE.
- Είναι η προτεινόμενη μεταφορά για νέες εφαρμογές MCP.

### Βήματα Μετάβασης

Ακολουθεί πώς μπορείτε να μεταβείτε από SSE σε Streamable HTTP στις εφαρμογές MCP σας:

- **Ενημερώστε τον κώδικα του server** για να χρησιμοποιεί `transport="streamable-http"` στο `mcp.run()`.
- **Ενημερώστε τον κώδικα του πελάτη** για να χρησιμοποιεί `streamablehttp_client` αντί για τον SSE client.
- **Υλοποιήστε έναν χειριστή μηνυμάτων** στον πελάτη για την επεξεργασία των ειδοποιήσεων.
- **Δοκιμάστε τη συμβατότητα** με τα υπάρχοντα εργαλεία και ροές εργασίας.

### Διατήρηση Συμβατότητας

Συνιστάται να διατηρήσετε τη συμβατότητα με τους υπάρχοντες SSE clients κατά τη διαδικασία μετάβασης. Μερικές στρατηγικές:

- Μπορείτε να υποστηρίξετε και τα δύο, SSE και Streamable HTTP, τρέχοντας και τις δύο μεταφορές σε διαφορετικά endpoints.
- Μεταβείτε σταδιακά τους πελάτες στη νέα μεταφορά.

### Προκλήσεις

Πρέπει να αντιμετωπίσετε τις εξής προκλήσεις κατά τη μετάβαση:

- Ενημέρωση όλων των πελατών
- Διαχείριση διαφορών στην παράδοση των ειδοποιήσεων

## Θέματα Ασφαλείας

Η ασφάλεια πρέπει να είναι κορυφαία προτεραιότητα κατά την υλοποίηση οποιουδήποτε server, ειδικά όταν χρησιμοποιούνται μεταφορές βασισμένες σε HTTP όπως το Streamable HTTP στο MCP.

Κατά την υλοποίηση MCP servers με μεταφορές βασισμένες σε HTTP, η ασφάλεια γίνεται πρωταρχικό ζήτημα που απαιτεί προσεκτική προσοχή σε πολλαπλές επιθέσεις και μηχανισμούς προστασίας.

### Επισκόπηση

Η ασφάλεια είναι κρίσιμη όταν εκθέτουμε MCP servers μέσω HTTP. Το Streamable HTTP εισάγει νέες επιφάνειες επίθεσης και απαιτεί προσεκτική ρύθμιση.

Ακολουθούν μερικά βασικά θέματα ασφαλείας:

- **Επαλήθευση της κεφαλίδας Origin**: Πάντα να επαληθεύετε την κεφαλίδα `Origin` για να αποτρέψετε επιθέσεις DNS rebinding.
- **Δέσμευση σε localhost**: Για τοπική ανάπτυξη, δέστε τους servers στο `localhost` για να αποφύγετε την έκθεσή τους στο δημόσιο διαδίκτυο.
- **Πιστοποίηση**: Υλοποιήστε πιστοποίηση (π.χ. API keys, OAuth) για παραγωγικές εγκαταστάσεις.
- **CORS**: Ρυθμίστε πολιτικές Cross-Origin Resource Sharing (CORS) για περιορισμό πρόσβασης.
- **HTTPS**: Χρησιμοποιήστε HTTPS στην παραγωγή για κρυπτογράφηση της κίνησης.

### Καλές Πρακτικές

Επιπλέον, ακολουθήστε τις παρακάτω καλές πρακτικές κατά την υλοποίηση ασφάλειας στον MCP streaming server σας:

- Μην εμπιστεύεστε ποτέ αιτήματα χωρίς επαλήθευση.
- Καταγράψτε και παρακολουθήστε όλες τις προσβάσεις και τα σφάλματα.
- Ενημερώνετε τακτικά τις εξαρτήσεις για να διορθώσετε ευπάθειες ασφαλείας.

### Προκλήσεις

Θα αντιμετωπίσετε κάποιες προκλήσεις κατά την υλοποίηση ασφάλειας σε MCP streaming servers:

- Ισορροπία μεταξύ ασφάλειας και ευκολίας ανάπτυξης
- Εξασφάλιση συμβατότητας με διάφορα περιβάλλοντα πελατών

### Άσκηση: Δημιουργήστε τη δική σας Streaming MCP Εφαρμογή

**Σενάριο:**
Δημιουργήστε έναν MCP server και πελάτη όπου ο server επεξεργάζεται μια λίστα αντικειμένων (π.χ. αρχεία ή έγγραφα) και στέλνει μια ειδοποίηση για κάθε επεξεργασμένο αντικείμενο. Ο πελάτης θα εμφανίζει κάθε ειδοποίηση καθώς αυτή φτάνει.

**Βήματα:**

1. Υλοποιήστε ένα εργαλείο server που επεξεργάζεται μια λίστα και στέλνει ειδοποιήσεις για κάθε αντικείμενο.
2. Υλοποιήστε έναν πελάτη με χειριστή μηνυμάτων για να εμφανίζει τις ειδοποιήσεις σε πραγματικό χρόνο.
3. Δοκιμάστε την υλοποίησή σας τρέχοντας και τον server και τον πελάτη, και παρατηρήστε τις ειδοποιήσεις.

[Solution](./solution/README.md)

## Επιπλέον Ανάγνωση & Τι Ακολουθεί;

Για να συνεχίσετε το ταξίδι σας με το MCP streaming και να επεκτείνετε τις γνώσεις σας, αυτή η ενότητα παρέχει επιπλέον πόρους και προτεινόμενα επόμενα βήματα για την κατασκευή πιο προηγμένων εφαρμογών.

### Επιπλέον Ανάγνωση

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Τι Ακολουθεί;

- Δοκιμάστε να δημιουργήσετε πιο προηγμένα εργαλεία MCP που χρησιμοποιούν streaming για ανάλυση σε πραγματικό χρόνο, chat ή συνεργατική επεξεργασία.
- Εξερευνήστε την ενσωμάτωση του MCP streaming με frontend frameworks (React, Vue, κ.ά.) για ζωντανές ενημερώσεις UI.
- Επόμενο: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

**Αποποίηση ευθυνών**:  
Αυτό το έγγραφο έχει μεταφραστεί χρησιμοποιώντας την υπηρεσία αυτόματης μετάφρασης AI [Co-op Translator](https://github.com/Azure/co-op-translator). Παρόλο που επιδιώκουμε την ακρίβεια, παρακαλούμε να έχετε υπόψη ότι οι αυτόματες μεταφράσεις ενδέχεται να περιέχουν λάθη ή ανακρίβειες. Το πρωτότυπο έγγραφο στη γλώσσα του θεωρείται η αυθεντική πηγή. Για κρίσιμες πληροφορίες, συνιστάται επαγγελματική ανθρώπινη μετάφραση. Δεν φέρουμε ευθύνη για τυχόν παρεξηγήσεις ή λανθασμένες ερμηνείες που προκύπτουν από τη χρήση αυτής της μετάφρασης.