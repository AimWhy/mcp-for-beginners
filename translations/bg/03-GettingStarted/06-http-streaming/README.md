<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "fbe345ba124324648cfb3aef9a9120b8",
  "translation_date": "2025-07-13T20:52:57+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "bg"
}
-->
# HTTPS стрийминг с Model Context Protocol (MCP)

Тази глава предоставя изчерпателно ръководство за реализиране на сигурен, мащабируем и в реално време стрийминг с Model Context Protocol (MCP) чрез HTTPS. Обхваща мотивацията за стрийминг, наличните транспортни механизми, как да се имплементира стрийминг HTTP в MCP, най-добри практики за сигурност, миграция от SSE и практически насоки за изграждане на собствени стрийминг MCP приложения.

## Транспортни механизми и стрийминг в MCP

Този раздел разглежда различните транспортни механизми, налични в MCP, и тяхната роля за осигуряване на стрийминг възможности за комуникация в реално време между клиенти и сървъри.

### Какво е транспортен механизъм?

Транспортният механизъм определя как се обменят данни между клиента и сървъра. MCP поддържа няколко типа транспорт, за да отговори на различни среди и изисквания:

- **stdio**: Стандартен вход/изход, подходящ за локални и CLI базирани инструменти. Прост, но не е подходящ за уеб или облак.
- **SSE (Server-Sent Events)**: Позволява на сървърите да изпращат актуализации в реално време към клиентите през HTTP. Подходящ за уеб интерфейси, но с ограничена мащабируемост и гъвкавост.
- **Streamable HTTP**: Модерен HTTP-базиран стрийминг транспорт, поддържащ нотификации и по-добра мащабируемост. Препоръчва се за повечето производствени и облачни сценарии.

### Таблица за сравнение

Вижте таблицата по-долу, за да разберете разликите между тези транспортни механизми:

| Транспорт         | Актуализации в реално време | Стрийминг | Мащабируемост | Приложение               |
|-------------------|-----------------------------|-----------|---------------|-------------------------|
| stdio             | Не                          | Не        | Ниска         | Локални CLI инструменти |
| SSE               | Да                          | Да        | Средна        | Уеб, актуализации в реално време |
| Streamable HTTP   | Да                          | Да        | Висока        | Облак, мулти-клиент     |

> [!TIP] Изборът на правилния транспорт влияе върху производителността, мащабируемостта и потребителското изживяване. **Streamable HTTP** е препоръчителен за модерни, мащабируеми и облачно готови приложения.

Обърнете внимание на транспортите stdio и SSE, които бяха показани в предишните глави, и как Streamable HTTP е транспортът, разгледан в тази глава.

## Стрийминг: Концепции и мотивация

Разбирането на основните концепции и мотивации зад стрийминга е ключово за реализиране на ефективни системи за комуникация в реално време.

**Стрийминг** е техника в мрежовото програмиране, която позволява данните да се изпращат и получават на малки, управляеми части или като поредица от събития, вместо да се чака цял отговор да бъде готов. Това е особено полезно за:

- Големи файлове или набори от данни.
- Актуализации в реално време (например чат, ленти за напредък).
- Дълготрайни изчисления, при които искате да държите потребителя информиран.

Ето какво трябва да знаете за стрийминга на високо ниво:

- Данните се доставят постепенно, не наведнъж.
- Клиентът може да обработва данните веднага щом пристигнат.
- Намалява възприеманото забавяне и подобрява потребителското изживяване.

### Защо да използваме стрийминг?

Причините за използване на стрийминг са следните:

- Потребителите получават обратна връзка веднага, а не само накрая.
- Позволява реалновремеви приложения и отзивчиви интерфейси.
- По-ефективно използване на мрежови и изчислителни ресурси.

### Прост пример: HTTP стрийминг сървър и клиент

Ето един прост пример как може да се реализира стрийминг:

<details>
<summary>Python</summary>

**Сървър (Python, използвайки FastAPI и StreamingResponse):**
<details>
<summary>Python</summary>

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

</details>

**Клиент (Python, използвайки requests):**
<details>
<summary>Python</summary>

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

</details>

Този пример показва сървър, който изпраща серия от съобщения към клиента веднага щом са налични, вместо да чака всички съобщения да са готови.

**Как работи:**
- Сървърът изпраща всяко съобщение веднага щом е готово.
- Клиентът получава и отпечатва всяка част веднага щом пристигне.

**Изисквания:**
- Сървърът трябва да използва стрийминг отговор (например `StreamingResponse` във FastAPI).
- Клиентът трябва да обработва отговора като поток (`stream=True` в requests).
- Content-Type обикновено е `text/event-stream` или `application/octet-stream`.

</details>

<details>
<summary>Java</summary>

**Сървър (Java, използвайки Spring Boot и Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Клиент (Java, използвайки Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Бележки за Java имплементацията:**
- Използва реактивния стек на Spring Boot с `Flux` за стрийминг
- `ServerSentEvent` предоставя структурирано събитийно стриймване с типове събития
- `WebClient` с `bodyToFlux()` позволява реактивно консумиране на стрийма
- `delayElements()` симулира време за обработка между събитията
- Събитията могат да имат типове (`info`, `result`) за по-добра обработка от клиента

</details>

### Сравнение: Класически стрийминг срещу MCP стрийминг

Разликите между класическия начин на стрийминг и този в MCP могат да се илюстрират така:

| Характеристика        | Класически HTTP стрийминг       | MCP стрийминг (нотификации)       |
|-----------------------|--------------------------------|----------------------------------|
| Основен отговор       | На части (chunked)              | Един, в края                     |
| Актуализации за напредък | Изпращат се като части от данни | Изпращат се като нотификации     |
| Изисквания към клиента | Трябва да обработва потока      | Трябва да има обработчик на съобщения |
| Приложение            | Големи файлове, AI токен стриймове | Напредък, логове, обратна връзка в реално време |

### Основни наблюдавани разлики

Освен това, ето някои ключови разлики:

- **Комуникационен модел:**
   - Класически HTTP стрийминг: Използва прост chunked transfer encoding за изпращане на данни на части
   - MCP стрийминг: Използва структурирана система за нотификации с JSON-RPC протокол

- **Формат на съобщенията:**
   - Класически HTTP: Обикновен текст с нови редове
   - MCP: Структурирани обекти LoggingMessageNotification с метаданни

- **Имплементация на клиента:**
   - Класически HTTP: Прост клиент, който обработва стрийминг отговори
   - MCP: По-сложен клиент с обработчик на съобщения за различни типове съобщения

- **Актуализации за напредък:**
   - Класически HTTP: Напредъкът е част от основния поток
   - MCP: Напредъкът се изпраща чрез отделни нотификации, докато основният отговор идва накрая

### Препоръки

Има някои препоръки при избора между класически стрийминг (като endpoint-а, показан по-горе с `/stream`) и стрийминг чрез MCP.

- **За прости нужди от стрийминг:** Класическият HTTP стрийминг е по-лесен за имплементиране и достатъчен за базови нужди.

- **За сложни, интерактивни приложения:** MCP стрийминг предлага по-структуриран подход с по-богати метаданни и разделение между нотификации и крайни резултати.

- **За AI приложения:** Системата за нотификации на MCP е особено полезна за дълготрайни AI задачи, където искате да държите потребителите информирани за напредъка.

## Стрийминг в MCP

Добре, вече видяхте някои препоръки и сравнения за разликите между класическия стрийминг и стрийминга в MCP. Нека разгледаме подробно как точно можете да използвате стрийминг в MCP.

Разбирането как работи стриймингът в рамките на MCP е ключово за изграждане на отзивчиви приложения, които предоставят обратна връзка в реално време по време на дълготрайни операции.

В MCP стриймингът не означава изпращане на основния отговор на части, а изпращане на **нотификации** към клиента, докато инструментът обработва заявка. Тези нотификации могат да включват актуализации за напредък, логове или други събития.

### Как работи

Основният резултат все още се изпраща като един отговор. Въпреки това, нотификациите могат да се изпращат като отделни съобщения по време на обработката и така да актуализират клиента в реално време. Клиентът трябва да може да обработва и показва тези нотификации.

## Какво е нотификация?

Казахме "нотификация", какво означава това в контекста на MCP?

Нотификацията е съобщение, изпратено от сървъра към клиента, за да информира за напредък, статус или други събития по време на дълготрайна операция. Нотификациите подобряват прозрачността и потребителското изживяване.

Например, клиентът трябва да изпрати нотификация веднага след като първоначалното свързване със сървъра е осъществено.

Нотификацията изглежда така като JSON съобщение:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

Нотификациите принадлежат към тема в MCP, наречена ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging).

За да работи логването, сървърът трябва да го активира като функция/възможност, както следва:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> В зависимост от използвания SDK, логването може да е активирано по подразбиране или може да се наложи да го включите изрично в конфигурацията на сървъра.

Има различни типове нотификации:

| Ниво      | Описание                      | Примерна употреба             |
|-----------|-------------------------------|------------------------------|
| debug     | Подробна отладъчна информация | Вход/изход на функции         |
| info      | Общи информационни съобщения  | Актуализации за напредък     |
| notice    | Нормални, но значими събития  | Промени в конфигурацията     |
| warning   | Предупредителни състояния     | Използване на остаряла функция|
| error     | Грешки                       | Провали в операции           |
| critical  | Критични състояния            | Повреди в системни компоненти|
| alert     | Необходимо е незабавно действие | Открита корупция на данни   |
| emergency | Системата е неизползваема     | Пълна системна повреда       |

## Имплементиране на нотификации в MCP

За да имплементирате нотификации в MCP, трябва да настроите както сървърната, така и клиентската страна да обработват актуализации в реално време. Това позволява на вашето приложение да предоставя незабавна обратна връзка на потребителите по време на дълготрайни операции.

### От страна на сървъра: Изпращане на нотификации

Нека започнем със сървърната страна. В MCP дефинирате инструменти, които могат да изпращат нотификации по време на обработка на заявки. Сървърът използва контекстния обект (обикновено `ctx`), за да изпраща съобщения към клиента.

<details>
<summary>Python</summary>

<details>
<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

В горния пример, инструментът `process_files` изпраща три нотификации към клиента, докато обработва всеки файл. Методът `ctx.info()` се използва за изпращане на информационни съобщения.

</details>

Освен това, за да активирате нотификациите, уверете се, че сървърът използва стрийминг транспорт (като `streamable-http`), а клиентът има имплементиран обработчик на съобщения за обработка на нотификации. Ето как да настроите сървъра да използва транспорта `streamable-http`:

```python
mcp.run(transport="streamable-http")
```

</details>

<details>
<summary>.NET</summary>

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

В този .NET пример, инструментът `ProcessFiles` е декориран с атрибута `Tool` и изпраща три нотификации към клиента, докато обработва всеки файл. Методът `ctx.Info()` се използва за изпращане на информационни съобщения.

За да активирате нотификациите във вашия .NET MCP сървър, уверете се, че използвате стрийминг транспорт:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

</details>

### От страна на клиента: Получаване на нотификации

Клиентът трябва да имплементира обработчик на съобщения, който да обработва и показва нотификациите веднага щом пристигнат.

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

В горния код функцията `message_handler` проверява дали входящото съобщение е нотификация. Ако е, го отпечатва; в противен случай го обработва като обикновено съобщение от сървъра. Също така се вижда как `ClientSession` се инициализира с `message_handler`, за да обработва входящите нотификации.

</details>

<details>
<summary>.NET</summary>

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

В този .NET пример функцията `MessageHandler` проверява дали входящото съобщение е нотификация. Ако е, го отпечатва; в противен случай го обработва като обикновено съобщение от сървъра. `ClientSession` се инициализира с обработчика на съобщения чрез `ClientSessionOptions`.

</details>

За да активирате нотификациите, уверете се, че сървърът използва стрийминг транспорт (като `streamable-http`), а клиентът има имплементиран обработчик на съобщения за обработка на нотификации.

## Нотификации за напредък и сценарии

Този раздел обяснява концепцията за нотификации за напредък в MCP, защо са важни и как да ги имплементирате с помощта на Streamable HTTP. Ще намерите и практическо задание за затвърждаване на знанията.

Нотификациите за напредък са съобщения в реално време, изпращани от сървъра към клиента по време на дълготрайни операции. Вместо да се чака цялата операция да приключи, сървърът държи клиента информиран за текущото състояние. Това подобрява прозрачността, потребителското изживяване и улеснява отстраняването на грешки.

**Пример:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### Защо да използваме нотификации за напредък?

Нотификациите за напредък са важни по няколко причини:

- **По-добро потребителско изживяване:** Потребителите виждат актуализации в процеса, а не само накрая.
- **Обратна връзка в реално време:** Клиентите могат да показват ленти за напредък или логове, което прави приложението по-отзивчиво.
- **По-лесно отстраняване на грешки и мониторинг:** Разработчиците и потребителите могат да видят къде процесът може да е бавен или блокиран.

### Как да имплементираме нотификации за напредък

Ето как можете да имплементирате нотификации за напредък в MCP:

- **От страна на сървъра:** Използвайте `ctx.info()` или `ctx.log()`, за да изпращате нотификации при обработка на всеки елемент. Това изпраща съобщение към клиента преди основния резултат да е готов.
- **От страна на клиента:** Имп

<summary>Python</summary>

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```

</details>

**Пример за клиент:**

<details>
<summary>Python</summary>

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)
```

</details>

## Съображения за сигурността

При реализиране на MCP сървъри с HTTP базирани трансфери, сигурността става основен приоритет, който изисква внимателно внимание към множество вектори на атака и защитни механизми.

### Обзор

Сигурността е критична при излагане на MCP сървъри през HTTP. Streamable HTTP въвежда нови възможни точки за атака и изисква прецизна конфигурация.

### Основни точки
- **Валидиране на Origin хедъра**: Винаги валидирайте `Origin` хедъра, за да предотвратите DNS rebinding атаки.
- **Свързване към localhost**: За локална разработка свързвайте сървърите към `localhost`, за да не ги излагате в публичния интернет.
- **Аутентикация**: Внедрете аутентикация (например API ключове, OAuth) за продукционни среди.
- **CORS**: Конфигурирайте политики за Cross-Origin Resource Sharing (CORS), за да ограничите достъпа.
- **HTTPS**: Използвайте HTTPS в продукция за криптиране на трафика.

### Най-добри практики
- Никога не се доверявайте на входящи заявки без проверка.
- Логвайте и наблюдавайте всички достъпи и грешки.
- Редовно обновявайте зависимостите, за да поправяте уязвимости.

### Предизвикателства
- Балансиране между сигурността и леснотата на разработка
- Осигуряване на съвместимост с различни клиентски среди


## Надграждане от SSE към Streamable HTTP

За приложения, които в момента използват Server-Sent Events (SSE), миграцията към Streamable HTTP предлага разширени възможности и по-добра дългосрочна устойчивост за вашите MCP реализации.

### Защо да надграждате?

Има две основателни причини да преминете от SSE към Streamable HTTP:

- Streamable HTTP предлага по-добра мащабируемост, съвместимост и по-богата поддръжка на нотификации в сравнение със SSE.
- Това е препоръчителният транспорт за нови MCP приложения.

### Стъпки за миграция

Ето как можете да мигрирате от SSE към Streamable HTTP във вашите MCP приложения:

- **Обновете сървърния код**, за да използва `transport="streamable-http"` в `mcp.run()`.
- **Обновете клиентския код**, за да използва `streamablehttp_client` вместо SSE клиента.
- **Имплементирайте обработчик на съобщения** в клиента за обработка на нотификациите.
- **Тествайте съвместимостта** с наличните инструменти и работни процеси.

### Поддържане на съвместимост

Препоръчително е да поддържате съвместимост с настоящите SSE клиенти по време на миграцията. Ето някои стратегии:

- Можете да поддържате и SSE, и Streamable HTTP, като пускате двата транспорта на различни крайни точки.
- Постепенно мигрирайте клиентите към новия транспорт.

### Предизвикателства

Уверете се, че сте адресирали следните предизвикателства по време на миграцията:

- Осигуряване, че всички клиенти са обновени
- Обработка на разлики в доставката на нотификации

## Съображения за сигурността

Сигурността трябва да е основен приоритет при реализиране на всеки сървър, особено при използване на HTTP базирани трансфери като Streamable HTTP в MCP.

При реализиране на MCP сървъри с HTTP базирани трансфери, сигурността става основен приоритет, който изисква внимателно внимание към множество вектори на атака и защитни механизми.

### Обзор

Сигурността е критична при излагане на MCP сървъри през HTTP. Streamable HTTP въвежда нови възможни точки за атака и изисква прецизна конфигурация.

Ето някои ключови съображения за сигурността:

- **Валидиране на Origin хедъра**: Винаги валидирайте `Origin` хедъра, за да предотвратите DNS rebinding атаки.
- **Свързване към localhost**: За локална разработка свързвайте сървърите към `localhost`, за да не ги излагате в публичния интернет.
- **Аутентикация**: Внедрете аутентикация (например API ключове, OAuth) за продукционни среди.
- **CORS**: Конфигурирайте политики за Cross-Origin Resource Sharing (CORS), за да ограничите достъпа.
- **HTTPS**: Използвайте HTTPS в продукция за криптиране на трафика.

### Най-добри практики

Освен това, ето някои най-добри практики при внедряване на сигурност в MCP стрийминг сървър:

- Никога не се доверявайте на входящи заявки без проверка.
- Логвайте и наблюдавайте всички достъпи и грешки.
- Редовно обновявайте зависимостите, за да поправяте уязвимости.

### Предизвикателства

Ще срещнете някои предизвикателства при внедряването на сигурност в MCP стрийминг сървъри:

- Балансиране между сигурността и леснотата на разработка
- Осигуряване на съвместимост с различни клиентски среди

### Задача: Създайте собствено MCP стрийминг приложение

**Сценарий:**
Създайте MCP сървър и клиент, където сървърът обработва списък с елементи (например файлове или документи) и изпраща нотификация за всеки обработен елемент. Клиентът трябва да показва всяка нотификация веднага щом пристигне.

**Стъпки:**

1. Имплементирайте сървър, който обработва списък и изпраща нотификации за всеки елемент.
2. Имплементирайте клиент с обработчик на съобщения, който показва нотификациите в реално време.
3. Тествайте реализацията, като стартирате и сървъра, и клиента, и наблюдавате нотификациите.

[Solution](./solution/README.md)

## Допълнително четиво и какво следва?

За да продължите с MCP стрийминг и да разширите знанията си, този раздел предоставя допълнителни ресурси и препоръчани следващи стъпки за изграждане на по-сложни приложения.

### Допълнително четиво

- [Microsoft: Въведение в HTTP стрийминг](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS в ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Какво следва?

- Опитайте да изградите по-сложни MCP инструменти, които използват стрийминг за анализи в реално време, чат или съвместно редактиране.
- Изследвайте интеграцията на MCP стрийминг с фронтенд рамки (React, Vue и др.) за живи UI ъпдейти.
- Следващо: [Използване на AI Toolkit за VSCode](../07-aitk/README.md)

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI преводаческа услуга [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи могат да съдържат грешки или неточности. Оригиналният документ на неговия роден език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален човешки превод. Ние не носим отговорност за каквито и да е недоразумения или неправилни тълкувания, произтичащи от използването на този превод.